<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Chat Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #87CEEB;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: none;
        }
        #loginContainer, #registerContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 300px;
        }
        #registerContainer {
            display: none;
        }
        #gameCanvas {
            background-color: #87CEEB;
        }
        #chatBox {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            max-width: 400px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        #chatMessages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
        }
        #chatInput {
            width: calc(100% - 70px);
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .leaderboard {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 200px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 5px;
    padding: 10px;
    z-index: 100;
}

.leaderboard h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 10px;
    color: #FFD700;
    font-size: 16px;
}

.playerRank {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
    padding: 3px 5px;
    border-radius: 3px;
}

.playerRank.self {
    background-color: rgba(255, 215, 0, 0.3);
    font-weight: bold;
}

.colorPicker {
    position: absolute;
    top: 210px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    z-index: 99;
}
.ammoDisplay {
    position: absolute;
    top: 40px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}
        .scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
        }
        .input-group input {
            width: 100%;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button.secondary {
            background-color: #777;
        }
        button:hover {
            opacity: 0.9;
        }
        .error-message {
            color: #f44336;
            margin: 10px 0;
            font-size: 14px;
        }
        .playerName {
            position: absolute;
            text-align: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="loginContainer">
        <h2>Welcome to Chat Lobby!</h2>
        <div class="input-group">
            <label for="loginUsername">Username:</label>
            <input type="text" id="loginUsername" placeholder="Username">
        </div>
        <div class="input-group">
            <label for="loginPassword">Password:</label>
            <input type="password" id="loginPassword" placeholder="Password">
        </div>
        <div class="error-message" id="loginError"></div>
        <button id="loginButton">Login</button>
        <p>Don't have an account? <a href="#" id="showRegisterLink">Register</a></p>
    </div>
    
    <div id="registerContainer">
        <h2>Create Account</h2>
        <div class="input-group">
            <label for="registerUsername">Username:</label>
            <input type="text" id="registerUsername" placeholder="Username (min 3 characters)">
        </div>
        <div class="input-group">
            <label for="registerPassword">Password:</label>
            <input type="password" id="registerPassword" placeholder="Password (min 4 characters)">
        </div>
        <div class="input-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" placeholder="Confirm Password">
        </div>
        <div class="error-message" id="registerError"></div>
        <button id="registerButton">Register</button>
        <p>Already have an account? <a href="#" id="showLoginLink">Login</a></p>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scoreDisplay" id="scoreDisplay">Score: 0</div>
        <div class="ammoDisplay" id="ammoDisplay">Ammo: 30/50</div>
        <div class="colorPicker">
            <p>Change your color:</p>
            <input type="color" id="colorPicker" value="#FF0000">
            <button id="applyColorButton">Apply</button>
            <hr style="margin: 10px 0;">
            <button id="logoutButton" class="secondary">Log Out</button>
            <button id="deleteAccountButton" style="background-color: #f44336;">Delete Account</button>
        </div>
        <div class="minimap" id="minimap"></div>
        <div id="chatBox">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <button id="toggleChatButton">Hide Chat</button>
                <span style="font-weight: bold;">Chat</span>
            </div>
            <div id="chatMessages"></div>
            <div>
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button id="sendButton">Send</button>
            </div>
        </div>
        <div class="leaderboard">
            <h3>Leaderboard</h3>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
    <script>
        // Connect to the server
        const socket = io();
        let chatInputFocused = false;
        // Game variables
        let canvas, ctx;
        let username = "";
        let userColor = "#FF0000";
        let players = {};

        let fishInventory = []; // Array to store caught fish
let isInventoryOpen = false;
let isFishing = false;
let fishingProgress = 0;
let fishingSuccess = false;
let fishingResult = null;
let fishingTimeout = null;
        let myId = null;
        let playerScore = 0;
        let gameObjects = {
            trees: [],
            rocks: [],
            coins: [],
            ammoPacks: [],
            ponds: []
        };
        let currentAmmo = 5; // Start with 30 bullets
        const MAX_AMMO = 10; // Maximum ammo capacity
        const AMMO_PACK_SIZE = 5; // Amount of ammo in each pack
        const AMMO_PACK_SIZE_DISPLAY = 50; // Visual size of ammo packs
        let bullets = [];
        let mouseX = 0;
        let mouseY = 0;
        let keys = {
    up: false,
    down: false,
    left: false,
    right: false
};
const inputBuffer = [];
const MAX_BUFFER_SIZE = 10;
let lastInputTime = 0;
const INPUT_SEND_INTERVAL = 50; // ms
let lastMovementUpdate = 0;
const MOVEMENT_UPDATE_INTERVAL = 33; // Send position updates at most every 33ms (~30 updates/sec)
    const BULLET_SPEED = 10;
    const BULLET_SIZE = 8;
    const BULLET_COOLDOWN = 500; // Cooldown in milliseconds
    let lastShotTime = 0;
        // Game constants
        const PLAYER_SPEED = 3;
        const PLAYER_SIZE = 50;
        const COIN_SIZE = 30;
        
        // Game assets preloading
        const playerSprite = new Image();
        playerSprite.src = '/player-sprite.png';
        const pondSprite = new Image();
        pondSprite.src = '/pond.png'; // Create this image or use a placeholder
        const fishingRodSprite = new Image();
fishingRodSprite.src = '/fishing-rod.png'; // Create this image or use a placeholder
        const treeSprite = new Image();

        const fishSprites = {};
for (let i = 1; i <= 10; i++) {
    fishSprites[`fish${i}`] = new Image();
    fishSprites[`fish${i}`].src = `/fish${i}.png`; // Create these images or use placeholders
}
        treeSprite.src = '/tree.png'; // Create this image or use a placeholder
        
        const rockSprite = new Image();
        rockSprite.src = '/rock.png'; // Create this image or use a placeholder
        
        const coinSprite = new Image();
        coinSprite.src = '/coin.png'; // Create this image or use a placeholder
        
        const ammoPackSprite = new Image();
        ammoPackSprite.src = '/ammo-rifle.png'; // Create this image or use a placeholder
        // Camera tracking
        let cameraX = 0;
        let cameraY = 0;
        const WORLD_WIDTH = 2000;
        const WORLD_HEIGHT = 1500;
        
        // DOM elements
        const loginContainer = document.getElementById('loginContainer');
        const registerContainer = document.getElementById('registerContainer');
        const gameContainer = document.getElementById('gameContainer');
        const loginError = document.getElementById('loginError');
        const registerError = document.getElementById('registerError');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        // Show/hide auth forms
        document.getElementById('showRegisterLink').addEventListener('click', (e) => {
            e.preventDefault();
            loginContainer.style.display = 'none';
            registerContainer.style.display = 'block';
        });
        
        document.getElementById('showLoginLink').addEventListener('click', (e) => {
            e.preventDefault();
            registerContainer.style.display = 'none';
            loginContainer.style.display = 'block';
        });
        
        // Register handling
        document.getElementById('registerButton').addEventListener('click', register);
        
        async function register() {
            const usernameInput = document.getElementById('registerUsername');
            const passwordInput = document.getElementById('registerPassword');
            const confirmPasswordInput = document.getElementById('confirmPassword');
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            const confirmPassword = confirmPasswordInput.value;
            
            // Reset error message
            registerError.textContent = '';
            
            // Validate inputs
            if (username.length < 3) {
                registerError.textContent = 'Username must be at least 3 characters long';
                return;
            }
            
            if (password.length < 4) {
                registerError.textContent = 'Password must be at least 4 characters long';
                return;
            }
            
            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match';
                return;
            }
            
            try {
                // Send register request to server
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    registerError.textContent = data.error || 'Registration failed';
                    return;
                }
                
                // Set color from server
                userColor = data.color;
                
                // Show login form
                registerContainer.style.display = 'none';
                loginContainer.style.display = 'block';
                loginError.textContent = 'Registration successful! Please login.';
                
                // Pre-fill username
                document.getElementById('loginUsername').value = username;
            } catch (error) {
                console.error('Registration error:', error);
                registerError.textContent = 'Server error. Please try again later.';
            }
        }
        function toggleChat() {
    const chatBox = document.getElementById('chatBox');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const toggleButton = document.getElementById('toggleChatButton');
    
    if (chatMessages.style.display === 'none') {
        // Show chat
        chatMessages.style.display = 'block';
        chatInput.style.display = 'inline-block';
        document.getElementById('sendButton').style.display = 'inline-block';
        toggleButton.textContent = 'Hide Chat';
    } else {
        // Hide chat
        chatMessages.style.display = 'none';
        chatInput.style.display = 'none';
        document.getElementById('sendButton').style.display = 'none';
        toggleButton.textContent = 'Show Chat';
    }
}

        // Login handling
        document.getElementById('loginButton').addEventListener('click', login);
        document.getElementById('loginUsername').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('loginPassword').focus();
            }
        });
        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') login();
        });
        
        async function login() {
            const usernameInput = document.getElementById('loginUsername');
            const passwordInput = document.getElementById('loginPassword');
            
            username = usernameInput.value.trim();
            const password = passwordInput.value;
            
            // Reset error message
            loginError.textContent = '';
            
            // Validate inputs
            if (!username || !password) {
                loginError.textContent = 'Username and password are required';
                return;
            }
            
            try {
                // Send login request to server
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    loginError.textContent = data.error || 'Login failed';
                    return;
                }
                
                // Set user data from database
                userColor = data.color;
                playerScore = data.score || 0;
                document.getElementById('colorPicker').value = userColor;
                
                // Update score display
                scoreDisplay.textContent = `Score: ${playerScore}`;
                
                // Join the game using socket
                socket.emit('join_game', {
                    username: username,
                    color: userColor
                });
                
                // Wait for server confirmation
                socket.once('join_success', (playerId) => {
                    myId = playerId;
                    
                    // Hide login and show game
                    loginContainer.style.display = 'none';
                    gameContainer.style.display = 'block';
                    
                    // Initialize the game
                    initGame();
                });
            } catch (error) {
                console.error('Login error:', error);
                loginError.textContent = 'Server error. Please try again later.';
            }
        }
        
        // Initialize the game after successful login
        function initGame() {
            // Set up the canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to window size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Set up chat functionality
            document.getElementById('sendButton').addEventListener('click', sendMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
            document.getElementById('chatInput').addEventListener('focus', () => {
    chatInputFocused = true;
    
    // Reset key states when focusing the chat input
    keys.up = false;
    keys.down = false;
    keys.left = false;
    keys.right = false;
});

document.getElementById('chatInput').addEventListener('blur', () => {
    chatInputFocused = false;
});

// Set up toggle chat button
document.getElementById('toggleChatButton').addEventListener('click', toggleChat);
            // Set up color picker
            document.getElementById('applyColorButton').addEventListener('click', changeColor);
            
            // Set up movement controls
            
// Add click handler for fishing
canvas.addEventListener('click', (e) => {
    // Only allow fishing when not already fishing and not typing in chat
    if (!isFishing && !chatInputFocused && isPlayerInWater() && currentAmmo > 0) {
        startFishing();
    }
});

// Add 'E' key handler for fish inventory
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && !chatInputFocused) {
        toggleFishInventory();
    }
});
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('mousemove', (e) => {
            // Get mouse position relative to canvas
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateLeaderboard();
            });
           
// Add spacebar shooting in handleKeyDown function, or as a separate event listener:
         window.addEventListener('keydown', (e) => {
            
            if (e.code === 'Space' || e.key === ' ') {
            // Check if player has ammo
           shootBullet();
        }
        });
        updateAmmoDisplay();
            // Set up minimap
            setupMinimap();
            
            // Start the game loop
            requestAnimationFrame(gameLoop);
            
            // Listen for server updates
            socket.on('game_state', (gameState) => {
                let prevPosition = null;
    if (myId && players[myId]) {
        prevPosition = {
            x: players[myId].x,
            y: players[myId].y
        };
    }
                players = gameState.players;
                

                if (prevPosition && myId && players[myId]) {
        const serverPos = players[myId];
        const distX = serverPos.x - prevPosition.x;
        const distY = serverPos.y - prevPosition.y;
        const distance = Math.sqrt(distX * distX + distY * distY);
        
        // Only reconcile if server and client positions differ significantly
        if (distance > 10) {
            // Smoothly move to the correct position over a few frames
            const reconciliationSpeed = 0.3; // Adjust as needed
            players[myId].x = prevPosition.x + distX * reconciliationSpeed;
            players[myId].y = prevPosition.y + distY * reconciliationSpeed;
        }
    }
                // Update game objects if available
                if (gameState.gameObjects) {
                    gameObjects = gameState.gameObjects;
                }
                
                // Update score display if this player's score changed
                if (myId && players[myId]) {
                    if (playerScore !== players[myId].score) {
                        playerScore = players[myId].score;
                        scoreDisplay.textContent = `Score: ${playerScore}`;
                        if (currentAmmo !== players[myId].ammo) {
                     currentAmmo = players[myId].ammo;
                updateAmmoDisplay();
                 }
                    }
                }
                socket.on('bullets_update', (serverBullets) => {
                // Add any new bullets from server that aren't in our local array
                for (const serverBullet of serverBullets) {
             if (!bullets.some(b => b.id === serverBullet.id)) {
                   bullets.push(serverBullet);
            }
        }
   
});
socket.on('fish_deleted', (data) => {
    if (data.success) {
        // Server confirmed deletion, show notification
        addChatMessage('System', `${data.fishName} has been removed from your inventory.`);
        
        // Request updated inventory to ensure client and server are in sync
        socket.emit('get_fish_inventory');
    } else {
        // Handle error
        addChatMessage('System', 'Failed to remove fish: ' + (data.error || 'Unknown error'));
    }
});
    socket.on('ammo_update', (data) => {
    currentAmmo = data.ammo;
    updateAmmoDisplay();
    });
    socket.on('player_hit', (data) => {
    const { playerId, damage, shooterId } = data;
    
    // If this is the player being hit, show visual feedback
    if (playerId === myId) {
        // Flash the screen red or play hurt animation
        flashScreen('rgba(255,0,0,0.3)');
        
        // Decrease score for the player being hit
        if (players[playerId]) {
            players[playerId].score -= damage;
            
            // Update local score if it's the current player
            playerScore = players[playerId].score;
            scoreDisplay.textContent = `Score: ${playerScore}`;
        }
    }
    
    // If this is the player who shot, show hit confirmation
    if (shooterId === myId) {
        // Show hit marker or play hit sound
        playHitConfirmSound();
        
        // Increase score for the shooter
        if (players[shooterId]) {
            players[shooterId].score += damage;
            
            // Update local score if it's the current player
            if (shooterId === myId) {
                playerScore = players[shooterId].score;
                scoreDisplay.textContent = `Score: ${playerScore}`;
            }
        }
    }
    
    // Update leaderboard
    updateLeaderboard();
});
                // Update minimap
                updateMinimap();
            });
            
            socket.on('chat_message', (data) => {
                addChatMessage(data.username, data.message);
            });
        }
        socket.on('fish_caught', (fishData) => {
    // Add the fish to inventory
    fishInventory.push(fishData);
    
    // Show notification
    addChatMessage('System', `You caught a ${fishData.rarity} ${fishData.name} (${fishData.size} cm)!`);
    
    // Sort inventory by rarity and size
    fishInventory.sort((a, b) => {
        const rarityOrder = { 'Common': 0, 'Uncommon': 1, 'Rare': 2, 'Epic': 3, 'Legendary': 4 };
        return rarityOrder[b.rarity] - rarityOrder[a.rarity] || b.size - a.size;
    });
});

socket.on('fish_inventory', (inventory) => {
    fishInventory = inventory;
});
        // Set up logout and delete account buttons
document.getElementById('logoutButton').addEventListener('click', handleLogout);
document.getElementById('deleteAccountButton').addEventListener('click', confirmDeleteAccount);

// Logout function
function handleLogout() {
    // Disconnect from the socket
    socket.disconnect();
    
    // Hide game container and show login form
    gameContainer.style.display = 'none';
    loginContainer.style.display = 'block';
    
    // Clear password field
    document.getElementById('loginPassword').value = '';
    
    // Optional: Show a message to the user
    loginError.textContent = 'You have been logged out successfully.';
    loginError.style.color = 'green';
}

// Delete account confirmation
function confirmDeleteAccount() {
    if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
        // Call the delete account API
        deleteAccount();
    }
}

// Delete account function
async function deleteAccount() {
    try {
        // Send delete request to server
        const response = await fetch('/api/delete-account', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: username })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            alert(`Failed to delete account: ${data.error}`);
            return;
        }
        
        // Disconnect socket
        socket.disconnect();
        
        // Show login screen
        gameContainer.style.display = 'none';
        loginContainer.style.display = 'block';
        
        // Show success message
        loginError.textContent = 'Your account has been deleted successfully.';
        loginError.style.color = 'green';
        
        // Clear fields
        document.getElementById('loginUsername').value = '';
        document.getElementById('loginPassword').value = '';
        
    } catch (error) {
        console.error('Delete account error:', error);
        alert('Server error. Please try again later.');
    }
}
        function setupMinimap() {
            const minimap = document.getElementById('minimap');
            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
            minimap.appendChild(minimapCanvas);
        }
        
        function updateMinimap() {
            const minimap = document.querySelector('#minimap canvas');
            const minimapCtx = minimap.getContext('2d');
            const minimapWidth = minimap.width;
            const minimapHeight = minimap.height;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw world boundary
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.strokeRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw trees as green dots
            minimapCtx.fillStyle = '#0a5';
            gameObjects.trees.forEach(tree => {
                minimapCtx.fillRect(
                    (tree.x / WORLD_WIDTH) * minimapWidth,
                    (tree.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
            });
            
            // Draw rocks as gray dots
            minimapCtx.fillStyle = '#777';
            gameObjects.rocks.forEach(rock => {
                minimapCtx.fillRect(
                    (rock.x / WORLD_WIDTH) * minimapWidth,
                    (rock.y / WORLD_HEIGHT) * minimapHeight,
                    2, 2
                );
            });
            
            // Draw coins as yellow dots
            minimapCtx.fillStyle = '#ff0';
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    minimapCtx.fillRect(
                        (coin.x / WORLD_WIDTH) * minimapWidth,
                        (coin.y / WORLD_HEIGHT) * minimapHeight,
                        3, 3
                    );
                }
            });
            //draw ammo packs as blue dots
            minimapCtx.fillStyle = '#00f';
            gameObjects.ammoPacks.forEach(ammoPack => {
             if (!ammoPack.collected) {
                minimapCtx.fillRect(
                    (ammoPack.x / WORLD_WIDTH) * minimapWidth,
                    (ammoPack.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
             }
        });
            // Draw players
            Object.values(players).forEach(player => {
                minimapCtx.fillStyle = player.color || '#f00';
                minimapCtx.fillRect(
                    (player.x / WORLD_WIDTH) * minimapWidth,
                    (player.y / WORLD_HEIGHT) * minimapHeight,
                    4, 4
                );
            });
            
            // Highlight current player
            if (myId && players[myId]) {
                const player = players[myId];
                minimapCtx.strokeStyle = '#fff';
                minimapCtx.strokeRect(
                    (player.x / WORLD_WIDTH) * minimapWidth - 2,
                    (player.y / WORLD_HEIGHT) * minimapHeight - 2,
                    8, 8
                );
                
                // Draw view rectangle
                minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                minimapCtx.strokeRect(
                    (cameraX / WORLD_WIDTH) * minimapWidth,
                    (cameraY / WORLD_HEIGHT) * minimapHeight,
                    (canvas.width / WORLD_WIDTH) * minimapWidth,
                    (canvas.height / WORLD_HEIGHT) * minimapHeight
                );
            }
        }
        
        function changeColor() {
            const colorPicker = document.getElementById('colorPicker');
            const newColor = colorPicker.value;
            
            // Update local color
            userColor = newColor;
            
            // Send to server
            socket.emit('change_color', { color: newColor });
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function handleKeyDown(e) {
            if (chatInputFocused && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
        return;
    }
            const input = updateKeyState(e, true);
    if (input) addToInputBuffer(input);
}

function handleKeyUp(e) {
    if (chatInputFocused && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
        return;
    }
    const input = updateKeyState(e, false);
    if (input) addToInputBuffer(input);
}

function updateKeyState(e, isPressed) {
    let input = null;
    switch(e.key) {
        case 'ArrowUp':
        case 'w':
            keys.up = isPressed;
            input = { type: 'move', key: 'up', pressed: isPressed };
            break;
        case 'ArrowDown':
        case 's':
            keys.down = isPressed;
            input = { type: 'move', key: 'down', pressed: isPressed };
            break;
        case 'ArrowLeft':
        case 'a':
            keys.left = isPressed;
            input = { type: 'move', key: 'left', pressed: isPressed };
            break;
        case 'ArrowRight':
        case 'd':
            keys.right = isPressed;
            input = { type: 'move', key: 'right', pressed: isPressed };
            break;
        case ' ': // Space
            if (isPressed) {
                shootBullet();
                input = { type: 'shoot' };
            }
            break;
    }
    
    return input;
}
function addToInputBuffer(input) {
    input.timestamp = Date.now();
    input.sequence = inputBuffer.length > 0 ? 
                    inputBuffer[inputBuffer.length - 1].sequence + 1 : 0;
    
    inputBuffer.push(input);
    
    // Keep buffer size limited
    if (inputBuffer.length > MAX_BUFFER_SIZE) {
        inputBuffer.shift();
    }
    
    // Process and send inputs
    processInputBuffer();
}
function processInputBuffer() {
    const now = Date.now();
    
    // Only send updates at a fixed interval
    if (now - lastInputTime >= INPUT_SEND_INTERVAL && inputBuffer.length > 0) {
        lastInputTime = now;
        
        // Send all buffered inputs at once
        socket.emit('player_inputs', inputBuffer);
        
        // Clear buffer after sending
        // inputBuffer.length = 0; // Uncomment if you want to clear after sending
    }
}
function updateLeaderboard() {
    const leaderboardContent = document.getElementById('leaderboardContent');
    if (!leaderboardContent) return;
    
    // Clear existing content
    leaderboardContent.innerHTML = '';
    
    // Get all players and sort by score
    const playerList = Object.values(players).sort((a, b) => b.score - a.score);
    
    // Add each player to the leaderboard
    playerList.forEach((player, index) => {
        const playerRow = document.createElement('div');
        playerRow.className = 'playerRank';
        
        // Highlight current player
        if (player.id === myId) {
            playerRow.classList.add('self');
        }
        
        // Add color indicator
        const colorIndicator = document.createElement('span');
        colorIndicator.style.display = 'inline-block';
        colorIndicator.style.width = '10px';
        colorIndicator.style.height = '10px';
        colorIndicator.style.backgroundColor = player.color;
        colorIndicator.style.marginRight = '5px';
        colorIndicator.style.borderRadius = '50%';
        
        // Create rank and name element
        const rankAndName = document.createElement('span');
        rankAndName.textContent = `${index + 1}. ${player.username}`;
        
        // Create score element
        const score = document.createElement('span');
        score.textContent = player.score;
        
        // Add elements to row
        playerRow.appendChild(colorIndicator);
        playerRow.appendChild(rankAndName);
        playerRow.appendChild(score);
        
        // Add row to leaderboard
        leaderboardContent.appendChild(playerRow);
    });
}
function shootBullet() {
    if (!myId || !players[myId] || chatInputFocused) return;
    
    if (currentAmmo <= 0) {
        // Play empty gun sound or show message
        showAmmoWarning();
        return;
    }
    // Check cooldown
    const currentTime = Date.now();
    if (currentTime - lastShotTime < BULLET_COOLDOWN) return;
    lastShotTime = currentTime;
    //Decrease ammo
    currentAmmo--;
    updateAmmoDisplay();
    const player = players[myId];
    
    // Calculate bullet starting position (center of player)
    const startX = player.x + PLAYER_SIZE / 2;
    const startY = player.y + PLAYER_SIZE / 2;
    
    // Calculate direction vector from player to mouse, considering camera position
    const targetX = mouseX + cameraX;
    const targetY = mouseY + cameraY;
    
    // Calculate direction vector
    let dirX = targetX - startX;
    let dirY = targetY - startY;
    
    // Normalize the direction vector
    const length = Math.sqrt(dirX * dirX + dirY * dirY);
    if (length > 0) {
        dirX /= length;
        dirY /= length;
    }
    
    // Create bullet object
    const bullet = {
        id: `bullet-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        x: startX,
        y: startY,
        dirX: dirX,
        dirY: dirY,
        playerId: myId,
        color: player.color
    };
    
    // Add to local bullets array
    bullets.push(bullet);
    
    // Send to server
    socket.emit('shoot_bullet', bullet);
     // Update server about ammo count
     socket.emit('update_ammo', { ammo: currentAmmo });
    // Play sound effect
    playShootSound();
}

// 4. Add sound effect function
function playShootSound() {
    const shootSound = new Audio('/gun.mp3'); // Create this sound or use a placeholder
    shootSound.volume = 0.2;
    shootSound.play().catch(e => console.log('Audio play failed:', e));
}
function updateAmmoDisplay() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        ammoDisplay.textContent = `Ammo: ${currentAmmo}/${MAX_AMMO}`;
        
        // Change color based on ammo level
        if (currentAmmo <= 5) {
            ammoDisplay.style.color = '#FF0000'; // Red for low ammo
        } else if (currentAmmo <= 15) {
            ammoDisplay.style.color = '#FFA500'; // Orange for medium ammo
        } else {
            ammoDisplay.style.color = '#000000'; // Black for normal
        }
    }
}
function showAmmoWarning() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        // Flash the ammo display
        ammoDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        setTimeout(() => {
            ammoDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        }, 300);
        
        // Show message in chat
        addChatMessage('System', 'Out of ammo! Find ammo packs to reload.');
    }
}
// 5. Add bullet update and rendering functions
function updateBullets(deltaTime) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        // Move bullet
        bullet.x += bullet.dirX * BULLET_SPEED;
        bullet.y += bullet.dirY * BULLET_SPEED;
        
        // Check if bullet is out of bounds
        if (
            bullet.x < 0 ||
            bullet.x > WORLD_WIDTH ||
            bullet.y < 0 ||
            bullet.y > WORLD_HEIGHT
        ) {
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with obstacles
        if (checkBulletObstacleCollision(bullet)) {
            // Add visual effect for collision
            createBulletImpactEffect(bullet.x, bullet.y);
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with other players (only for visual feedback)
        for (const playerId in players) {
    // Don't collide with the shooter
    if (playerId === bullet.playerId) continue;
    
    const player = players[playerId];
    
    // Use a more reliable collision detection algorithm
    // Calculate distances between centers
    const bulletCenterX = bullet.x;
    const bulletCenterY = bullet.y;
    const playerCenterX = player.x + PLAYER_SIZE/2;
    const playerCenterY = player.y + PLAYER_SIZE/2;
    
    // Check if the bullet is inside the player's bounding box
    if (
        bulletCenterX >= player.x &&
        bulletCenterX <= player.x + PLAYER_SIZE &&
        bulletCenterY >= player.y &&
        bulletCenterY <= player.y + PLAYER_SIZE
    ) {
        // Visual effect only
        createHitEffect(bullet.x, bullet.y);
        
        // Notify server about the hit - this is the key change
        socket.emit('bullet_hit_player', {
            bulletId: bullet.id,
            playerId: playerId
        });
        
        // Remove bullet locally
        bullets.splice(i, 1);
        break;
    }
}
    }
}
function createBulletImpactEffect(x, y) {
    // Create impact particle effect
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        const size = Math.random() * 3 + 2;
        const lifetime = Math.random() * 15 + 5;
        
        const particle = {
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            lifetime: lifetime,
            maxLifetime: lifetime,
            color: '#888888'
        };
        
        // If you have a particles array, add it there
        // particles.push(particle);
        
        // For simplicity, we'll just draw them directly
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Play impact sound
    const impactSound = new Audio('/impact-sound.mp3'); // Create this sound or use a placeholder
    impactSound.volume = 0.2;
    impactSound.play().catch(e => console.log('Audio play failed:', e));
}
// Find the gameLoop function in your code and modify the part where you draw the ground
// Replace the current ground drawing code with this:

function gameLoop() {
    if (!myId || !players[myId]) {
        requestAnimationFrame(gameLoop);
        return;
    }
    // Update player movement based on key states
    updatePlayerMovement();
    // Update camera position to follow player
    const player = players[myId];
    cameraX = player.x - canvas.width / 2 + PLAYER_SIZE / 2;
    cameraY = player.y - canvas.height / 2 + PLAYER_SIZE / 2;
    
    // Clamp camera to world bounds
    cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));
    cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - canvas.height));
    
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw sky background
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw pixelated grass background
    drawPixelatedGrass();
    
    // Draw clouds (optional)
    drawClouds();
    
    // Rest of your drawing code...
    drawGameObjects(gameObjects.rocks, rockSprite, 'gray');
    drawGameObjects(gameObjects.trees, treeSprite, 'green');
    drawCoins();
    drawAmmoPacks();
    drawPlayers();
    updateBullets(16);
    drawBullets();
    
    // Continue the game loop
    requestAnimationFrame(gameLoop);
}

// Add this new function to create the pixelated grass effect
function drawPixelatedGrass() {
    // Use larger pixels for better performance
    const pixelSize = 16; // Larger pixels for better performance
    
    // Calculate visible area based on camera position
    // Only draw pixels that are actually visible on screen
    const startX = Math.floor(cameraX / pixelSize) * pixelSize;
    const startY = Math.floor(cameraY / pixelSize) * pixelSize;
    const endX = startX + canvas.width + pixelSize;
    const endY = startY + canvas.height + pixelSize;
    
    // Simpler color palette for better performance
    const grassColors = [
        '#7CFC00', // Base bright green (main color)
        '#6BC400', // Slightly darker green
        '#5FB300', // Medium green
        '#73DB0A'  // Yellowish green
    ];
    
    // Pre-calculated pattern lookup for better performance
    // This creates a 16x16 pattern that repeats
    if (!window.grassPattern) {
        // Create a reusable pattern (only computed once)
        window.grassPattern = [];
        for (let px = 0; px < 16; px++) {
            window.grassPattern[px] = [];
            for (let py = 0; py < 16; py++) {
                // Generate values for each position in the repeating pattern
                const patternSeed = Math.sin(px * 0.7) * 10000 + Math.cos(py * 0.7) * 10000;
                const val = Math.abs(patternSeed) % 100;
                
                // Determine color index based on the value
                let colorIndex;
                if (val < 60) colorIndex = 0; // Main color (60%)
                else if (val < 85) colorIndex = 1; // Second color (25%)
                else if (val < 95) colorIndex = 2; // Third color (10%)
                else colorIndex = 3; // Fourth color (5%)
                
                window.grassPattern[px][py] = colorIndex;
            }
        }
    }
    
    // Draw the pixelated grass efficiently
    for (let x = startX; x < endX; x += pixelSize) {
        for (let y = startY; y < endY; y += pixelSize) {
            // Use a repeating pattern based on world position
            const patternX = Math.abs(Math.floor(x / pixelSize) % 16);
            const patternY = Math.abs(Math.floor(y / pixelSize) % 16);
            
            // Look up the color index from our pre-computed pattern
            const colorIndex = window.grassPattern[patternX][patternY];
            
            // Draw the grass pixel
            ctx.fillStyle = grassColors[colorIndex];
            ctx.fillRect(
                x - cameraX, 
                y - cameraY, 
                pixelSize, 
                pixelSize
            );
            
            // Add minimal detail elements (only to about 1% of pixels)
            // This uses a very efficient calculation
            if ((patternX + patternY) % 16 === 0) {
                // Simple highlight detail that's very cheap to draw
                ctx.fillStyle = '#AEFF00';
                ctx.fillRect(
                    x - cameraX + pixelSize/4, 
                    y - cameraY + pixelSize/4, 
                    pixelSize/2, 
                    pixelSize/2
                );
            }
        }
    }
}
function checkBulletObstacleCollision(bullet) {
    // Check rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        if (
            bullet.x >= rock.x &&
            bullet.x <= rock.x + rockSize &&
            bullet.y >= rock.y &&
            bullet.y <= rock.y + rockSize
        ) {
            return true;
        }
    }
    
    // Check trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Only collide with the trunk part
        if (
            bullet.x >= tree.x + treeSize * 0.3 &&
            bullet.x <= tree.x + treeSize * 0.7 &&
            bullet.y >= tree.y + treeSize * 0.5 &&
            bullet.y <= tree.y + treeSize
        ) {
            return true;
        }
    }
    
    return false;
}

// 6. Add hit effect function for visual feedback
function createHitEffect(x, y) {
    // This could be expanded with particles, animation, etc.
    const hitSound = new Audio('/hit-sound.mp3'); // Create this sound or use a placeholder
    hitSound.volume = 0.3;
    hitSound.play().catch(e => console.log('Audio play failed:', e));
}


function drawPonds() {
    gameObjects.ponds.forEach(pond => {
        const drawX = pond.x - cameraX;
        const drawY = pond.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + pond.width >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + pond.height >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to colored shape
            try {
                ctx.drawImage(pondSprite, drawX, drawY, pond.width, pond.height);
            } catch (e) {
                // Fallback to blue oval
                ctx.fillStyle = '#4FC3F7';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/2, 
                    pond.height/2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add some detail to the pond
                ctx.fillStyle = '#29B6F6';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/3, 
                    pond.height/3, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add ripple effects
                drawPondRipples(drawX, drawY, pond);
            }
            
            // Animate water by drawing semi-transparent waves
            drawWaterAnimation(drawX, drawY, pond);
        }
    });
}

// Add ripple effects to pond
function drawPondRipples(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2;
    
    // Draw 3 elliptical ripples that grow and fade over time
    for (let i = 0; i < 3; i++) {
        const offset = i * Math.PI * 0.6; // Offset each ripple
        const size = ((time + offset) % 3) / 3; // 0 to 1 value for size
        
        if (size > 0.1) { // Only draw visible ripples
            ctx.globalAlpha = 0.3 - size * 0.3; // Fade out as they grow
            ctx.beginPath();
            ctx.ellipse(
                drawX + pond.width/2, 
                drawY + pond.height/2, 
                pond.width/2 * size + pond.width/4, 
                pond.height/2 * size + pond.height/4, 
                0, 0, Math.PI * 2
            );
            ctx.stroke();
        }
    }
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

// Animate water surface
function drawWaterAnimation(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    
    // Draw some animated wave lines on the water
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1.5;
    
    // Create wave patterns
    for (let i = 0; i < 5; i++) {
        const yOffset = (i * pond.height/5) + Math.sin(time * 2 + i) * 5;
        
        if (yOffset > 0 && yOffset < pond.height) {
            ctx.beginPath();
            ctx.moveTo(drawX + pond.width * 0.2, drawY + yOffset);
            
            // Create wavy line
            for (let x = 0; x <= 6; x++) {
                const waveX = drawX + pond.width * (0.2 + x * 0.1);
                const waveY = drawY + yOffset + Math.sin(time * 3 + x + i) * 3;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.stroke();
        }
    }
}
// 7. Add bullet drawing function
function drawBullets() {
    for (const bullet of bullets) {
        const drawX = bullet.x - cameraX;
        const drawY = bullet.y - cameraY;
        
        // Only draw if visible on screen
        if (
            drawX + BULLET_SIZE >= 0 &&
            drawX <= canvas.width &&
            drawY + BULLET_SIZE >= 0 &&
            drawY <= canvas.height
        ) {
            // Draw bullet
            ctx.fillStyle = bullet.color || '#FF0000';
            ctx.beginPath();
            ctx.arc(drawX, drawY, BULLET_SIZE/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Optional: Draw trail/tail
            ctx.strokeStyle = bullet.color || '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX, drawY);
            ctx.lineTo(drawX - bullet.dirX * 10, drawY - bullet.dirY * 10);
            ctx.stroke();
        }
    }
}
// Function to draw ammo packs
function drawAmmoPacks() {
    ctx.fillStyle = '#00AAFF'; // Blue color for ammo packs
    
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            const drawX = ammoPack.x - cameraX;
            const drawY = ammoPack.y - cameraY;
            
            // Only draw if visible on screen
            if (
                drawX + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawX <= canvas.width &&
                drawY + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawY <= canvas.height
            ) {
                // Try to draw sprite
                try {
                    ctx.drawImage(ammoPackSprite, drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                } catch (e) {
                    // Fallback to colored rectangle with an "A" on it
                    ctx.fillStyle = '#0088CC';
                    ctx.fillRect(drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                    
                    // Draw a white "A" on the ammo pack
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('A', drawX + AMMO_PACK_SIZE_DISPLAY/2, drawY + AMMO_PACK_SIZE_DISPLAY/2 + 7);
                    
                    // Reset fill style
                    ctx.fillStyle = '#00AAFF';
                }
                
                // Animate ammo pack bob up and down (similar to coins)
                ammoPack.bobOffset = ammoPack.bobOffset || 0;
                ammoPack.bobDirection = ammoPack.bobDirection || 1;
                ammoPack.bobOffset += 0.05 * ammoPack.bobDirection;
                
                if (ammoPack.bobOffset > 5 || ammoPack.bobOffset < 0) {
                    ammoPack.bobDirection *= -1;
                }
            }
        }
    });
}
let lastFlashTime = 0;
const FLASH_COOLDOWN = 500;
function flashScreen(color) {
    const currentTime = Date.now();
    if (currentTime - lastFlashTime < FLASH_COOLDOWN) return;
    lastFlashTime = currentTime;
    // Create overlay div
    
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.boxShadow = 'inset 0 0 50px 20px ' + color; // Create an inset shadow instead of background
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '1000';
    flash.style.backgroundColor = 'transparent'; // No background color
    
    // Add to game container
    gameContainer.appendChild(flash);
    
    // Fade out and remove
    setTimeout(() => {
        flash.style.transition = 'box-shadow 0.3s';
        flash.style.boxShadow = 'inset 0 0 0 0 transparent';
        setTimeout(() => {
            gameContainer.removeChild(flash);
        }, 300);
    }, 100);
}

function playHitConfirmSound() {
    const hitConfirmSound = new Audio('/hit-confirm.mp3'); // Create this sound or use a placeholder
    hitConfirmSound.volume = 0.2;
    hitConfirmSound.play().catch(e => console.log('Audio play failed:', e));
}

        function checkCoinCollection(player) {
            // Define player hitbox
            const playerHitbox = {
                x: player.x + 10,
                y: player.y + 10,
                width: PLAYER_SIZE - 20,
                height: PLAYER_SIZE - 20
            };
            
            // Check collision with each coin
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    // Define coin hitbox
                    const coinHitbox = {
                        x: coin.x + 5,
                        y: coin.y + 5,
                        width: COIN_SIZE - 10,
                        height: COIN_SIZE - 10
                    };
                    
                    // Check hitbox overlap
                    if (
                        playerHitbox.x < coinHitbox.x + coinHitbox.width &&
                        playerHitbox.x + playerHitbox.width > coinHitbox.x &&
                        playerHitbox.y < coinHitbox.y + coinHitbox.height &&
                        playerHitbox.y + playerHitbox.height > coinHitbox.y
                    ) {
                        // Collect the coin (server will validate)
                        socket.emit('collect_coin', coin.id);
                        
                        // Play coin collection sound
                        playCoinSound();
                    }
                }
            });
        }
        function checkAmmoPackCollection(player) {
    // Define player hitbox
    const playerHitbox = {
        x: player.x + 10,
        y: player.y + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Check collision with each ammo pack
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            // Define ammo pack hitbox
            const ammoPackHitbox = {
                x: ammoPack.x + 5,
                y: ammoPack.y + 5,
                width: AMMO_PACK_SIZE_DISPLAY - 10,
                height: AMMO_PACK_SIZE_DISPLAY - 10
            };
            
            // Check hitbox overlap
            if (
                playerHitbox.x < ammoPackHitbox.x + ammoPackHitbox.width &&
                playerHitbox.x + playerHitbox.width > ammoPackHitbox.x &&
                playerHitbox.y < ammoPackHitbox.y + ammoPackHitbox.height &&
                playerHitbox.y + playerHitbox.height > ammoPackHitbox.y
            ) {
                // Collect the ammo pack (server will validate)
                socket.emit('collect_ammo', ammoPack.id);
                
                // Play ammo collection sound
                playAmmoSound();
            }
        }
    });
}
function playAmmoSound() {
    const ammoSound = new Audio('/ammo-sound.mp3'); // Create this sound or use a placeholder
    ammoSound.volume = 0.4;
    ammoSound.play().catch(e => console.log('Audio play failed:', e));
}
        function checkCollision(player, newX, newY) {
    // Define player hitbox with some padding for better gameplay
    const playerHitbox = {
        x: newX + 10,
        y: newY + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Check collision with trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Trees have a smaller collision box than visual size
        const treeHitbox = {
            x: tree.x + treeSize * 0.2,
            y: tree.y + treeSize * 0.5, // Mostly bottom part (trunk)
            width: treeSize * 0.6,
            height: treeSize * 0.5
        };
        
        if (
            playerHitbox.x < treeHitbox.x + treeHitbox.width &&
            playerHitbox.x + playerHitbox.width > treeHitbox.x &&
            playerHitbox.y < treeHitbox.y + treeHitbox.height &&
            playerHitbox.y + playerHitbox.height > treeHitbox.y
        ) {
            return true; // Collision detected
        }
    }
    
    // Check collision with rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        // Rocks have a slightly smaller collision box
        const rockHitbox = {
            x: rock.x + rockSize * 0.1,
            y: rock.y + rockSize * 0.1,
            width: rockSize * 0.8,
            height: rockSize * 0.8
        };
        
        if (
            playerHitbox.x < rockHitbox.x + rockHitbox.width &&
            playerHitbox.x + playerHitbox.width > rockHitbox.x &&
            playerHitbox.y < rockHitbox.y + rockHitbox.height &&
            playerHitbox.y + playerHitbox.height > rockHitbox.y
        ) {
            return true; // Collision detected
        }
    }
    
    return false; // No collision
}
        function playCoinSound() {
            const coinSound = new Audio('/coin-sound.mp3'); // Create this sound or use a placeholder
            coinSound.volume = 0.3;
            coinSound.play().catch(e => console.log('Audio play failed:', e));
        }
        
        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message.length > 0) {
                socket.emit('chat_message', message);
                chatInput.value = '';
            }
        }
        
        function addChatMessage(username, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.textContent = `${username}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function gameLoop() {
            if (!myId || !players[myId]) {
                requestAnimationFrame(gameLoop);
                return;
            }
             // Update player movement based on key states
            updatePlayerMovement();
            // Update camera position to follow player
            const player = players[myId];
            cameraX = player.x - canvas.width / 2 + PLAYER_SIZE / 2;
            cameraY = player.y - canvas.height / 2 + PLAYER_SIZE / 2;
            
            // Clamp camera to world bounds
            cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - canvas.height));
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            ctx.fillStyle = '#7CFC00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds (optional)
            drawPixelatedGrass();
          
           
            // Draw rocks
            drawGameObjects(gameObjects.rocks, rockSprite, 'gray');
            
            //draw ponds
            drawPonds();
            // Draw trees
            drawGameObjects(gameObjects.trees, treeSprite, 'green');
            
            // Draw coins
            drawCoins();
            drawPlayers();

            
             // Draw ammo packs
            drawAmmoPacks();
            if (isFishing) {
        drawFishingProgress();
    }
    
    // Draw fish inventory if open
    if (isInventoryOpen) {
        drawFishInventory();
    }
    
    updateBullets(16);
    drawBullets();
    drawClouds();
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }
        function updatePlayerMovement() {
    if (!myId || !players[myId]) return;
    
    const player = players[myId];
    let newX = player.x;
    let newY = player.y;
    let moved = false;
    
    // Calculate movement based on active keys
    if (keys.up) {
        newY -= PLAYER_SPEED;
        moved = true;
    }
    if (keys.down) {
        newY += PLAYER_SPEED;
        moved = true;
    }
    if (keys.left) {
        newX -= PLAYER_SPEED;
        moved = true;
    }
    if (keys.right) {
        newX += PLAYER_SPEED;
        moved = true;
    }
    
    // If diagonal movement, normalize speed
    if ((keys.up || keys.down) && (keys.left || keys.right)) {
        const diagonalSpeed = PLAYER_SPEED / Math.sqrt(2);
        if (keys.up) newY = player.y - diagonalSpeed;
        if (keys.down) newY = player.y + diagonalSpeed;
        if (keys.left) newX = player.x - diagonalSpeed;
        if (keys.right) newX = player.x + diagonalSpeed;
    }
    
    // Keep player within world bounds
    if (newX < 0) newX = 0;
    if (newY < 0) newY = 0;
    if (newX > WORLD_WIDTH - PLAYER_SIZE) newX = WORLD_WIDTH - PLAYER_SIZE;
    if (newY > WORLD_HEIGHT - PLAYER_SIZE) newY = WORLD_HEIGHT - PLAYER_SIZE;
    
    // Check for collision with obstacles
    if (moved && !checkCollision(player, newX, newY)) {
        // Apply movement locally first (client-side prediction)
        players[myId].x = newX;
        players[myId].y = newY;
        
        // Check for coin and ammo pack collection
        checkCoinCollection(player);
        checkAmmoPackCollection(player);
        
        // Send updated position to server
        const now = Date.now();
        if (now - lastMovementUpdate >= MOVEMENT_UPDATE_INTERVAL) {
            lastMovementUpdate = now;
            socket.emit('move', {
                x: newX,
                y: newY
            });
        }
    }
}
function drawClouds() {
    // Cloud settings
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    
    // Use time to animate clouds
    const time = Date.now() * 0.0002;
    
    // Create fewer clouds with larger minimum size
    // and make them move horizontally
    const cloudSpacingX = 800; // Increased spacing (fewer clouds)
    const cloudSpacingY = 500; // Increased vertical spacing
    
    // Determine visible area based on camera position
    const visibleLeft = cameraX;
    const visibleRight = cameraX + canvas.width;
    const visibleTop = cameraY;
    const visibleBottom = cameraY + canvas.height;
    
    // Generate clouds in the visible area (with buffer for smooth scrolling)
    for (let baseY = Math.floor(visibleTop / cloudSpacingY) * cloudSpacingY - cloudSpacingY; 
         baseY <= visibleBottom + cloudSpacingY; 
         baseY += cloudSpacingY) {
        
        // For each row, create fewer clouds
        for (let i = 0; i < 3; i++) {
            // Create a cloud with consistent movement based on position
            const seed = baseY * 0.1 + i * 1000;
            const random = Math.abs(Math.sin(seed)) * 10000 % 1;
            
            // Calculate base position
            let baseX = (i * cloudSpacingX) + (random * cloudSpacingX);
            
            // Apply horizontal movement based on time
            // Different rows move at different speeds and directions
            const speedFactor = (baseY % 3 === 0) ? 1 : ((baseY % 3 === 1) ? -0.7 : 0.5);
            const movement = time * 100 * speedFactor;
            
            // Wrap around the world width
            baseX = (baseX + movement) % (WORLD_WIDTH + cloudSpacingX);
            if (baseX < -cloudSpacingX) baseX += WORLD_WIDTH + cloudSpacingX;
            
            // Determine cloud size (larger minimum size)
            const minSize = 120; // Increased minimum size
            const maxSize = 200;
            const sizeVariation = Math.max(0.5, 1 - (baseY / WORLD_HEIGHT));
            const cloudSize = minSize + (maxSize - minSize) * sizeVariation * random;
            
            const drawX = baseX - cameraX;
            const drawY = baseY - cameraY;
            
            // Only draw if potentially visible
            if (drawX + cloudSize >= -200 && 
                drawX <= canvas.width + 200 && 
                drawY + cloudSize >= -200 && 
                drawY <= canvas.height + 200) {
                
                // Draw cloud with MORE overlapping circles to avoid triangle gaps
                ctx.beginPath();
                
                // Main center circle
                ctx.arc(drawX, drawY, cloudSize * 0.5, 0, Math.PI * 2);
                
                // Additional circles to create fuller shape without gaps
                ctx.arc(drawX + cloudSize * 0.4, drawY - cloudSize * 0.1, cloudSize * 0.45, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.3, drawY, cloudSize * 0.4, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.1, drawY + cloudSize * 0.1, cloudSize * 0.35, 0, Math.PI * 2);
                
                // Add more circles to fill gaps
                ctx.arc(drawX - cloudSize * 0.15, drawY - cloudSize * 0.15, cloudSize * 0.35, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.25, drawY + cloudSize * 0.05, cloudSize * 0.3, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.1, drawY + cloudSize * 0.2, cloudSize * 0.25, 0, Math.PI * 2);
                
                // Fill the entire shape
                ctx.fill();
            }
        }
    }
}
        
      function drawGameObjects(objects, sprite, fallbackColor) {
    objects.forEach(obj => {
        // Use our constants instead of default values
        const size = obj === gameObjects.trees ? 
            (obj.size || TREE_SIZE) : 
            (obj === gameObjects.rocks ? 
                (obj.size || ROCK_SIZE) : 
                (obj.size || 50));
        
        const drawX = obj.x - cameraX;
        const drawY = obj.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + size >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + size >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to color shape
            try {
                ctx.drawImage(sprite, drawX, drawY, size, size);
            } catch (e) {
                // Fallback to colored shape
                ctx.fillStyle = fallbackColor;
                
                if (objects === gameObjects.rocks) {
                    // Draw rock (irregular circle)
                    ctx.beginPath();
                    ctx.ellipse(drawX + size/2, drawY + size/2, size/2, size/2 * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (objects === gameObjects.trees) {
                    // Draw tree (triangle top with rectangle trunk)
                    ctx.fillStyle = '#8B4513'; // Brown trunk
                    ctx.fillRect(drawX + size/3, drawY + size/2, size/3, size/2);
                    
                    ctx.fillStyle = '#006400'; // Dark green foliage
                    ctx.beginPath();
                    ctx.moveTo(drawX, drawY + size/2);
                    ctx.lineTo(drawX + size/2, drawY);
                    ctx.lineTo(drawX + size, drawY + size/2);
                    ctx.fill();
                }
            }
        }
    });
}
        
        function drawCoins() {
            ctx.fillStyle = '#FFD700'; // Gold color
            
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    const drawX = coin.x - cameraX;
                    const drawY = coin.y - cameraY;
                    
                    // Only draw if visible on screen
                    if (
                        drawX + COIN_SIZE >= 0 &&
                        drawX <= canvas.width &&
                        drawY + COIN_SIZE >= 0 &&
                        drawY <= canvas.height
                    ) {
                        // Try to draw sprite
                        try {
                            ctx.drawImage(coinSprite, drawX, drawY, COIN_SIZE, COIN_SIZE);
                        } catch (e) {
                            // Fallback to gold circle
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Add coin detail (inner circle)
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/4, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = '#FFD700';
                        }
                        
                        // Animate coin bob up and down
                        coin.bobOffset = coin.bobOffset || 0;
                        coin.bobDirection = coin.bobDirection || 1;
                        coin.bobOffset += 0.05 * coin.bobDirection;
                        
                        if (coin.bobOffset > 5 || coin.bobOffset < 0) {
                            coin.bobDirection *= -1;
                        }
                    }
                }
            });
        }
        
        function drawPlayers() {
            for (const id in players) {
                const player = players[id];
                const drawX = player.x - cameraX;
                const drawY = player.y - cameraY;
                
                // Only draw if visible on screen
                if (
                    drawX + PLAYER_SIZE >= 0 &&
                    drawX <= canvas.width &&
                    drawY + PLAYER_SIZE >= 0 &&
                    drawY <= canvas.height
                ) {
                    // First draw colored square (for customized color)
                    ctx.fillStyle = player.color || '#FF0000';
                    ctx.fillRect(drawX, drawY, PLAYER_SIZE, PLAYER_SIZE);
                    
                    // Then draw player sprite with transparency
                    try {
                        ctx.globalAlpha = 0.7; // Make sprite semi-transparent
                        ctx.drawImage(playerSprite, drawX, drawY, PLAYER_SIZE, PLAYER_SIZE);
                        ctx.globalAlpha = 1.0; // Reset alpha
                    } catch (e) {
                        // If sprite fails, we already have the colored square
                    }
                    
                    // Draw player name
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.username, drawX + PLAYER_SIZE / 2, drawY - 5);
                    
                    // Draw player score
                    if (player.score !== undefined) {
                        ctx.fillText(`${player.score} pts`, drawX + PLAYER_SIZE / 2, drawY - 25);
                    }
                }
            }
        }
        function isPlayerInWater() {
    if (!myId || !players[myId]) return false;
    
    const player = players[myId];
    const playerCenter = {
        x: player.x + PLAYER_SIZE/2,
        y: player.y + PLAYER_SIZE/2
    };
    
    // Check each pond
    for (const pond of gameObjects.ponds) {
        // Use ellipse equation to check if player is in the pond
        const dx = (playerCenter.x - (pond.x + pond.width/2)) / (pond.width/2);
        const dy = (playerCenter.y - (pond.y + pond.height/2)) / (pond.height/2);
        
        if (dx*dx + dy*dy <= 1) {
            return true;
        }
    }
    
    return false;
}


// Start fishing minigame
function startFishing() {
    if (isFishing) return;
    
    isFishing = true;
    fishingProgress = 0;
    fishingSuccess = false;
    fishingResult = null;
    
    // Show fishing message
    addChatMessage('System', 'Fishing started! Click when the indicator is in the green zone to catch a fish!');
    
    // Simulate rod casting animation
    playSound('splash.mp3', 0.3);
    
    // Start fishing minigame
    fishingTimeout = setTimeout(() => {
        if (isFishing) {
            // If player didn't click in time, fishing fails
            isFishing = false;
            addChatMessage('System', 'You missed your chance! The fish got away.');
        }
    }, 5000); // 5 seconds to click
}

// Handle fishing progress
function drawFishingProgress() {
    if (!isFishing) return;
    
    const player = players[myId];
    const drawX = player.x - cameraX;
    const drawY = player.y - cameraY;
    
    // Draw fishing line from player to water
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(drawX + PLAYER_SIZE/2, drawY + PLAYER_SIZE/2);
    
    // Find closest pond point for fishing line
    let nearestPondPoint = { x: drawX + PLAYER_SIZE/2, y: drawY + PLAYER_SIZE/2 + 100 };
    for (const pond of gameObjects.ponds) {
        const pondCenterX = pond.x - cameraX + pond.width/2;
        const pondCenterY = pond.y - cameraY + pond.height/2;
        
        // Simplified nearest point calculation - this could be improved
        nearestPondPoint = { 
            x: pondCenterX, 
            y: pondCenterY 
        };
    }
    
    // Draw fishing line
    ctx.lineTo(nearestPondPoint.x, nearestPondPoint.y);
    ctx.stroke();
    
    // Draw fishing float
    ctx.fillStyle = '#FF0000';
    ctx.beginPath();
    ctx.arc(nearestPondPoint.x, nearestPondPoint.y, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw fishing progress bar
    const progressBarWidth = 200;
    const progressBarHeight = 30;
    const progressBarX = (canvas.width - progressBarWidth) / 2;
    const progressBarY = canvas.height - 100;
    
    // Update fishing progress based on time
    fishingProgress = (Date.now() % 5000) / 5000; // 0 to 1 value cycling every 5 seconds
    
    // Draw progress bar background
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
    
    // Draw progress indicator
    const indicatorPos = progressBarX + progressBarWidth * fishingProgress;
    ctx.fillStyle = '#000000';
    ctx.fillRect(indicatorPos - 2, progressBarY, 4, progressBarHeight);
    
    // Draw success zone (30% of the bar width, positioned randomly)
    const successZoneWidth = progressBarWidth * 0.3;
    
    // Position success zone based on a repeating pattern with pseudo-randomness
    const timeOffset = Math.floor(Date.now() / 5000); // Changes every 5 seconds
    const successZonePosition = ((Math.sin(timeOffset) + 1) / 2) * (progressBarWidth - successZoneWidth);
    const successZoneStart = progressBarX + successZonePosition;
    
    ctx.fillStyle = '#4CAF50'; // Green color for success zone
    ctx.fillRect(successZoneStart, progressBarY, successZoneWidth, progressBarHeight);
    
    // Check if the indicator is in the success zone
    const inSuccessZone = 
        indicatorPos >= successZoneStart && 
        indicatorPos <= successZoneStart + successZoneWidth;
    
    // Add "CLICK NOW!" text if in success zone
    if (inSuccessZone) {
        ctx.fillStyle = '#FF0000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('CLICK NOW!', canvas.width / 2, progressBarY - 10);
        
        // Setup click handler for catch attempt
        canvas.onclick = function() {
            catchFish(true); // Success!
            canvas.onclick = null; // Remove click handler
        };
    }
}

// Handle caught fish
function catchFish(success) {
    if (!isFishing) return;
    
    // Clear fishing timeout
    clearTimeout(fishingTimeout);
    isFishing = false;
    
    if (success) {
        // Request a fish from the server
        socket.emit('catch_fish');
        addChatMessage('System', 'You got a bite! Waiting to see what you caught...');
        playSound('catch.mp3', 0.4);
    } else {
        addChatMessage('System', 'You missed! Better luck next time.');
        playSound('missed.mp3', 0.3);
    }
}

// Render fish inventory
function toggleFishInventory() {
    isInventoryOpen = !isInventoryOpen;
    
    if (isInventoryOpen) {
        // Request latest fish inventory from server
        socket.emit('get_fish_inventory');
    }
}

// Draw the fish inventory screen
function drawFishInventory() {
    // Semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Inventory panel
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Draw panel background
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    
    // Panel title
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Fish Collection', panelX + panelWidth/2, panelY + 40);
    
    // Close button
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(panelX + panelWidth - 30, panelY + 10, 20, 20);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('', panelX + panelWidth - 20, panelY + 25);
    
    // Check if we have fish to display
    if (fishInventory.length === 0) {
        ctx.fillStyle = '#666666';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No fish caught yet. Go fishing!', panelX + panelWidth/2, panelY + panelHeight/2);
    } else {
        // Display fish in a grid
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const startX = panelX + (panelWidth - (columns * itemSize)) / 2;
        const startY = panelY + 80;
        
        fishInventory.forEach((fish, index) => {
            const col = index % columns;
            const row = Math.floor(index / columns);
            const x = startX + col * itemSize;
            const y = startY + row * itemSize;
            
            // Draw fish slot background
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(x, y, itemSize - 10, itemSize - 10);
            
            // Draw fish sprite if available
            try {
                const fishSprite = fishSprites[`fish${fish.typeId}`];
                ctx.drawImage(fishSprite, x + 10, y + 10, itemSize - 30, itemSize - 50);
            } catch (e) {
                // Fallback to colored rectangle if sprite not available
                ctx.fillStyle = getFishColor(fish.typeId);
                ctx.fillRect(x + 10, y + 10, itemSize - 30, itemSize - 50);
            }
            
            // Draw fish details
            ctx.fillStyle = '#333333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(fish.name, x + (itemSize - 10)/2, y + itemSize - 35);
            ctx.fillText(`${fish.size} cm`, x + (itemSize - 10)/2, y + itemSize - 20);
            
            // Draw rarity indicator
            const rarityColor = getRarityColor(fish.rarity);
            ctx.fillStyle = rarityColor;
            ctx.fillRect(x + (itemSize - 40)/2, y + itemSize - 15, 40, 10);
            
            // NEW: Add delete button for each fish
            ctx.fillStyle = '#FF3B30';
            ctx.fillRect(x + itemSize - 25, y + 5, 15, 15);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('', x + itemSize - 17, y + 15);
            
            // Store button coordinates for click detection
            fish.deleteButton = {
                x: x + itemSize - 25,
                y: y + 5,
                width: 15,
                height: 15
            };
        });
    }
    
    // Stats section
    const statsY = panelY + panelHeight - 60;
    
    ctx.fillStyle = '#333333';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    
    // Calculate stats
    const totalFish = fishInventory.length;
    const uniqueTypes = new Set(fishInventory.map(fish => fish.typeId)).size;
    const largestFish = fishInventory.length > 0 ? 
        Math.max(...fishInventory.map(fish => fish.size)) : 0;
    
    ctx.fillText(`Total Caught: ${totalFish}`, panelX + 30, statsY);
    ctx.fillText(`Unique Types: ${uniqueTypes}/10`, panelX + 30, statsY + 25);
    ctx.fillText(`Largest Fish: ${largestFish} cm`, panelX + panelWidth - 200, statsY);
    
    // Handle clicks in inventory (close button or delete fish buttons)
    canvas.onclick = handleInventoryClick;
}

// 2. Add a function to handle inventory clicks
function handleInventoryClick(e) {
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    
    // Get canvas position for accurate coordinates
    const rect = canvas.getBoundingClientRect();
    const canvasX = mouseX - rect.left;
    const canvasY = mouseY - rect.top;
    
    // Calculate panel dimensions again (should match drawFishInventory)
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Check if close button clicked
    if (
        canvasX >= panelX + panelWidth - 30 && 
        canvasX <= panelX + panelWidth - 10 &&
        canvasY >= panelY + 10 && 
        canvasY <= panelY + 30
    ) {
        isInventoryOpen = false;
        canvas.onclick = null; // Remove click handler
        return;
    }
    
    // Check if any fish delete button was clicked
    for (const fish of fishInventory) {
        if (fish.deleteButton && 
            canvasX >= fish.deleteButton.x &&
            canvasX <= fish.deleteButton.x + fish.deleteButton.width &&
            canvasY >= fish.deleteButton.y &&
            canvasY <= fish.deleteButton.y + fish.deleteButton.height
        ) {
            // Show confirmation dialog
            if (confirm(`Are you sure you want to remove this ${fish.rarity} ${fish.name}?`)) {
                deleteFish(fish.id);
            }
            return;
        }
    }
}

// 3. Add function to send delete request to server
function deleteFish(fishId) {
    // Send delete request to server
    socket.emit('delete_fish', { fishId: fishId });
    
    // Optimistically remove from local inventory (server will validate)
    fishInventory = fishInventory.filter(fish => fish.id !== fishId);
    
    // Redraw inventory
    drawFishInventory();
    
    // Play sound effect
    playSound('trash.mp3', 0.3);
}

// Helper functions for fish display
function getFishColor(typeId) {
    const colors = [
        '#F44336', '#E91E63', '#9C27B0', '#673AB7', 
        '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', 
        '#009688', '#4CAF50'
    ];
    return colors[(typeId - 1) % colors.length];
}

function getRarityColor(rarity) {
    switch(rarity) {
        case 'Common': return '#AAAAAA';
        case 'Uncommon': return '#4CAF50';
        case 'Rare': return '#2196F3';
        case 'Epic': return '#9C27B0';
        case 'Legendary': return '#FFD700';
        default: return '#AAAAAA';
    }
}

// Play sounds with error handling
function playSound(soundFile, volume = 0.5) {
    try {
        const sound = new Audio(`/${soundFile}`);
        sound.volume = volume;
        sound.play().catch(e => console.log(`Sound play failed: ${e}`));
    } catch (e) {
        console.log(`Error playing sound: ${e}`);
    }
}
    </script>
     <div style="position: fixed; bottom: 5px; right: 5px; font-size: 12px; opacity: 0.5;">
        <a href="/admin" target="_blank">Admin</a>
    </div>
    
</body>
</html>