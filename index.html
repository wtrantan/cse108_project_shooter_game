<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat and Chill</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #87CEEB;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: none;
        }
        #loginContainer, #registerContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 300px;
        }
        #registerContainer {
            display: none;
        }
        #gameCanvas {
            background-color: #87CEEB;
        }
        #chatBox {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            max-width: 400px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        #chatMessages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
        }
        #chatInput {
            width: calc(100% - 70px);
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .leaderboard {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 200px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 5px;
    padding: 10px;
    z-index: 100;
}

.leaderboard h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 10px;
    color: #FFD700;
    font-size: 16px;
}

.playerRank {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
    padding: 3px 5px;
    border-radius: 3px;
}

.playerRank.self {
    background-color: rgba(255, 215, 0, 0.3);
    font-weight: bold;
}

.colorPicker {
    position: absolute;
    top: 210px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    z-index: 99;
}
.ammoDisplay {
    position: absolute;
    top: 50px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}
        .scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
        }
        .input-group input {
            width: 100%;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button.secondary {
            background-color: #777;
        }
        button:hover {
            opacity: 0.9;
        }
        .error-message {
            color: #f44336;
            margin: 10px 0;
            font-size: 14px;
        }
        .playerName {
            position: absolute;
            text-align: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
        }
        .baitDisplay {
    position: absolute;
    top: 90px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}
#settingsMenu {
            position: absolute;
            top: 250px; /* Adjusted top position */
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            width: 250px;
            display: none; /* Initially hidden */
        }

        #settingsMenu h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #333;
        }

        #settingsMenu .setting-group {
            margin-bottom: 15px;
        }

        #settingsMenu .setting-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.9em;
        }

        #settingsMenu .setting-group input[type="color"] {
            width: 100%;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        #settingsMenu .setting-group button {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            width: 100%;
            text-align: center;
        }

        #settingsMenu .setting-group button:hover {
            background-color: #45a049;
        }

        #settingsMenu hr {
            margin: 10px 0;
            border: 0;
            border-top: 1px solid #ddd;
        }

        #settingsMenu .setting-group button.secondary {
            background-color: #777;
        }

        #settingsMenu .setting-group button.secondary:hover {
            background-color: #666;
        }

        #settingsMenu .setting-group button.danger {
            background-color: #f44336;
            color: white;
        }

        #settingsMenu .setting-group button.danger:hover {
            background-color: #d32f2f;
        }
        #settingsToggleButton {
            position: absolute;
            top: 10 px;
            right: 230px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 101; /* Ensure it's above other elements */
            color: #000;
            cursor: pointer;
        }
        /* Basic modal styling (you can customize this) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 300px; /* Could be more or less, depending on screen size */
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loginContainer">
        <h2>Welcome to Chat and Chill!</h2>
        <div class="input-group">
            <label for="loginUsername">Username:</label>
            <input type="text" id="loginUsername" placeholder="Username">
        </div>
        <div class="input-group">
            <label for="loginPassword">Password:</label>
            <input type="password" id="loginPassword" placeholder="Password">
        </div>
        <div class="error-message" id="loginError"></div>
        <button id="loginButton">Login</button>
        <p>Don't have an account? <a href="#" id="showRegisterLink">Register</a></p>
    </div>
    
    <div id="registerContainer">
        <h2>Create Account</h2>
        <div class="input-group">
            <label for="registerUsername">Username:</label>
            <input type="text" id="registerUsername" placeholder="Username (min 3 characters)">
        </div>
        <div class="input-group">
            <label for="registerPassword">Password:</label>
            <input type="password" id="registerPassword" placeholder="Password (min 4 characters)">
        </div>
        <div class="input-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" placeholder="Confirm Password">
        </div>
        <div class="error-message" id="registerError"></div>
        <button id="registerButton">Register</button>
        <p>Already have an account? <a href="#" id="showLoginLink">Login</a></p>
    </div>
    
    <div id="gameContainer">

<div id="instructionsCard" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1000; width: 400px; max-width: 90vw; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); font-family: Arial, sans-serif;">
    <h2 style="text-align: center; color: #FFD700; margin-top: 0;">Welcome to Chat and Chill!</h2>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #4CAF50; margin-bottom: 5px;">Movement</h3>
        <p>Use <b>WASD</b> or <b>Arrow Keys</b> to move your character</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #2196F3; margin-bottom: 5px;">Combat</h3>
        <p>Press <b>Spacebar</b> to shoot snowballs</p>
        <p>Collect snowballs to reload</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #FFC107; margin-bottom: 5px;">Fishing</h3>
        <p>Stand in a pond and press <b>F</b> to start fishing</p>
        <p><b>Click</b> when the indicator is in the green zone to catch a fish</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #9C27B0; margin-bottom: 5px;">Inventory</h3>
        <p>Press <b>E</b> to open your fish inventory</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #FF5722; margin-bottom: 5px;">Scoring</h3>
        <p>Collect coins to increase your score</p>
        <p>Shooting other players increases your score</p>
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button id="closeInstructionsButton" style="background-color: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">Got it!</button>
    </div>
</div>

        <canvas id="gameCanvas"></canvas>
        <div class="scoreDisplay" id="scoreDisplay">Score: 0</div>
        <div class="ammoDisplay" id="ammoDisplay">Ammo: 30/50</div>
        <div class="baitDisplay" id="baitDisplay">Bait: 5/10</div>
        <button id="settingsToggleButton">Settings</button>
        <div id="settingsMenu">
            <h2>Settings</h2>
            <div class="setting-group">
                <label>Change your color:</label>
                <input type="color" id="colorPicker" value="#FF0000">
                <button id="applyColorButton">Apply</button>
            </div>
            <hr>
            <button id="change-username-btn">Change Username</button>
            <button id="change-password-btn">Change Password</button>
            <div class="setting-group">
                <button id="logoutButton" class="secondary">Log Out</button>
            </div>
            <div class="setting-group">
                <button id="deleteAccountButton" class="danger">Delete Account</button>
            </div>
        </div>
        <div id="change-password-modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h3>Change Password</h3>
                <input type="password" id="current-password-change" placeholder="Current Password">
                <input type="password" id="new-password-change" placeholder="New Password">
                <button id="save-password-btn">Save Password</button>
            </div>
        </div>
        
        <div id="change-username-modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h3>Change Username</h3>
                <input type="password" id="current-password-username" placeholder="Current Password">
                <input type="text" id="new-username" placeholder="New Username">
                <button id="save-username-btn">Save Username</button>
            </div>
        </div>
        <div class="minimap" id="minimap"></div>
        <div id="chatBox">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <button id="toggleChatButton">Hide Chat</button>
                <span style="font-weight: bold;">Chat</span>
            </div>
            <div id="chatMessages"></div>
            <div>
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button id="sendButton">Send</button>
            </div>
        </div>
        <div class="leaderboard">
            <h3>Leaderboard</h3>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
    <script>
        // Connect to the server
        const socket = io();
        let chatInputFocused = false;
        // Game variables
        let canvas, ctx;
        let username = "";
        let userColor = "#FF0000";
        let players = {};
        const soundEffectCooldowns = {
    'coin-sound.mp3': 0,
    'ammo-sound.mp3': 0,
    'bait.mp3': 0,
    'gun.mp3': 0,
    'catch.mp3': 0,
    'missedFish.mp3': 0,
    'splash.mp3': 0,
    'trashcan.mp3': 0
};


// Get the settings button and menu elements
const settingsToggleButton = document.getElementById('settingsToggleButton');
        const settingsMenu = document.getElementById('settingsMenu');
        const changePasswordBtn = document.getElementById('change-password-btn');
const changeUsernameBtn = document.getElementById('change-username-btn');
const changePasswordModal = document.getElementById('change-password-modal');
const changeUsernameModal = document.getElementById('change-username-modal');
const savePasswordBtn = document.getElementById('save-password-btn');
const saveUsernameBtn = document.getElementById('save-username-btn');
const closePasswordModal = document.querySelectorAll('#change-password-modal .close');
const closeUsernameModal = document.querySelectorAll('#change-username-modal .close');


changePasswordBtn.addEventListener('click', () => {
    changePasswordModal.style.display = 'block';
});

changeUsernameBtn.addEventListener('click', () => {
    changeUsernameModal.style.display = 'block';
});

closePasswordModal.forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        changePasswordModal.style.display = 'none';
    });
});

closeUsernameModal.forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        changeUsernameModal.style.display = 'none';
    });
});

window.addEventListener('click', (event) => {
    if (event.target === changePasswordModal) {
        changePasswordModal.style.display = 'none';
    }
    if (event.target === changeUsernameModal) {
        changeUsernameModal.style.display = 'none';
    }
});

savePasswordBtn.addEventListener('click', async () => {
    const currentPassword = document.getElementById('current-password-change').value;
    const newPassword = document.getElementById('new-password-change').value;

    const response = await fetch('/api/change-password', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ currentPassword, newPassword, username })
    });

    const data = await response.json();

    if (response.ok) {
        alert(data.message);
        changePasswordModal.style.display = 'none';
        window.location.reload();
    } else {
        alert(data.error);
    }
});

saveUsernameBtn.addEventListener('click', async () => {
    const currentPassword = document.getElementById('current-password-username').value;
    const newUsername = document.getElementById('new-username').value;

    const response = await fetch('/api/change-username', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ currentPassword, newUsername, username })
    });

    const data = await response.json();

    if (response.ok) {
        alert(data.message);
        localStorage.setItem('username', newUsername);  // Update local storage
        username = newUsername; // Update the username variable
        changeUsernameModal.style.display = 'none';
        window.location.reload();
    } else {
        alert(data.error);
    }
});
        // Add a click event listener to the settings button
        settingsToggleButton.addEventListener('click', () => {
            // Toggle the display of the settings menu
            if (settingsMenu.style.display === 'none') {
                settingsMenu.style.display = 'block';
            } else {
                settingsMenu.style.display = 'none';
            }
        });
const backgroundMusic = new Audio('/background-music.mp3'); // Replace with your music file path
backgroundMusic.loop = true; // Make music loop continuously
backgroundMusic.volume = 0.3; // Set to 30% volume to start
let isMusicMuted = false;
        const SOUND_COOLDOWN = 300; // Adjust this value as needed
        let fishInventory = []; // Array to store caught fish
        let isInventoryOpen = false;
        let isFishing = false;
        let fishingProgress = 0;
        let fishingSuccess = false;
        let fishingResult = null;
        let fishingTimeout = null;
        let myId = null;
        let playerScore = 0;
        let gameObjects = {
            trees: [],
            rocks: [],
            coins: [],
            ammoPacks: [],
            baitPacks: [],
            ponds: [],
            decorativeLakes: [] 
        };
        let currentBait = 5; // Start with 5 bait
        const MAX_BAIT = 10; // Maximum bait capacity
        const BAIT_PACK_SIZE = 1; // Amount of bait in each pack
        const BAIT_PACK_SIZE_DISPLAY = 60; // Visual size of bait packs
        let currentAmmo = 5; // Start with 30 bullets
        const MAX_AMMO = 10; // Maximum ammo capacity
        const AMMO_PACK_SIZE = 5; // Amount of ammo in each pack
        const AMMO_PACK_SIZE_DISPLAY = 70; // Visual size of ammo packs
        let bullets = [];
        let mouseX = 0;
        let mouseY = 0;
        let keys = {
    up: false,
    down: false,
    left: false,
    right: false
};
let lastLeaderboardUpdate = 0;
const LEADERBOARD_UPDATE_INTERVAL = 250; // Only update every 250ms max
const inputBuffer = [];
const MAX_BUFFER_SIZE = 10;
const positionBuffer = [];
let lastInputTime = 0;
const INPUT_SEND_INTERVAL = 50; // ms
let lastMovementUpdate = 0;
const MOVEMENT_UPDATE_INTERVAL = 33; // Send position updates at most every 33ms (~30 updates/sec)
let lastUpdateTime = 0; 
    const BULLET_SPEED = 10;
    const BULLET_SIZE = 8;
    const BULLET_COOLDOWN = 500; // Cooldown in milliseconds
    let lastShotTime = 0;
        // Game constants
        const PLAYER_SPEED = 7;
        const PLAYER_SIZE = 50;
        const COIN_SIZE = 20;
        let deleteButtonPositions = [];
        // Game assets preloading
        const playerSprite = new Image();
        playerSprite.src = '/player-penguin.png';
        const baitPackSprite = new Image();
baitPackSprite.src = '/worm.png'; // Create this image or use a placeholder    
        const pondSprite = new Image();
        pondSprite.src = '/'; // Create this image or use a placeholder
//         const fishingRodSprite = new Image();
// fishingRodSprite.src = '/fishing-rod.png'; // Create this image or use a placeholder
        const treeSprite = new Image();

        const fishSprites = {};
for (let i = 1; i <= 12; i++) {
    fishSprites[`fish${i}`] = new Image();
    fishSprites[`fish${i}`].src = `/fish${i}.png`; // Create these images or use placeholders
}
        treeSprite.src = '/tree.png'; // Create this image or use a placeholder
        
        const rockSprite = new Image();
        rockSprite.src = '/rock.png'; // Create this image or use a placeholder
        
        const coinSprite = new Image();
        coinSprite.src = '/coin.png'; // Create this image or use a placeholder
        
        const ammoPackSprite = new Image();
        ammoPackSprite.src = '/Snowball2.png'; // Create this image or use a placeholder
        // Camera tracking
        let cameraX = 0;
        let cameraY = 0;
        const WORLD_WIDTH = 4000;  // Increased from 2000
        const WORLD_HEIGHT = 3000; // Increased from 1500
        
        // DOM elements
        const loginContainer = document.getElementById('loginContainer');
        const registerContainer = document.getElementById('registerContainer');
        const gameContainer = document.getElementById('gameContainer');
        const loginError = document.getElementById('loginError');
        const registerError = document.getElementById('registerError');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        // Show/hide auth forms
        document.getElementById('showRegisterLink').addEventListener('click', (e) => {
            e.preventDefault();
            loginContainer.style.display = 'none';
            registerContainer.style.display = 'block';
        });
        
        document.getElementById('showLoginLink').addEventListener('click', (e) => {
            e.preventDefault();
            registerContainer.style.display = 'none';
            loginContainer.style.display = 'block';
        });
        
        // Register handling
        document.getElementById('registerButton').addEventListener('click', register);
        
        async function register() {
            const usernameInput = document.getElementById('registerUsername');
            const passwordInput = document.getElementById('registerPassword');
            const confirmPasswordInput = document.getElementById('confirmPassword');
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            const confirmPassword = confirmPasswordInput.value;
            
            // Reset error message
            registerError.textContent = '';
            
            // Validate inputs
            if (username.length < 3) {
                registerError.textContent = 'Username must be at least 3 characters long';
                return;
            }
            
            if (password.length < 4) {
                registerError.textContent = 'Password must be at least 4 characters long';
                return;
            }
            
            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match';
                return;
            }
            
            try {
                // Send register request to server
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    registerError.textContent = data.error || 'Registration failed';
                    return;
                }
                
                // Set color from server
                userColor = data.color;
                
                // Show login form
                registerContainer.style.display = 'none';
                loginContainer.style.display = 'block';
                loginError.textContent = 'Registration successful! Please login.';
                
                // Pre-fill username
                document.getElementById('loginUsername').value = username;
            } catch (error) {
                console.error('Registration error:', error);
                registerError.textContent = 'Server error. Please try again later.';
            }
        }
        function toggleChat() {
    const chatBox = document.getElementById('chatBox');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const toggleButton = document.getElementById('toggleChatButton');
    
    if (chatMessages.style.display === 'none') {
        // Show chat
        chatMessages.style.display = 'block';
        chatInput.style.display = 'inline-block';
        document.getElementById('sendButton').style.display = 'inline-block';
        toggleButton.textContent = 'Hide Chat';
    } else {
        // Hide chat
        chatMessages.style.display = 'none';
        chatInput.style.display = 'none';
        document.getElementById('sendButton').style.display = 'none';
        toggleButton.textContent = 'Show Chat';
    }
}

        // Login handling
        document.getElementById('loginButton').addEventListener('click', login);
        document.getElementById('loginUsername').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('loginPassword').focus();
            }
        });
        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') login();
        });
        
        async function login() {
            const usernameInput = document.getElementById('loginUsername');
            const passwordInput = document.getElementById('loginPassword');
            
            username = usernameInput.value.trim();
            const password = passwordInput.value;
            
            // Reset error message
            loginError.textContent = '';
            
            // Validate inputs
            if (!username || !password) {
                loginError.textContent = 'Username and password are required';
                return;
            }
            
            try {
                // Send login request to server
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    loginError.textContent = data.error || 'Login failed';
                    return;
                }
                
                // Set user data from database
                userColor = data.color;
                playerScore = data.score || 0;
                document.getElementById('colorPicker').value = userColor;
                
                // Update score display
                scoreDisplay.textContent = `Score: ${playerScore}`;
                
                // Join the game using socket
                socket.emit('join_game', {
                    username: username,
                    color: userColor
                });
                
                // Wait for server confirmation
                socket.once('join_success', (playerId) => {
                    myId = playerId;
                    
                    // Hide login and show game
                    loginContainer.style.display = 'none';
                    gameContainer.style.display = 'block';
                    
                    // Initialize the game
                    initGame();
                });
            } catch (error) {
                console.error('Login error:', error);
                loginError.textContent = 'Server error. Please try again later.';
            }
        }
        
        // Initialize the game after successful login
        function initGame() {
            // Set up the canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to window size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
             // Add unstuck button to the game UI
    const unstuckButton = document.createElement('button');
    unstuckButton.textContent = '🔄 Unstuck';
    unstuckButton.style.position = 'absolute';
    unstuckButton.style.bottom = '170px';
    unstuckButton.style.right = '10px';
    unstuckButton.style.backgroundColor = '#FF9800';
    unstuckButton.style.color = 'white';
    unstuckButton.style.border = 'none';
    unstuckButton.style.borderRadius = '5px';
    unstuckButton.style.padding = '8px 15px';
    unstuckButton.style.cursor = 'pointer';
    unstuckButton.style.zIndex = '1000';
    unstuckButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    
    // Add cooldown tracking
    let lastUnstuckTime = 0;
    const unstuckCooldown = 10000; // 10 seconds cooldown
    
    unstuckButton.addEventListener('click', function() {
        const currentTime = Date.now();
        
        // Check for cooldown
        if (currentTime - lastUnstuckTime < unstuckCooldown) {
            const remainingCooldown = Math.ceil((unstuckCooldown - (currentTime - lastUnstuckTime)) / 1000);
            addChatMessage('System', `Unstuck on cooldown. Please wait ${remainingCooldown} seconds.`);
            return;
        }
        
        // Request unstuck from server
        socket.emit('request_unstuck');
        lastUnstuckTime = currentTime;
        
        // Visual feedback that request was sent
        unstuckButton.disabled = true;
        unstuckButton.textContent = '⏳ Processing...';
        unstuckButton.style.backgroundColor = '#999';
        
        // Reset button after cooldown
        setTimeout(() => {
            unstuckButton.disabled = false;
            unstuckButton.textContent = '🔄 Unstuck';
            unstuckButton.style.backgroundColor = '#FF9800';
        }, unstuckCooldown);
        
        // Notify the player
        addChatMessage('System', "Attempting to unstuck you... Please wait.");
    });
    
    document.getElementById('gameContainer').appendChild(unstuckButton);
            // Set up chat functionality
            document.getElementById('sendButton').addEventListener('click', sendMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
            document.getElementById('chatInput').addEventListener('focus', () => {
    chatInputFocused = true;
    
    // Reset key states when focusing the chat input
    keys.up = false;
    keys.down = false;
    keys.left = false;
    keys.right = false;
});

document.getElementById('chatInput').addEventListener('blur', () => {
    chatInputFocused = false;
});

// Set up toggle chat button
document.getElementById('toggleChatButton').addEventListener('click', toggleChat);
            // Set up color picker
            document.getElementById('applyColorButton').addEventListener('click', changeColor);
            
            // Set up movement controls
            
// Add click handler for fishing
document.addEventListener('keydown', (e) => {
    // Check if the 'F' key was pressed (case-insensitive)
    if (e.key.toLowerCase() === 'f') {
        // Only allow fishing when not already fishing and not typing in chat
        if (!isFishing && !chatInputFocused && isPlayerInWater() && currentBait > 0) {
            startFishing();
        }
    }
});

// Add 'E' key handler for fish inventory
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && !chatInputFocused) {
        toggleFishInventory();
    }
});
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('mousemove', (e) => {
            // Get mouse position relative to canvas
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateLeaderboard();
            });
           
// Add spacebar shooting in handleKeyDown function, or as a separate event listener:
         window.addEventListener('keydown', (e) => {
            
            if (e.code === 'Space' || e.key === ' ') {
            // Check if player has ammo
           shootBullet();
        }
        });
        updateAmmoDisplay();
        updateBaitDisplay();
        setupSocketHandlers();
            // Set up minimap
            setupMinimap();
            
            // Start the game loop
            requestAnimationFrame(gameLoop);
            
            // Listen for server updates
            socket.on('game_state', (gameState) => {
                let prevPosition = null;
    if (myId && players[myId]) {
        prevPosition = {
            x: players[myId].x,
            y: players[myId].y
        };
    }
                players = gameState.players;
                

                if (prevPosition && myId && players[myId]) {
        const serverPos = players[myId];
        const distX = serverPos.x - prevPosition.x;
        const distY = serverPos.y - prevPosition.y;
        const distance = Math.sqrt(distX * distX + distY * distY);
        
        // Only reconcile if server and client positions differ significantly
        if (distance > 10) {
            // Smoothly move to the correct position over a few frames
            const reconciliationSpeed = 0.3; // Adjust as needed
            players[myId].x = prevPosition.x + distX * reconciliationSpeed;
            players[myId].y = prevPosition.y + distY * reconciliationSpeed;
        }
    }
                // Update game objects if available
                if (gameState.gameObjects) {
                    gameObjects = gameState.gameObjects;
                }
                
                // Update score display if this player's score changed
                if (myId && players[myId]) {
                    if (playerScore !== players[myId].score) {
                        playerScore = players[myId].score;
                        scoreDisplay.textContent = `Score: ${playerScore}`;
                        if (currentAmmo !== players[myId].ammo) {
                     currentAmmo = players[myId].ammo;
                updateAmmoDisplay();
                 }
                    }
                }
                socket.on('bullets_update', (serverBullets) => {
                // Add any new bullets from server that aren't in our local array
                for (const serverBullet of serverBullets) {
             if (!bullets.some(b => b.id === serverBullet.id)) {
                   bullets.push(serverBullet);
            }
        }
   
});
socket.on('fish_deleted', (data) => {
    if (data.success) {
        // Server confirmed deletion, show notification
        //addChatMessage('System', `${data.fishName} has been removed from your inventory.`);
        
        // Request updated inventory to ensure client and server are in sync
        socket.emit('get_fish_inventory');
    } else {
        // Handle errors
        addChatMessage('System', 'Failed to remove fish: ' + (data.error || 'Unknown error'));
    }
});
    socket.on('ammo_update', (data) => {
    currentAmmo = data.ammo;
    updateAmmoDisplay();
    });
    socket.on('bait_update', (data) => {
    currentBait = data.bait;
    updateBaitDisplay();
});
   // Modify the socket.on('player_hit') handler to update scores immediately
socket.on('player_hit', (data) => {
    const { playerId, shooterId, damage } = data;
    
    // If this is the player being hit
    if (playerId === myId) {
        // Flash the screen red for feedback
        flashScreen('rgba(255,0,0,0.3)');
        
        // Immediately update score on hit (prevent negative scores)
        playerScore = Math.max(0, playerScore - damage);
        scoreDisplay.textContent = `Score: ${playerScore}`;
        
        // Update the player's score in our local model
        if (players[myId]) {
            players[myId].score = playerScore;
        }
    }
    
    // If this is the player who shot
    if (shooterId === myId) {
        // Play hit confirmation sound
        playHitConfirmSound();
        
        // Immediately update score for shooter
        playerScore = playerScore + damage;
        scoreDisplay.textContent = `Score: ${playerScore}`;
        
        // Update the player's score in our local model
        if (players[myId]) {
            players[myId].score = playerScore;
        }
    }
    
    // Also update scores in the players object for both shooter and hit player
    // This ensures consistency with local score and leaderboard
    if (players[playerId]) {
        players[playerId].score = Math.max(0, players[playerId].score - damage);
    }
    
    if (players[shooterId]) {
        players[shooterId].score += damage;
    }
    
    // Update the leaderboard with these new scores
    updateLeaderboard();
});

// Add this to handle the players_update event more efficiently
socket.on('players_update', (updatedPlayers) => {
    // Update only the specific players that changed
    for (const id in updatedPlayers) {
        if (players[id]) {
            players[id] = {...players[id], ...updatedPlayers[id]};
        }
    }
    
    // Update score display if current player was updated by server
    // (this ensures client stays in sync with authoritative server)
    if (myId && updatedPlayers[myId] && updatedPlayers[myId].score !== undefined) {
        // Only update if server value differs from local value
        if (playerScore !== updatedPlayers[myId].score) {
            playerScore = updatedPlayers[myId].score;
            scoreDisplay.textContent = `Score: ${playerScore}`;
        }
    }
    
    // Update leaderboard
    updateLeaderboard();
});
                // Update minimap
                updateMinimap();
            });
            
            socket.on('chat_message', (data) => {
                addChatMessage(data.username, data.message);
            });
        }
        socket.on('fish_caught', (fishData) => {
    // Add the fish to inventory
    fishInventory.push(fishData);
    
    // Show notification
   // addChatMessage('System', `You caught a ${fishData.rarity} ${fishData.name} (${fishData.size} cm)!`);
    
    // Sort inventory by rarity and size
    fishInventory.sort((a, b) => {
        const rarityOrder = { 'Common': 0, 'Uncommon': 1, 'Rare': 2, 'Epic': 3, 'Legendary': 4, 'Mythical': 5 };
        return rarityOrder[b.rarity] - rarityOrder[a.rarity] || b.size - a.size;
    });
});

socket.on('fish_inventory', (inventory) => {
    fishInventory = inventory;
});
        // Set up logout and delete account buttons
document.getElementById('logoutButton').addEventListener('click', handleLogout);
document.getElementById('deleteAccountButton').addEventListener('click', confirmDeleteAccount);

// Logout function
function handleLogout() {
    // Disconnect from the socket
    socket.disconnect();
    
    // Hide game container and show login form
    gameContainer.style.display = 'none';
    loginContainer.style.display = 'block';
    
    // Clear password field
    document.getElementById('loginPassword').value = '';
    
    // Optional: Show a message to the user
    loginError.textContent = 'You have been logged out successfully.';
    loginError.style.color = 'green';
}

// Delete account confirmation
function confirmDeleteAccount() {
    if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
        // Call the delete account API
        deleteAccount();
    }
}

// Delete account function
async function deleteAccount() {
    try {
        // Send delete request to server
        const response = await fetch('/api/delete-account', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: username })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            alert(`Failed to delete account: ${data.error}`);
            return;
        }
        
        // Disconnect socket
        socket.disconnect();
        
        // Show login screen
        gameContainer.style.display = 'none';
        loginContainer.style.display = 'block';
        
        // Show success message
        loginError.textContent = 'Your account has been deleted successfully.';
        loginError.style.color = 'green';
        
        // Clear fields
        document.getElementById('loginUsername').value = '';
        document.getElementById('loginPassword').value = '';
        
    } catch (error) {
        console.error('Delete account error:', error);
        alert('Server error. Please try again later.');
    }
}

        function setupMinimap() {
            const minimap = document.getElementById('minimap');
            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
            minimap.appendChild(minimapCanvas);
        }
        
        function updateMinimap() {
            const minimap = document.querySelector('#minimap canvas');
            const minimapCtx = minimap.getContext('2d');
            const minimapWidth = minimap.width;
            const minimapHeight = minimap.height;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw world boundary
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.strokeRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw trees as green dots
            minimapCtx.fillStyle = '#0a5';
            gameObjects.trees.forEach(tree => {
                minimapCtx.fillRect(
                    (tree.x / WORLD_WIDTH) * minimapWidth,
                    (tree.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
            });
//frozen lakes
    minimapCtx.fillStyle = '#B8E3FF';
    gameObjects.decorativeLakes.forEach(lake => {
        const centerX = (lake.x / WORLD_WIDTH) * minimapWidth + ((lake.width / WORLD_WIDTH) * minimapWidth) / 2;
        const centerY = (lake.y / WORLD_HEIGHT) * minimapHeight + ((lake.height / WORLD_HEIGHT) * minimapHeight) / 2;
        const radiusX = ((lake.width / WORLD_WIDTH) * minimapWidth) / 2;
        const radiusY = ((lake.height / WORLD_HEIGHT) * minimapHeight) / 2;
        
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.fill();
    });
    
    // Draw fishable ponds as darker blue (so they're distinguishable)
     minimapCtx.fillStyle = '#4FC3F7';
    gameObjects.ponds.forEach(pond => {
        const centerX = (pond.x / WORLD_WIDTH) * minimapWidth + ((pond.width / WORLD_WIDTH) * minimapWidth) / 2;
        const centerY = (pond.y / WORLD_HEIGHT) * minimapHeight + ((pond.height / WORLD_HEIGHT) * minimapHeight) / 2;
        const radiusX = ((pond.width / WORLD_WIDTH) * minimapWidth) / 2;
        const radiusY = ((pond.height / WORLD_HEIGHT) * minimapHeight) / 2;
        
        // Draw pond
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.fill();
        
        // Add border for visibility
        minimapCtx.strokeStyle = '#0277BD';
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.stroke();
    });
            // Draw rocks as gray dots
            minimapCtx.fillStyle = '#777';
            gameObjects.rocks.forEach(rock => {
                minimapCtx.fillRect(
                    (rock.x / WORLD_WIDTH) * minimapWidth,
                    (rock.y / WORLD_HEIGHT) * minimapHeight,
                    2, 2
                );
            });
            
            // Draw coins as yellow dots
            minimapCtx.fillStyle = '#ff0';
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    minimapCtx.fillRect(
                        (coin.x / WORLD_WIDTH) * minimapWidth,
                        (coin.y / WORLD_HEIGHT) * minimapHeight,
                        3, 3
                    );
                }
            });
            //draw ammo packs as blue dots
            minimapCtx.fillStyle = '#00f';
            gameObjects.ammoPacks.forEach(ammoPack => {
             if (!ammoPack.collected) {
                minimapCtx.fillRect(
                    (ammoPack.x / WORLD_WIDTH) * minimapWidth,
                    (ammoPack.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
             }
        });
          // Draw bait packs as brown dots
    minimapCtx.fillStyle = '#8B4513';
    gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected) {
            minimapCtx.fillRect(
                (baitPack.x / WORLD_WIDTH) * minimapWidth,
                (baitPack.y / WORLD_HEIGHT) * minimapHeight,
                3, 3
            );
        }
    });
            // Draw players
             Object.values(players).forEach(player => {
        // Find if this player has an active interpolation
        const movingPlayer = positionBuffer.find(move => move.id === player.id);
        let displayX = player.x;
        let displayY = player.y;
        
        // If player is currently being interpolated, use the interpolated position
        if (movingPlayer) {
            // Calculate interpolated position using the same logic as in gameLoop
            const progress = movingPlayer.progress;
            const t = 1 - Math.pow(1 - progress, 2); // Same easing function
            displayX = movingPlayer.fromX + (movingPlayer.toX - movingPlayer.fromX) * t;
            displayY = movingPlayer.fromY + (movingPlayer.toY - movingPlayer.fromY) * t;
        }
        
        minimapCtx.fillStyle = player.color || '#f00';
        minimapCtx.fillRect(
            (displayX / WORLD_WIDTH) * minimapWidth,
            (displayY / WORLD_HEIGHT) * minimapHeight,
            4, 4
        );
    });
            
            // Highlight current player
            if (myId && players[myId]) {
                const player = players[myId];
                minimapCtx.strokeStyle = '#fff';
                minimapCtx.strokeRect(
                    (player.x / WORLD_WIDTH) * minimapWidth - 2,
                    (player.y / WORLD_HEIGHT) * minimapHeight - 2,
                    8, 8
                );
                
                // Draw view rectangle
                minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                minimapCtx.strokeRect(
                    (cameraX / WORLD_WIDTH) * minimapWidth,
                    (cameraY / WORLD_HEIGHT) * minimapHeight,
                    (canvas.width / WORLD_WIDTH) * minimapWidth,
                    (canvas.height / WORLD_HEIGHT) * minimapHeight
                );
            }
        }
        
        function changeColor() {
            const colorPicker = document.getElementById('colorPicker');
            const newColor = colorPicker.value;
            
            // Update local color
            userColor = newColor;
            
            // Send to server
            socket.emit('change_color', { color: newColor });
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function handleKeyDown(e) {
            if (chatInputFocused && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
        return;
    }
            const input = updateKeyState(e, true);
    if (input) addToInputBuffer(input);
}

function handleKeyUp(e) {
    if (chatInputFocused && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
        return;
    }
    const input = updateKeyState(e, false);
    if (input) addToInputBuffer(input);
}

function updateKeyState(e, isPressed) {
    let input = null;
    switch(e.key) {
        case 'ArrowUp':
        case 'w':
            keys.up = isPressed;
            input = { type: 'move', key: 'up', pressed: isPressed };
            break;
        case 'ArrowDown':
        case 's':
            keys.down = isPressed;
            input = { type: 'move', key: 'down', pressed: isPressed };
            break;
        case 'ArrowLeft':
        case 'a':
            keys.left = isPressed;
            input = { type: 'move', key: 'left', pressed: isPressed };
            break;
        case 'ArrowRight':
        case 'd':
            keys.right = isPressed;
            input = { type: 'move', key: 'right', pressed: isPressed };
            break;
        case ' ': // Space
            if (isPressed) {
                shootBullet();
                input = { type: 'shoot' };
            }
            break;
    }
    
    return input;
}
function addToInputBuffer(input) {
    input.timestamp = Date.now();
    input.sequence = inputBuffer.length > 0 ? 
                    inputBuffer[inputBuffer.length - 1].sequence + 1 : 0;
    
    inputBuffer.push(input);
    
    // Keep buffer size limited
    if (inputBuffer.length > MAX_BUFFER_SIZE) {
        inputBuffer.shift();
    }
    
    // Process and send inputs
    processInputBuffer();
}
function processInputBuffer() {
    const now = Date.now();
    
    // Only send updates at a fixed interval
    if (now - lastInputTime >= INPUT_SEND_INTERVAL && inputBuffer.length > 0) {
        lastInputTime = now;
        
        // Send all buffered inputs at once
        socket.emit('player_inputs', inputBuffer);
        
        // Clear buffer after sending
        // inputBuffer.length = 0; // Uncomment if you want to clear after sending
    }
}
function updateLeaderboard() {
    const now = Date.now();
    
    // Throttle updates to avoid flickering
    if (now - lastLeaderboardUpdate < LEADERBOARD_UPDATE_INTERVAL) {
        return;
    }
    
    lastLeaderboardUpdate = now;
    
    const leaderboardContent = document.getElementById('leaderboardContent');
    if (!leaderboardContent) return;
    
    // Clear existing content
    leaderboardContent.innerHTML = '';
    
    // Get all players and ensure scores are valid numbers
    const playerList = Object.values(players).map(player => {
        // Ensure score is a valid number
        if (typeof player.score !== 'number' || isNaN(player.score)) {
            player = {...player, score: 0};
        }
        return player;
    }).sort((a, b) => b.score - a.score);
    
    // Add each player to the leaderboard
    playerList.forEach((player, index) => {
        const playerRow = document.createElement('div');
        playerRow.className = 'playerRank';
        
        // Highlight current player
        if (player.id === myId) {
            playerRow.classList.add('self');
        }
        
        // Add color indicator
        const colorIndicator = document.createElement('span');
        colorIndicator.style.display = 'inline-block';
        colorIndicator.style.width = '10px';
        colorIndicator.style.height = '10px';
        colorIndicator.style.backgroundColor = player.color;
        colorIndicator.style.marginRight = '5px';
        colorIndicator.style.borderRadius = '50%';
        
        // Create rank and name element
        const rankAndName = document.createElement('span');
        rankAndName.textContent = `${index + 1}. ${player.username}`;
        
        // Create score element
        const score = document.createElement('span');
        score.textContent = player.score || 0;  // Ensure we display 0 if undefined
        
        // Add elements to row
        playerRow.appendChild(colorIndicator);
        playerRow.appendChild(rankAndName);
        playerRow.appendChild(score);
        
        // Add row to leaderboard
        leaderboardContent.appendChild(playerRow);
    });
}
function shootBullet() {
    if (!myId || !players[myId] || chatInputFocused) return;
    
    if (currentAmmo <= 0) {
        // Play empty gun sound or show message
        showAmmoWarning();
        return;
    }
    // Check cooldown
    const currentTime = Date.now();
    if (currentTime - lastShotTime < BULLET_COOLDOWN) return;
    lastShotTime = currentTime;
    //Decrease ammo
    currentAmmo--;
    updateAmmoDisplay();
    const player = players[myId];
    
    // Calculate bullet starting position (center of player)
    const startX = player.x + PLAYER_SIZE / 2;
    const startY = player.y + PLAYER_SIZE / 2;
    
    // Calculate direction vector from player to mouse, considering camera position
    const targetX = mouseX + cameraX;
    const targetY = mouseY + cameraY;
    
    // Calculate direction vector
    let dirX = targetX - startX;
    let dirY = targetY - startY;
    
    // Normalize the direction vector
    const length = Math.sqrt(dirX * dirX + dirY * dirY);
    if (length > 0) {
        dirX /= length;
        dirY /= length;
    }
    
    // Create bullet object
    const bullet = {
        id: `bullet-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        x: startX,
        y: startY,
        dirX: dirX,
        dirY: dirY,
        playerId: myId,
        color: player.color
    };
    
    // Add to local bullets array
    bullets.push(bullet);
    
    // Send to server
    socket.emit('shoot_bullet', bullet);
     // Update server about ammo count
     socket.emit('update_ammo', { ammo: currentAmmo });
    // Play sound effect
    playShootSound();
}

// 4. Add sound effect function
function playShootSound() {
    playSound('snowball-shoot.mp3', 0.2);
}
function updateAmmoDisplay() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        ammoDisplay.textContent = `Snowball: ${currentAmmo}/${MAX_AMMO}`;
        
        // Change color based on ammo level
        if (currentAmmo <= 2) {
            ammoDisplay.style.color = '#FF0000'; // Red for low ammo
        } else if (currentAmmo <= 4) {
            ammoDisplay.style.color = '#FFA500'; // Orange for medium ammo
        } else {
            ammoDisplay.style.color = '#000000'; // Black for normal
        }
    }
}
function showAmmoWarning() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        // Flash the ammo display
        ammoDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        setTimeout(() => {
            ammoDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        }, 300);
        
        // Show message in chat
       // addChatMessage('System', 'Out of ammo! Find ammo packs to reload.');
    }
}
// 5. Add bullet update and rendering functions
function updateBullets(deltaTime) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        // Move bullet
        bullet.x += bullet.dirX * BULLET_SPEED;
        bullet.y += bullet.dirY * BULLET_SPEED;
        
        // Check if bullet is out of bounds
        if (
            bullet.x < 0 ||
            bullet.x > WORLD_WIDTH ||
            bullet.y < 0 ||
            bullet.y > WORLD_HEIGHT
        ) {
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with obstacles
        if (checkBulletObstacleCollision(bullet)) {
            // Add visual effect for collision
            createBulletImpactEffect(bullet.x, bullet.y);
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with other players (only for visual feedback)
        for (const playerId in players) {
    // Don't collide with the shooter
    if (playerId === bullet.playerId) continue;
    
    const player = players[playerId];
    
    // Use a more reliable collision detection algorithm
    // Calculate distances between centers
    const bulletCenterX = bullet.x;
    const bulletCenterY = bullet.y;
    const playerCenterX = player.x + PLAYER_SIZE/2;
    const playerCenterY = player.y + PLAYER_SIZE/2;
    
    // Check if the bullet is inside the player's bounding box
    if (
        bulletCenterX >= player.x &&
        bulletCenterX <= player.x + PLAYER_SIZE &&
        bulletCenterY >= player.y &&
        bulletCenterY <= player.y + PLAYER_SIZE
    ) {
        // Visual effect only
        createHitEffect(bullet.x, bullet.y);
        
        // Notify server about the hit - this is the key change
        socket.emit('bullet_hit_player', {
            bulletId: bullet.id,
            playerId: playerId
        });
        
        // Remove bullet locally
        bullets.splice(i, 1);
        break;
    }
}
    }
}
function showBaitWarning() {
    const baitDisplay = document.getElementById('baitDisplay');
    if (baitDisplay) {
        // Flash the bait display
        baitDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        setTimeout(() => {
            baitDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        }, 300);
        
        // Show message in chat
        addChatMessage('System', 'Out of bait! Find bait packs to resupply.');
    }
}

function createBulletImpactEffect(x, y) {
    // Create impact particle effect
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        const size = Math.random() * 3 + 2;
        const lifetime = Math.random() * 15 + 5;
        
        const particle = {
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            lifetime: lifetime,
            maxLifetime: lifetime,
            color: '#888888'
        };
        
        // If you have a particles array, add it there
        // particles.push(particle);
        
        // For simplicity, we'll just draw them directly
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Play impact sound
    // const impactSound = new Audio('/impact-sound.mp3'); // Create this sound or use a placeholder
    // impactSound.volume = 0.2;
    // impactSound.play().catch(e => console.log('Audio play failed:', e));
}
// Find the gameLoop function in your code and modify the part where you draw the ground
// Replace the current ground drawing code with this:

function drawBaitPacks() {
    gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected) {
            const drawX = baitPack.x - cameraX;
            const drawY = baitPack.y - cameraY;
            
            // Only draw if visible on screen
            if (
                drawX + BAIT_PACK_SIZE_DISPLAY >= 0 &&
                drawX <= canvas.width &&
                drawY + BAIT_PACK_SIZE_DISPLAY >= 0 &&
                drawY <= canvas.height
            ) {
                // Calculate bob effect for animation
                baitPack.bobOffset = baitPack.bobOffset || 0;
                baitPack.bobDirection = baitPack.bobDirection || 1;
                baitPack.bobOffset += 0.05 * baitPack.bobDirection;
                
                if (baitPack.bobOffset > 5 || baitPack.bobOffset < 0) {
                    baitPack.bobDirection *= -1;
                }
                
                // Draw with vertical bobbing animation
                const bobY = drawY + baitPack.bobOffset;
                
                // Try to draw sprite
                try {
                    ctx.drawImage(baitPackSprite, drawX, bobY, BAIT_PACK_SIZE_DISPLAY, BAIT_PACK_SIZE_DISPLAY);
                } catch (e) {
                    // Fallback to drawn worm if sprite fails to load
                    // Draw a worm-like bait pack
                    ctx.fillStyle = '#8B4513'; // Brown for worm body
                    ctx.fillRect(drawX + 5, bobY + 10, BAIT_PACK_SIZE_DISPLAY - 10, BAIT_PACK_SIZE_DISPLAY - 20);
                    
                    // Draw worm details
                    ctx.fillStyle = '#A0522D'; // Darker brown for segments
                    ctx.fillRect(drawX + 8, bobY + 15, BAIT_PACK_SIZE_DISPLAY - 16, 3);
                    ctx.fillRect(drawX + 8, bobY + 22, BAIT_PACK_SIZE_DISPLAY - 16, 3);
                    
                    // Draw worm head
                    ctx.fillStyle = '#CD853F'; // Lighter brown for head
                    ctx.beginPath();
                    ctx.arc(drawX + 5, bobY + BAIT_PACK_SIZE_DISPLAY/2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw a "B" on the bait pack (for "Bait")
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('B', drawX + BAIT_PACK_SIZE_DISPLAY/2 + 5, bobY + BAIT_PACK_SIZE_DISPLAY/2 + 5);
                }
            }
        }
    });
}
// 9. Add bait pack collection function
function checkBaitPackCollection(player) {
    // Define player hitbox
    const playerHitbox = {
        x: player.x + 10,
        y: player.y + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Check collision with each bait pack
    gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected) {
            // Define bait pack hitbox
            const baitPackHitbox = {
                x: baitPack.x + 5,
                y: baitPack.y + 5,
                width: BAIT_PACK_SIZE_DISPLAY - 10,
                height: BAIT_PACK_SIZE_DISPLAY - 10
            };
            
            // Check hitbox overlap
            if (
                playerHitbox.x < baitPackHitbox.x + baitPackHitbox.width &&
                playerHitbox.x + playerHitbox.width > baitPackHitbox.x &&
                playerHitbox.y < baitPackHitbox.y + baitPackHitbox.height &&
                playerHitbox.y + playerHitbox.height > baitPackHitbox.y
            ) {
                // Collect the bait pack (server will validate)
                socket.emit('collect_bait', baitPack.id);
                
                // Play bait collection sound
                playBaitSound();
            }
        }
    });
}

// 10. Add bait collection sound
function playBaitSound() {
    playSound('bait.mp3', 0.3);
}
function drawPixelatedSnow() {
    // Use larger pixels for better performance
    const pixelSize = 16; // Larger pixels for better performance
    
    // Calculate visible area based on camera position
    // Only draw pixels that are actually visible on screen
    const startX = Math.floor(cameraX / pixelSize) * pixelSize;
    const startY = Math.floor(cameraY / pixelSize) * pixelSize;
    const endX = startX + canvas.width + pixelSize;
    const endY = startY + canvas.height + pixelSize;
    
    // Snow color palette
    const snowColors = [
        '#FFFFFF', // Pure white (main color)
        '#F0F8FF', // Alice blue (very light blue-white)
        '#F5F5F5', // White smoke (off-white)
        '#E6EEFF'  // Light blue tinted white
    ];
    
    // Pre-calculated pattern lookup for better performance
    // This creates a 16x16 pattern that repeats
    if (!window.snowPattern) {
        // Create a reusable pattern (only computed once)
        window.snowPattern = [];
        for (let px = 0; px < 16; px++) {
            window.snowPattern[px] = [];
            for (let py = 0; py < 16; py++) {
                // Generate values for each position in the repeating pattern
                const patternSeed = Math.sin(px * 0.7) * 10000 + Math.cos(py * 0.7) * 10000;
                const val = Math.abs(patternSeed) % 100;
                
                // Determine color index based on the value
                let colorIndex;
                if (val < 60) colorIndex = 0; // Main color (60%)
                else if (val < 85) colorIndex = 1; // Second color (25%)
                else if (val < 95) colorIndex = 2; // Third color (10%)
                else colorIndex = 3; // Fourth color (5%)
                
                window.snowPattern[px][py] = colorIndex;
            }
        }
    }
    
    // Draw the pixelated snow efficiently
    for (let x = startX; x < endX; x += pixelSize) {
        for (let y = startY; y < endY; y += pixelSize) {
            // Use a repeating pattern based on world position
            const patternX = Math.abs(Math.floor(x / pixelSize) % 16);
            const patternY = Math.abs(Math.floor(y / pixelSize) % 16);
            
            // Look up the color index from our pre-computed pattern
            const colorIndex = window.snowPattern[patternX][patternY];
            
            // Draw the snow pixel
            ctx.fillStyle = snowColors[colorIndex];
            ctx.fillRect(
                x - cameraX, 
                y - cameraY, 
                pixelSize, 
                pixelSize
            );
            
            // Add sparkle effects to make snow glisten (only to about 1% of pixels)
            if ((patternX + patternY) % 16 === 0) {
                // Simple highlight detail that's very cheap to draw
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(
                    x - cameraX + pixelSize/4, 
                    y - cameraY + pixelSize/4, 
                    pixelSize/2, 
                    pixelSize/2
                );
            }
        }
    }
    
    // Add occasional snow drifts/bumps for texture
    drawSnowDrifts(startX, startY, endX, endY, pixelSize);
}

// Function to add occasional snow drifts for more texture
function drawSnowDrifts(startX, startY, endX, endY, pixelSize) {
    // Create some random snow drifts
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    
    // Use a deterministic approach for drift placement based on world position
    for (let x = startX; x < endX; x += pixelSize * 10) {
        for (let y = startY; y < endY; y += pixelSize * 10) {
            // Use position to seed a consistent drift pattern
            const seed = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 10000;
            
            // Only draw drift in some locations
            if (Math.abs(seed) % 100 < 30) {
                // Determine drift size
                const driftWidth = (Math.abs(seed) % 5 + 3) * pixelSize;
                const driftHeight = (Math.abs(seed) % 3 + 1) * pixelSize;
                
                // Draw an oval snow drift
                ctx.beginPath();
                ctx.ellipse(
                    x - cameraX + pixelSize * 5, 
                    y - cameraY + pixelSize * 5, 
                    driftWidth / 2, 
                    driftHeight / 2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }
    }
}
// Add this new function to create the pixelated grass effect
function drawPixelatedGrass() {
    // Use larger pixels for better performance
    const pixelSize = 16; // Larger pixels for better performance
    
    // Calculate visible area based on camera position
    // Only draw pixels that are actually visible on screen
    const startX = Math.floor(cameraX / pixelSize) * pixelSize;
    const startY = Math.floor(cameraY / pixelSize) * pixelSize;
    const endX = startX + canvas.width + pixelSize;
    const endY = startY + canvas.height + pixelSize;
    
    // Simpler color palette for better performance
    const grassColors = [
        '#7CFC00', // Base bright green (main color)
        '#6BC400', // Slightly darker green
        '#5FB300', // Medium green
        '#73DB0A'  // Yellowish green
    ];
    
    // Pre-calculated pattern lookup for better performance
    // This creates a 16x16 pattern that repeats
    if (!window.grassPattern) {
        // Create a reusable pattern (only computed once)
        window.grassPattern = [];
        for (let px = 0; px < 16; px++) {
            window.grassPattern[px] = [];
            for (let py = 0; py < 16; py++) {
                // Generate values for each position in the repeating pattern
                const patternSeed = Math.sin(px * 0.7) * 10000 + Math.cos(py * 0.7) * 10000;
                const val = Math.abs(patternSeed) % 100;
                
                // Determine color index based on the value
                let colorIndex;
                if (val < 60) colorIndex = 0; // Main color (60%)
                else if (val < 85) colorIndex = 1; // Second color (25%)
                else if (val < 95) colorIndex = 2; // Third color (10%)
                else colorIndex = 3; // Fourth color (5%)
                
                window.grassPattern[px][py] = colorIndex;
            }
        }
    }
    
    // Draw the pixelated grass efficiently
    for (let x = startX; x < endX; x += pixelSize) {
        for (let y = startY; y < endY; y += pixelSize) {
            // Use a repeating pattern based on world position
            const patternX = Math.abs(Math.floor(x / pixelSize) % 16);
            const patternY = Math.abs(Math.floor(y / pixelSize) % 16);
            
            // Look up the color index from our pre-computed pattern
            const colorIndex = window.grassPattern[patternX][patternY];
            
            // Draw the grass pixel
            ctx.fillStyle = grassColors[colorIndex];
            ctx.fillRect(
                x - cameraX, 
                y - cameraY, 
                pixelSize, 
                pixelSize
            );
            
            // Add minimal detail elements (only to about 1% of pixels)
            // This uses a very efficient calculation
            if ((patternX + patternY) % 16 === 0) {
                // Simple highlight detail that's very cheap to draw
                ctx.fillStyle = '#AEFF00';
                ctx.fillRect(
                    x - cameraX + pixelSize/4, 
                    y - cameraY + pixelSize/4, 
                    pixelSize/2, 
                    pixelSize/2
                );
            }
        }
    }
}

function checkBulletObstacleCollision(bullet) {
    // Check rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        if (
            bullet.x >= rock.x &&
            bullet.x <= rock.x + rockSize &&
            bullet.y >= rock.y &&
            bullet.y <= rock.y + rockSize
        ) {
            return true;
        }
    }
    
    // Check trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Only collide with the trunk part
        if (
            bullet.x >= tree.x + treeSize * 0.3 &&
            bullet.x <= tree.x + treeSize * 0.7 &&
            bullet.y >= tree.y + treeSize * 0.5 &&
            bullet.y <= tree.y + treeSize
        ) {
            return true;
        }
    }
    
    return false;
}

// 6. Add hit effect function for visual feedback
function createHitEffect(x, y) {
    // This could be expanded with particles, animation, etc.
    // const hitSound = new Audio('/hit-sound.mp3'); // Create this sound or use a placeholder
    // hitSound.volume = 0.3;
    // hitSound.play().catch(e => console.log('Audio play failed:', e));
}

// Function to update the water animation to look like ice
function drawDecorativeLakes() {
    gameObjects.decorativeLakes.forEach(lake => {
        const drawX = lake.x - cameraX;
        const drawY = lake.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + lake.width >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + lake.height >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Use the same ice drawing style as your existing ponds
            // but make them slightly lighter to differentiate
            ctx.fillStyle = '#B8E3FF'; // Slightly lighter blue than fishable ponds
            ctx.beginPath();
            ctx.ellipse(
                drawX + lake.width/2, 
                drawY + lake.height/2, 
                lake.width/2, 
                lake.height/2, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Add inner detail
            ctx.fillStyle = '#E0F4FF'; // Even lighter blue
            ctx.beginPath();
            ctx.ellipse(
                drawX + lake.width/2, 
                drawY + lake.height/2, 
                lake.width/3, 
                lake.height/3, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Draw ice cracks and ripples
            drawDecorativeIceRipples(drawX, drawY, lake);
            
            // Animate ice effects
            drawDecorativeIceAnimation(drawX, drawY, lake);
        }
    });
}

// 3. Adapted ice ripples function for decorative lakes
function drawDecorativeIceRipples(drawX, drawY, lake) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // Slightly more transparent than ponds
    ctx.lineWidth = 1;
    
    // Draw 4 elliptical cracks (more than ponds for larger size)
    for (let i = 0; i < 4; i++) {
        const seed = i * 1000 + lake.x + lake.y + 500; // Different seed pattern
        const cracksScale = 0.7 + (i * 0.08);
        
        ctx.beginPath();
        ctx.ellipse(
            drawX + lake.width/2, 
            drawY + lake.height/2, 
            lake.width/2 * cracksScale, 
            lake.height/2 * cracksScale, 
            0, 0, Math.PI * 2
        );
        ctx.stroke();
        
        // Add radiating cracks
        const numCracks = 4 + i; // More cracks for larger lakes
        for (let j = 0; j < numCracks; j++) {
            const angle = (seed + j * 1000) % 628 / 100;
            const startX = drawX + lake.width/2;
            const startY = drawY + lake.height/2;
            const length = (lake.width/2) * (0.4 + (j % 3) * 0.2);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Create jagged line
            let currentX = startX;
            let currentY = startY;
            const segments = 4 + (j % 3);
            
            for (let k = 0; k < segments; k++) {
                const segmentAngle = angle + (Math.sin(k * 1.7) * 0.25);
                const segmentLength = length / segments;
                
                currentX += Math.cos(segmentAngle) * segmentLength;
                currentY += Math.sin(segmentAngle) * segmentLength;
                
                ctx.lineTo(currentX, currentY);
            }
            
            ctx.stroke();
        }
    }
}

// 4. Adapted ice animation function for decorative lakes
function drawDecorativeIceAnimation(drawX, drawY, lake) {
    const time = Date.now() * 0.001;
    
    // Draw ice cracks pattern
    ctx.strokeStyle = 'rgba(200, 230, 255, 0.5)'; // Slightly more transparent
    ctx.lineWidth = 1.5;
    
    // Create ice crack patterns (more for larger lakes)
    for (let i = 0; i < 7; i++) {
        const yOffset = (i * lake.height/7) + Math.sin(time * 0.4 + i) * 4;
        
        if (yOffset > 0 && yOffset < lake.height) {
            ctx.beginPath();
            ctx.moveTo(drawX + lake.width * 0.15, drawY + yOffset);
            
            // Create jagged line for ice cracks
            for (let x = 0; x <= 8; x++) {
                const waveX = drawX + lake.width * (0.15 + x * 0.0875);
                const waveY = drawY + yOffset + Math.sin(time * 1.3 + x * 2.2 + i) * 4;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.stroke();
        }
    }
    
    // Add multiple ice shine highlights for larger area
    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
    
    // Main highlight
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * 0.6,
        drawY + lake.height * 0.3,
        lake.width * 0.12,
        lake.height * 0.08,
        Math.PI / 5,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Secondary highlight
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * 0.75,
        drawY + lake.height * 0.6,
        lake.width * 0.08,
        lake.height * 0.05,
        -Math.PI / 6,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Moving frost pattern
    const frostTime = (time * 0.5) % 1;
    ctx.fillStyle = 'rgba(245, 250, 255, 0.15)';
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * (0.2 + frostTime * 0.6),
        drawY + lake.height * (0.4 + Math.sin(time) * 0.2),
        lake.width * 0.1,
        lake.height * 0.05,
        time,
        0, Math.PI * 2
    );
    ctx.fill();
}


function drawPonds() {
    gameObjects.ponds.forEach(pond => {
        const drawX = pond.x - cameraX;
        const drawY = pond.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + pond.width >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + pond.height >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to colored shape
            try {
                ctx.drawImage(pondSprite, drawX, drawY, pond.width, pond.height);
            } catch (e) {
                // Fallback to blue oval
                ctx.fillStyle = '#4FC3F7';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/2, 
                    pond.height/2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add some detail to the pond
                ctx.fillStyle = '#29B6F6';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/3, 
                    pond.height/3, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add ripple effects
                drawPondRipples(drawX, drawY, pond);
            }
            
            // Animate water by drawing semi-transparent waves
            drawWaterAnimation(drawX, drawY, pond);
        }
    });
}

// Add ripple effects to pond
function drawPondRipples(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2;
    
    // Draw 3 elliptical ripples that grow and fade over time
    for (let i = 0; i < 3; i++) {
        const offset = i * Math.PI * 0.6; // Offset each ripple
        const size = ((time + offset) % 3) / 3; // 0 to 1 value for size
        
        if (size > 0.1) { // Only draw visible ripples
            ctx.globalAlpha = 0.3 - size * 0.3; // Fade out as they grow
            ctx.beginPath();
            ctx.ellipse(
                drawX + pond.width/2, 
                drawY + pond.height/2, 
                pond.width/2 * size + pond.width/4, 
                pond.height/2 * size + pond.height/4, 
                0, 0, Math.PI * 2
            );
            ctx.stroke();
        }
    }
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

// Animate water surface
function drawWaterAnimation(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    
    // Draw some animated wave lines on the water
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1.5;
    
    // Create wave patterns
    for (let i = 0; i < 5; i++) {
        const yOffset = (i * pond.height/5) + Math.sin(time * 2 + i) * 5;
        
        if (yOffset > 0 && yOffset < pond.height) {
            ctx.beginPath();
            ctx.moveTo(drawX + pond.width * 0.2, drawY + yOffset);
            
            // Create wavy line
            for (let x = 0; x <= 6; x++) {
                const waveX = drawX + pond.width * (0.2 + x * 0.1);
                const waveY = drawY + yOffset + Math.sin(time * 3 + x + i) * 3;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.stroke();
        }
    }
}
// 7. Add bullet drawing function
function drawBullets() {
    for (const bullet of bullets) {
        const drawX = bullet.x - cameraX;
        const drawY = bullet.y - cameraY;
        
        // Only draw if visible on screen
        if (
            drawX + BULLET_SIZE >= 0 &&
            drawX <= canvas.width &&
            drawY + BULLET_SIZE >= 0 &&
            drawY <= canvas.height
        ) {
            // Draw bullet
            ctx.fillStyle = bullet.color || '#FF0000';
            ctx.beginPath();
            ctx.arc(drawX, drawY, BULLET_SIZE/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Optional: Draw trail/tail
            ctx.strokeStyle = bullet.color || '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX, drawY);
            ctx.lineTo(drawX - bullet.dirX * 10, drawY - bullet.dirY * 10);
            ctx.stroke();
        }
    }
}
// Function to draw ammo packs
function drawAmmoPacks() {
    ctx.fillStyle = '#00AAFF'; // Blue color for ammo packs
    
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            const drawX = ammoPack.x - cameraX;
            const drawY = ammoPack.y - cameraY;
            
            // Only draw if visible on screen
            if (
                drawX + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawX <= canvas.width &&
                drawY + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawY <= canvas.height
            ) {
                // Try to draw sprite
                try {
                    ctx.drawImage(ammoPackSprite, drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                } catch (e) {
                    // Fallback to colored rectangle with an "A" on it
                    ctx.fillStyle = '#0088CC';
                    ctx.fillRect(drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                    
                    // Draw a white "A" on the ammo pack
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('A', drawX + AMMO_PACK_SIZE_DISPLAY/2, drawY + AMMO_PACK_SIZE_DISPLAY/2 + 7);
                    
                    // Reset fill style
                    ctx.fillStyle = '#00AAFF';
                }
                
                // Animate ammo pack bob up and down (similar to coins)
                ammoPack.bobOffset = ammoPack.bobOffset || 0;
                ammoPack.bobDirection = ammoPack.bobDirection || 1;
                ammoPack.bobOffset += 0.05 * ammoPack.bobDirection;
                
                if (ammoPack.bobOffset > 5 || ammoPack.bobOffset < 0) {
                    ammoPack.bobDirection *= -1;
                }
            }
        }
    });
}
let lastFlashTime = 0;
const FLASH_COOLDOWN = 500;
function flashScreen(color) {
    const currentTime = Date.now();
    if (currentTime - lastFlashTime < FLASH_COOLDOWN) return;
    lastFlashTime = currentTime;
    // Create overlay div
    
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.boxShadow = 'inset 0 0 50px 20px ' + color; // Create an inset shadow instead of background
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '1000';
    flash.style.backgroundColor = 'transparent'; // No background color
    
    // Add to game container
    gameContainer.appendChild(flash);
    
    // Fade out and remove
    setTimeout(() => {
        flash.style.transition = 'box-shadow 0.3s';
        flash.style.boxShadow = 'inset 0 0 0 0 transparent';
        setTimeout(() => {
            gameContainer.removeChild(flash);
        }, 300);
    }, 100);
}

function playHitConfirmSound() {
    // const hitConfirmSound = new Audio('/hit-confirm.mp3'); // Create this sound or use a placeholder
    // hitConfirmSound.volume = 0.2;
    // hitConfirmSound.play().catch(e => console.log('Audio play failed:', e));
}

        function checkCoinCollection(player) {
            // Define player hitbox
            const playerHitbox = {
                x: player.x + 10,
                y: player.y + 10,
                width: PLAYER_SIZE - 20,
                height: PLAYER_SIZE - 20
            };
            
            // Check collision with each coin
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    // Define coin hitbox
                    const coinHitbox = {
                        x: coin.x + 5,
                        y: coin.y + 5,
                        width: COIN_SIZE - 10,
                        height: COIN_SIZE - 10
                    };
                    
                    // Check hitbox overlap
                    if (
                        playerHitbox.x < coinHitbox.x + coinHitbox.width &&
                        playerHitbox.x + playerHitbox.width > coinHitbox.x &&
                        playerHitbox.y < coinHitbox.y + coinHitbox.height &&
                        playerHitbox.y + playerHitbox.height > coinHitbox.y
                    ) {
                        // Collect the coin (server will validate)
                        socket.emit('collect_coin', coin.id);
                        
                        // Play coin collection sound
                        playCoinSound();
                    }
                }
            });
        }
        function checkAmmoPackCollection(player) {
    // Define player hitbox
    const playerHitbox = {
        x: player.x + 10,
        y: player.y + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Check collision with each ammo pack
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            // Define ammo pack hitbox
            const ammoPackHitbox = {
                x: ammoPack.x + 5,
                y: ammoPack.y + 5,
                width: AMMO_PACK_SIZE_DISPLAY - 10,
                height: AMMO_PACK_SIZE_DISPLAY - 10
            };
            
            // Check hitbox overlap
            if (
                playerHitbox.x < ammoPackHitbox.x + ammoPackHitbox.width &&
                playerHitbox.x + playerHitbox.width > ammoPackHitbox.x &&
                playerHitbox.y < ammoPackHitbox.y + ammoPackHitbox.height &&
                playerHitbox.y + playerHitbox.height > ammoPackHitbox.y
            ) {
                // Collect the ammo pack (server will validate)
                socket.emit('collect_ammo', ammoPack.id);
                
                // Play ammo collection sound
                playAmmoSound();
            }
        }
    });
}
function playAmmoSound() {
    playSound('snowball-get.mp3', 0.5);
}
        function checkCollision(player, newX, newY) {
    // Define player hitbox with some padding for better gameplay
    const playerHitbox = {
        x: newX + 10,
        y: newY + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Calculate player center coordinates - ADD THESE LINES
    const playerCenterX = newX + PLAYER_SIZE/2;
    const playerCenterY = newY + PLAYER_SIZE/2;
    // Check collision with trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Trees have a smaller collision box than visual size
        const treeHitbox = {
            x: tree.x + treeSize * 0.2,
            y: tree.y + treeSize * 0.5, // Mostly bottom part (trunk)
            width: treeSize * 0.6,
            height: treeSize * 0.5
        };
        
        if (
            playerHitbox.x < treeHitbox.x + treeHitbox.width &&
            playerHitbox.x + playerHitbox.width > treeHitbox.x &&
            playerHitbox.y < treeHitbox.y + treeHitbox.height &&
            playerHitbox.y + playerHitbox.height > treeHitbox.y
        ) {
            return true; // Collision detected
        }
    }
    
    // Check collision with rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        // Rocks have a slightly smaller collision box
        const rockHitbox = {
            x: rock.x + rockSize * 0.1,
            y: rock.y + rockSize * 0.1,
            width: rockSize * 0.8,
            height: rockSize * 0.8
        };
        
        if (
            playerHitbox.x < rockHitbox.x + rockHitbox.width &&
            playerHitbox.x + playerHitbox.width > rockHitbox.x &&
            playerHitbox.y < rockHitbox.y + rockHitbox.height &&
            playerHitbox.y + playerHitbox.height > rockHitbox.y
        ) {
            return true; // Collision detected
        }
    }
     // Check deep water collision (allow wading at edges but not deep water)
    for (const pond of gameObjects.ponds) {
        // Calculate pond center and radiuses
        const pondCenterX = pond.x + pond.width/2;
        const pondCenterY = pond.y + pond.height/2;
        const pondRadiusX = pond.width/2;
        const pondRadiusY = pond.height/2;
        
        // Calculate normalized distance from center (elliptical equation)
        // For a point (x,y) in an ellipse with center (h,k) and radii a,b:
        // ((x-h)/a)² + ((y-k)/b)² <= 1 means the point is inside the ellipse
        const dx = (playerCenterX - pondCenterX) / pondRadiusX;
        const dy = (playerCenterY - pondCenterY) / pondRadiusY;
        const distanceSquared = dx*dx + dy*dy;
        
        // If player is deeper than 70% into the pond (from edge to center), block movement
        // This allows the player to wade in the shallow edges (30% from the edge)
        if (distanceSquared < 0.7*0.7) {  // Using 0.7² to avoid square root calculation
            return true; // Too deep in water
        }
        
        // Optional: Add movement penalty when in shallow water
        // This would be handled elsewhere in movement code
    }
    
    return false; // No collision
}
function playCoinSound() {
    playSound('coin-sound.mp3', 0.3);
}
        
        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message.length > 0) {
                socket.emit('chat_message', message);
                chatInput.value = '';
            }
        }
        
        function addChatMessage(username, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.textContent = `${username}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function gameLoop() {
            if (!myId || !players[myId]) {
                requestAnimationFrame(gameLoop);
                return;
            }
             // Update player movement based on key states
            updatePlayerMovement();
            // Update camera position to follow player
            const player = players[myId];
            cameraX = player.x - canvas.width / 2 + PLAYER_SIZE / 2;
            cameraY = player.y - canvas.height / 2 + PLAYER_SIZE / 2;
            
            // Clamp camera to world bounds
            cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - canvas.height));
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            ctx.fillStyle = '#7CFC00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds (optional)
            //drawPixelatedGrass();
            drawPixelatedSnow();
           
            // Draw rocks
           
             drawDecorativeLakes();
            //draw ponds
            drawPonds();
            //drawIce();
            // Draw trees
            drawGameObjects(gameObjects.trees, treeSprite, 'green');
            
            // Draw coins
           
            drawPlayers();
            drawGameObjects(gameObjects.rocks, rockSprite, 'gray');
             
             // Draw ammo packs
            drawAmmoPacks();
            if (isFishing) {
                drawFishingProgress();
            }
    drawBaitPacks();
    drawCoins();
    drawBullets();
    drawClouds();
    drawFallingSnow();
    // Draw fish inventory if open
    if (isInventoryOpen) {
        drawFishInventory();
    }
    
    updateBullets(16);
     updateMinimap();
    const now = Date.now();
    const INTERPOLATION_DURATION = 100; // ms
    
    // Process position buffer for smooth movement
    for (let i = positionBuffer.length - 1; i >= 0; i--) {
        const move = positionBuffer[i];
        const elapsed = now - move.timestamp;
        
        if (elapsed >= INTERPOLATION_DURATION) {
            // Apply final position and remove from buffer
            if (players[move.id]) {
                players[move.id].x = move.toX;
                players[move.id].y = move.toY;
            }
            positionBuffer.splice(i, 1);
        } else {
            // Interpolate position
            const progress = elapsed / INTERPOLATION_DURATION;
            move.progress = progress;
            
            if (players[move.id]) {
                // Ease-out function for smoother motion
                const t = 1 - Math.pow(1 - progress, 2);
                players[move.id].x = move.fromX + (move.toX - move.fromX) * t;
                players[move.id].y = move.fromY + (move.toY - move.fromY) * t;
            }
        }
    }
   
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }
       function updatePlayerMovement() {
    if (!myId || !players[myId]) return;
    
    const player = players[myId];
    let newX = player.x;
    let newY = player.y;
    let moved = false;
    

    // Save original position for rollback if needed
    const originalX = player.x;
    const originalY = player.y;
    
    // Calculate movement based on active keys with improved delta time
    const now = performance.now();
    const deltaTime = now - (lastUpdateTime || now);
    const deltaFactor = deltaTime / 16.67; // Normalize to 60fps
    lastUpdateTime = now;
    
    // Base speed adjusted by delta time for consistent speed regardless of frame rate
    const adjustedSpeed = PLAYER_SPEED * Math.min(deltaFactor, 2.0); // Cap to prevent huge jumps
    
    if (keys.up) {
        newY -= adjustedSpeed;
        moved = true;
    }
    if (keys.down) {
        newY += adjustedSpeed;
        moved = true;
    }
    if (keys.left) {
        newX -= adjustedSpeed;
        moved = true;
    }
    if (keys.right) {
        newX += adjustedSpeed;
        moved = true;
    }
    
    // If diagonal movement, normalize speed
    if ((keys.up || keys.down) && (keys.left || keys.right)) {
        const diagonalFactor = 0.7071; // 1/sqrt(2)
        if (keys.up) newY = player.y - adjustedSpeed * diagonalFactor;
        if (keys.down) newY = player.y + adjustedSpeed * diagonalFactor;
        if (keys.left) newX = player.x - adjustedSpeed * diagonalFactor;
        if (keys.right) newX = player.x + adjustedSpeed * diagonalFactor;
    }
    
    // Keep player within world bounds
    if (newX < 0) newX = 0;
    if (newY < 0) newY = 0;
    if (newX > WORLD_WIDTH - PLAYER_SIZE) newX = WORLD_WIDTH - PLAYER_SIZE;
    if (newY > WORLD_HEIGHT - PLAYER_SIZE) newY = WORLD_HEIGHT - PLAYER_SIZE;
    
    // Check for collision with obstacles
    if (moved && !checkCollision(player, newX, newY)) {
        // Apply movement locally first (client-side prediction)
        players[myId].x = newX;
        players[myId].y = newY;
        
        // Check for collectibles
        checkCoinCollection(player);
        checkAmmoPackCollection(player);
        checkBaitPackCollection(player);
        
        // Send updated position to server with timestamp
        const now = Date.now();
        if (now - lastMovementUpdate >= MOVEMENT_UPDATE_INTERVAL) {
            lastMovementUpdate = now;
            socket.emit('move', {
                x: newX,
                y: newY,
                timestamp: now
            });
        }
    } else if (moved) {
        // If there's a collision, revert to last valid position
        players[myId].x = originalX;
        players[myId].y = originalY;
    }
}
function drawClouds() {
    // Winter cloud settings - using blue-gray tones
    // Choose one of these color options:
    
    // Option 1: Light Gray Clouds
    // ctx.fillStyle = 'rgba(220, 220, 220, 0.8)';
    
    // Option 2: Soft Blue-Gray Clouds (recommended for winter theme)
    ctx.fillStyle = 'rgba(210, 218, 230, 0.8)';
    
    // Option 3: White with blue tint
    // ctx.fillStyle = 'rgba(240, 248, 255, 0.8)';
    
    // Use time to animate clouds
    const time = Date.now() * 0.0002;
    
    // Create fewer clouds with larger minimum size
    // and make them move horizontally
    const cloudSpacingX = 1200; // Increased from 800 for larger world
    const cloudSpacingY = 800;  // Increased from 500 for larger world
    
    // Determine visible area based on camera position
    const visibleLeft = cameraX;
    const visibleRight = cameraX + canvas.width;
    const visibleTop = cameraY;
    const visibleBottom = cameraY + canvas.height;
    
    // Generate clouds in the visible area (with buffer for smooth scrolling)
    for (let baseY = Math.floor(visibleTop / cloudSpacingY) * cloudSpacingY - cloudSpacingY; 
         baseY <= visibleBottom + cloudSpacingY; 
         baseY += cloudSpacingY) {
        
        // For each row, create fewer clouds
        for (let i = 0; i < 5; i++) {
            // Create a cloud with consistent movement based on position
            const seed = baseY * 0.1 + i * 1000;
            const random = Math.abs(Math.sin(seed)) * 10000 % 1;
            
            // Calculate base position
            let baseX = (i * cloudSpacingX) + (random * cloudSpacingX);
            
            // Apply horizontal movement based on time
            // Different rows move at different speeds and directions
            const speedFactor = (baseY % 3 === 0) ? 1 : ((baseY % 3 === 1) ? -0.7 : 0.5);
            const movement = time * 100 * speedFactor;
            
            // Wrap around the world width
            baseX = (baseX + movement) % (WORLD_WIDTH + cloudSpacingX);
            if (baseX < -cloudSpacingX) baseX += WORLD_WIDTH + cloudSpacingX;
            
            // Determine cloud size (larger minimum size)
            const minSize = 220; // Increased minimum size
            const maxSize = 500;
            const sizeVariation = Math.max(0.5, 1 - (baseY / WORLD_HEIGHT));
            const cloudSize = minSize + (maxSize - minSize) * sizeVariation * random;
            
            const drawX = baseX - cameraX;
            const drawY = baseY - cameraY;
            
            // Only draw if potentially visible
            if (drawX + cloudSize >= -200 && 
                drawX <= canvas.width + 200 && 
                drawY + cloudSize >= -200 && 
                drawY <= canvas.height + 200) {
                
                // Draw cloud with MORE overlapping circles to avoid triangle gaps
                ctx.beginPath();
                
                // Main center circle
                ctx.arc(drawX, drawY, cloudSize * 0.5, 0, Math.PI * 2);
                
                // Additional circles to create fuller shape without gaps
                ctx.arc(drawX + cloudSize * 0.4, drawY - cloudSize * 0.1, cloudSize * 0.45, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.3, drawY, cloudSize * 0.4, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.1, drawY + cloudSize * 0.1, cloudSize * 0.35, 0, Math.PI * 2);
                
                // Add more circles to fill gaps
                ctx.arc(drawX - cloudSize * 0.15, drawY - cloudSize * 0.15, cloudSize * 0.35, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.25, drawY + cloudSize * 0.05, cloudSize * 0.3, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.1, drawY + cloudSize * 0.2, cloudSize * 0.25, 0, Math.PI * 2);
                
                // Fill the entire shape
                ctx.fill();
                
                // Optional: Add darker bottom to clouds to suggest snow
                ctx.fillStyle = 'rgba(190, 200, 220, 0.4)';
                ctx.beginPath();
                ctx.arc(drawX, drawY + cloudSize * 0.1, cloudSize * 0.45, 0, Math.PI);
                ctx.arc(drawX - cloudSize * 0.25, drawY + cloudSize * 0.15, cloudSize * 0.3, 0, Math.PI);
                ctx.arc(drawX + cloudSize * 0.25, drawY + cloudSize * 0.12, cloudSize * 0.35, 0, Math.PI);
                ctx.fill();
            }
        }
    }
    
    // Optional: Add occasional falling snowflakes
   // drawFallingSnow();
}

// Add a new function to create falling snow effect
// Simple diagonal snow effect for top-down view
function drawFallingSnow() {
    // Create snow array once
    if (!window.snowflakes) {
        window.snowflakes = [];
        // Create snowflakes around the camera view
        for (let i = 0; i < 300; i++) {
            window.snowflakes.push(createSnowflakeAtCamera());
        }
    }
    
    // Draw and update each snowflake
    ctx.fillStyle = '#FFFFFF';
    
    for (let i = 0; i < window.snowflakes.length; i++) {
        const flake = window.snowflakes[i];
        
        // Calculate screen position (relative to camera)
        const drawX = flake.x - cameraX;
        const drawY = flake.y - cameraY;
        
        // Only draw if visible on screen (with small buffer)
        if (
            drawX >= -20 &&
            drawX <= canvas.width + 20 &&
            drawY >= -20 &&
            drawY <= canvas.height + 20
        ) {
            // Set opacity for this snowflake
            ctx.globalAlpha = flake.opacity;
            
            // Draw snowflake as a simple circle
            ctx.beginPath();
            ctx.arc(drawX, drawY, flake.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Update snowflake position - diagonal movement
        flake.x += flake.speedX;
        flake.y += flake.speedY;
        
        // Check if the snowflake is far outside the camera view
        // Use a larger boundary than drawing boundary
        const farOffScreen = 
            drawX < -100 || 
            drawX > canvas.width + 100 || 
            drawY < -100 || 
            drawY > canvas.height + 100;
            
        // If far off screen, recycle the snowflake to a new position near the camera
        if (farOffScreen) {
            // Determine which edge to place the new snowflake based on the movement direction
            // Since we're moving diagonally down-left, place new flakes at top or right edges
            const edgeChoice = Math.random() > 0.5 ? 'top' : 'right';
            
            if (edgeChoice === 'top') {
                // Place at random position along top edge of camera view
                flake.x = cameraX + Math.random() * canvas.width;
                flake.y = cameraY - 10 - Math.random() * 20; // Slightly above camera view
            } else {
                // Place at random position along right edge of camera view
                flake.x = cameraX + canvas.width + 10 + Math.random() * 20; // Slightly right of camera view
                flake.y = cameraY + Math.random() * canvas.height;
            }
            
            // Randomize the snowflake properties slightly to keep the effect fresh
            flake.size = Math.random() * 2 + 1;
            flake.speedX = -(Math.random() * 0.5 + 1); // Always moves left
            flake.speedY = Math.random() * 0.5 + 1;    // Always moves down
            flake.opacity = Math.random() * 0.3 + 0.7;
        }
    }
    
    // Reset global alpha
    ctx.globalAlpha = 1.0;
}

// Helper function to create a snowflake near the camera
function createSnowflakeAtCamera() {
    // Determine start position - either above or to the right of camera view
    const edgeChoice = Math.random() > 0.5 ? 'top' : 'right';
    
    let x, y;
    
    if (edgeChoice === 'top') {
        // Place at random position along top edge of camera view
        x = cameraX + Math.random() * canvas.width;
        y = cameraY - 10 - Math.random() * 20; // Slightly above camera view
    } else {
        // Place at random position along right edge of camera view
        x = cameraX + canvas.width + 10 + Math.random() * 20; // Slightly right of camera view
        y = cameraY + Math.random() * canvas.height;
    }
    
    // For initial creation, also randomly place some flakes within the camera view
    if (Math.random() < 0.3) { // 30% chance
        x = cameraX + Math.random() * canvas.width;
        y = cameraY + Math.random() * canvas.height;
    }
    
    return {
        x: x,
        y: y,
        size: Math.random() * 2 + 1,
        // Diagonal speed components
        speedX: -(Math.random() * 0.5 + 1), // Always moves left (negative X)
        speedY: Math.random() * 0.5 + 1,    // Always moves down (positive Y)
        // Slight variance in opacity
        opacity: Math.random() * 0.3 + 0.7
    };
}
        
      function drawGameObjects(objects, sprite, fallbackColor) {
    objects.forEach(obj => {
        // Use our constants instead of default values
        const size = obj === gameObjects.trees ? 
            (obj.size || TREE_SIZE) : 
            (obj === gameObjects.rocks ? 
                (obj.size || ROCK_SIZE) : 
                (obj.size || 50));
        
        const drawX = obj.x - cameraX;
        const drawY = obj.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + size >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + size >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to color shape
            try {
                ctx.drawImage(sprite, drawX, drawY, size, size);
            } catch (e) {
                // Fallback to colored shape
                ctx.fillStyle = fallbackColor;
                
                if (objects === gameObjects.rocks) {
                    // Draw rock (irregular circle)
                    ctx.beginPath();
                    ctx.ellipse(drawX + size/2, drawY + size/2, size/2, size/2 * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (objects === gameObjects.trees) {
                    // Draw tree (triangle top with rectangle trunk)
                    ctx.fillStyle = '#8B4513'; // Brown trunk
                    ctx.fillRect(drawX + size/3, drawY + size/2, size/3, size/2);
                    
                    ctx.fillStyle = '#006400'; // Dark green foliage
                    ctx.beginPath();
                    ctx.moveTo(drawX, drawY + size/2);
                    ctx.lineTo(drawX + size/2, drawY);
                    ctx.lineTo(drawX + size, drawY + size/2);
                    ctx.fill();
                }
            }
        }
    });
}
        
        function drawCoins() {
            ctx.fillStyle = '#FFD700'; // Gold color
            
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    const drawX = coin.x - cameraX;
                    const drawY = coin.y - cameraY;
                    
                    // Only draw if visible on screen
                    if (
                        drawX + COIN_SIZE >= 0 &&
                        drawX <= canvas.width &&
                        drawY + COIN_SIZE >= 0 &&
                        drawY <= canvas.height
                    ) {
                        // Try to draw sprite
                        try {
                            ctx.drawImage(coinSprite, drawX, drawY, COIN_SIZE, COIN_SIZE);
                        } catch (e) {
                            // Fallback to gold circle
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Add coin detail (inner circle)
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/4, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = '#FFD700';
                        }
                        
                        // Animate coin bob up and down
                        coin.bobOffset = coin.bobOffset || 0;
                        coin.bobDirection = coin.bobDirection || 1;
                        coin.bobOffset += 0.05 * coin.bobDirection;
                        
                        if (coin.bobOffset > 5 || coin.bobOffset < 0) {
                            coin.bobDirection *= -1;
                        }
                    }
                }
            });
        }
        
        function drawPlayers() {
    for (const id in players) {
        const player = players[id];
        const drawX = player.x - cameraX;
        const drawY = player.y - cameraY;
        
        // Only draw if visible on screen
        if (
            drawX + PLAYER_SIZE >= 0 &&
            drawX <= canvas.width &&
            drawY + PLAYER_SIZE >= 0 &&
            drawY <= canvas.height
        ) {
            // First draw colored square (for customized color)
            ctx.fillStyle = player.color || '#FF0000';
            ctx.fillRect(drawX, drawY, PLAYER_SIZE, PLAYER_SIZE);
            
            // Then draw player sprite with transparency
            try {
                ctx.globalAlpha = 0.7; // Make sprite semi-transparent
                ctx.drawImage(playerSprite, drawX, drawY, PLAYER_SIZE, PLAYER_SIZE);
                ctx.globalAlpha = 1.0; // Reset alpha
            } catch (e) {
                // If sprite fails, we already have the colored square
            }
            
            // Draw player name with improved visibility
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            
            // Use a dark color that stands out against snow (no shadow)
            ctx.fillStyle = '#000000'; // Black text
            ctx.fillText(player.username, drawX + PLAYER_SIZE / 2, drawY - 5);
            
            // Draw player score
            if (player.score !== undefined) {
                ctx.fillStyle = '#000000'; // Same black color
                ctx.fillText(`${player.score} pts`, drawX + PLAYER_SIZE / 2, drawY - 25);
            }
        }
    }
}
let currentFishingPond = null;
function findNearestPond(playerX, playerY) {
    let nearestPond = null;
    let shortestDistance = Infinity;
    
    for (const pond of gameObjects.ponds) {
        // Calculate distance from player center to pond center
        const playerCenterX = playerX + PLAYER_SIZE/2;
        const playerCenterY = playerY + PLAYER_SIZE/2;
        const pondCenterX = pond.x + pond.width/2;
        const pondCenterY = pond.y + pond.height/2;
        
        const distance = Math.sqrt(
            Math.pow(playerCenterX - pondCenterX, 2) + 
            Math.pow(playerCenterY - pondCenterY, 2)
        );
        
        if (distance < shortestDistance) {
            shortestDistance = distance;
            nearestPond = pond;
        }
    }
    
    return { pond: nearestPond, distance: shortestDistance };
}

      function isPlayerInWater() {
    if (!myId || !players[myId]) return false;
    
    const player = players[myId];
    const playerCenter = {
        x: player.x + PLAYER_SIZE/2,
        y: player.y + PLAYER_SIZE/2
    };
    
    // Check each pond
    for (const pond of gameObjects.ponds) {
        // Use ellipse equation to check if player is in the pond
        const dx = (playerCenter.x - (pond.x + pond.width/2)) / (pond.width/2);
        const dy = (playerCenter.y - (pond.y + pond.height/2)) / (pond.height/2);
        
        if (dx*dx + dy*dy <= 1) {
            return true;
        }
    }
    
    return false;
}


// Start fishing minigame


function startFishing() {
    if (isFishing) return;
    
    // Check if player has bait
    if (currentBait <= 0) {
        // Show message that player needs bait
        addChatMessage('System', 'You need bait to fish! Find bait packs around the map.');
        return;
    }
    
    // Find the nearest pond and store it for the entire fishing session
    const player = players[myId];
    const { pond: nearestPond, distance } = findNearestPond(player.x, player.y);
    
    if (!nearestPond) {
        addChatMessage('System', "You're not close enough to a fishing spot!");
        return;
    }
    
    // Store the pond for the entire fishing session
    currentFishingPond = nearestPond;
    
    isFishing = true;
    fishingProgress = 0;
    fishingSuccess = false;
    fishingResult = null;
    
    // Use bait instead of ammo
    currentBait--;
    updateBaitDisplay();
    
    // Show fishing message
    //addChatMessage('System', 'Fishing started! Click when the indicator is in the green zone to catch a fish!');
    
    // Simulate rod casting animation
    playSound('splash.mp3', 0.3);
    
    // Start fishing minigame
    fishingTimeout = setTimeout(() => {
        if (isFishing) {
            // If player didn't click in time, fishing fails
            isFishing = false;
            currentFishingPond = null; // Reset fishing pond
            playSound('missedFish.mp3', 1);
            addChatMessage('System', 'You missed your chance! The fish got away.');
        }
    }, 3000); // 3 seconds to click

    // Tell server we've used bait
    socket.emit('update_bait', { bait: currentBait });
}

// Handle fishing progress
function drawFishingProgress() {
  if (!isFishing) return;
    
    const player = players[myId];
    const drawX = player.x - cameraX;
    const drawY = player.y - cameraY;
    
     // Find the nearest pond to target
     const pond = currentFishingPond;
    
    if (pond) {  
        // Get player center coordinates
        const playerCenterX = player.x + PLAYER_SIZE/2;
        const playerCenterY = player.y + PLAYER_SIZE/2;
        
        // Get pond center coordinates
        const pondCenterX = pond.x + pond.width/2; 
        const pondCenterY = pond.y + pond.height/2;  
        
        // Convert to screen coordinates
        const rodEndX = pondCenterX - cameraX;
        const rodEndY = pondCenterY - cameraY;
        
        // Draw fishing line from player to pond center
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(drawX + PLAYER_SIZE/2, drawY + PLAYER_SIZE/2);
        ctx.lineTo(rodEndX, rodEndY);
        ctx.stroke();
        
        // Draw fishing float at the pond center
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(rodEndX, rodEndY, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Add bobber ripples centered in pond
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        const time = Date.now() * 0.003;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(rodEndX, rodEndY, 8 + i * 4 + time % 10, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    // Draw fishing progress bar 
    const progressBarWidth = 200;
    const progressBarHeight = 30;
    const progressBarX = (canvas.width - progressBarWidth) / 2;
    const progressBarY = canvas.height - 100;
    
    // Update fishing progress based on time
    fishingProgress = (Date.now() % 1000) / 1000;
    
    // Draw progress bar background
    ctx.fillStyle = '#332727';
    ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
    
    // Draw success zone
    const successZoneWidth = progressBarWidth * 0.3;
    const timeOffset = Math.floor(Date.now() / 3000);
    const successZonePosition = ((Math.sin(timeOffset) + 1) / 2) * (progressBarWidth - successZoneWidth);
    const successZoneStart = progressBarX + successZonePosition;
    
    ctx.fillStyle = '#8bf0a8';
    ctx.fillRect(successZoneStart, progressBarY, successZoneWidth, progressBarHeight);
    
    // Draw progress indicator
    const indicatorPos = progressBarX + progressBarWidth * fishingProgress;
    ctx.fillStyle = '#c23636';
    ctx.fillRect(indicatorPos - 2, progressBarY, 4, progressBarHeight);
    
    // Check if in success zone
    const inSuccessZone = 
        indicatorPos >= successZoneStart && 
        indicatorPos <= successZoneStart + successZoneWidth;
    
    if (inSuccessZone) {
        ctx.fillStyle = '#FF0000';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('CLICK NOW!', canvas.width / 2, progressBarY - 10);
    }
    
    // Setup click handler
    canvas.onclick = function() {
        if (inSuccessZone) {
            catchFish(true);
        } else {
            catchFish(false);
        }
        canvas.onclick = null;
    };
}
// Handle caught fish
function catchFish(success) {
    if (!isFishing) return;
    
    // Clear fishing timeout
    clearTimeout(fishingTimeout);
    isFishing = false;
     currentFishingPond = null;
    if (success) {
        // Request a fish from the server
        socket.emit('catch_fish');
        addChatMessage('System', 'You got a bite! Waiting to see what you caught...');
        playSound('catch.mp3', 0.4);
    } else {
        addChatMessage('System', 'You missed! Better luck next time.');
        playSound('missedFish.mp3', 1);
    }
}

// Render fish inventory
function toggleFishInventory() {
    isInventoryOpen = !isInventoryOpen;
    
    if (isInventoryOpen) {
        // Request latest fish inventory from server
        socket.emit('get_fish_inventory');
    }
}

// Draw the fish inventory screen
function drawFishInventory() {
    // Semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Inventory panel
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Draw panel background
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    
    // Panel title
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    
    // Display different title based on viewing mode
    if (viewingOtherPlayer) {
        ctx.fillText(`${viewingPlayerName}'s Fish Collection`, panelX + panelWidth/2, panelY + 40);
    } else {
        ctx.fillText('Fish Collection', panelX + panelWidth/2, panelY + 40);
    }
    
    // Add search input
    const searchInputWidth = 200;
    const searchButtonWidth = 80;
    const searchInputHeight = 30;
    
    ctx.fillStyle = '#EEEEEE';
    ctx.fillRect(panelX + 30, panelY + 60, searchInputWidth, searchInputHeight);
    ctx.strokeStyle = '#AAAAAA';
    ctx.strokeRect(panelX + 30, panelY + 60, searchInputWidth, searchInputHeight);
    
    // Add search button
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(panelX + 30 + searchInputWidth + 10, panelY + 60, searchButtonWidth, searchInputHeight);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Search', panelX + 30 + searchInputWidth + 10 + searchButtonWidth/2, panelY + 60 + searchInputHeight/2 + 5);
    
    // Add search placeholder/text
    ctx.fillStyle = '#888888';
    ctx.textAlign = 'left';
    ctx.fillText(currentSearchQuery || 'Enter player name...', panelX + 40, panelY + 60 + searchInputHeight/2 + 5);
    
    // Back button if viewing other player's inventory
    if (viewingOtherPlayer) {
        ctx.fillStyle = '#2196F3';
        ctx.fillRect(panelX + panelWidth - 150, panelY + 60, 100, searchInputHeight);
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.fillText('Back to Mine', panelX + panelWidth - 100, panelY + 60 + searchInputHeight/2 + 5);
    }
    
    // Close button
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(panelX + panelWidth - 30, panelY + 10, 20, 20);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('×', panelX + panelWidth - 20, panelY + 25);
    
    // Draw fish section
    // Check if we have fish to display
    if (fishInventory.length === 0) {
        ctx.fillStyle = '#666666';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        if (viewingOtherPlayer) {
            ctx.fillText(`${viewingPlayerName} hasn't caught any fish yet.`, panelX + panelWidth/2, panelY + panelHeight/2);
        } else {
            ctx.fillText('No fish caught yet. Go fishing!', panelX + panelWidth/2, panelY + panelHeight/2);
        }
    } else {
        // Display fish in a grid with scrolling
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const startX = panelX + (panelWidth - (columns * itemSize)) / 2;
        
        // Set up scrollable area
        const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
        const viewportHeight = panelHeight - 180; // Space for title, search, and stats
        const viewportY = panelY + 100; // Start below search box
        
        // Create clipPath for the scrollable area
        ctx.save();
        ctx.beginPath();
        ctx.rect(panelX + 10, viewportY, panelWidth - 20, viewportHeight);
        ctx.clip();
        
        // Apply scroll offset
        const scrollY = viewportY - inventoryScrollOffset;
        
        deleteButtonPositions = [];


        // Draw fish items
        fishInventory.forEach((fish, index) => {
            const col = index % columns;
            const row = Math.floor(index / columns);
            const x = startX + col * itemSize;
            const y = scrollY + row * itemSize;
            
            // Only draw if it would be visible (optimization)
            if (y + itemSize >= viewportY && y <= viewportY + viewportHeight) {
                // Draw fish slot background
                ctx.fillStyle = '#F0F0F0';
                ctx.fillRect(x, y, itemSize - 10, itemSize - 10);
                
                // Draw fish sprite if available
                try {
                    const fishSprite = fishSprites[`fish${fish.typeId}`];
                    ctx.drawImage(fishSprite, x + 10, y + 10, itemSize - 30, itemSize - 50);
                } catch (e) {
                    // Fallback to colored rectangle if sprite not available
                    ctx.fillStyle = getFishColor(fish.typeId);
                    ctx.fillRect(x + 10, y + 10, itemSize - 30, itemSize - 50);
                }
                
                // Draw fish details
                ctx.fillStyle = '#333333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(fish.name, x + (itemSize - 10)/2, y + itemSize - 35);
                ctx.fillText(`${fish.size} cm`, x + (itemSize - 10)/2, y + itemSize - 20);
                
                // Draw rarity indicator
                const rarityColor = getRarityColor(fish.rarity);
                ctx.fillStyle = rarityColor;
                ctx.fillRect(x + (itemSize - 40)/2, y + itemSize - 15, 40, 10);
                
                // Add delete button for each fish ONLY for own inventory (not when viewing others)
                if (!viewingOtherPlayer) {
                    ctx.fillStyle = '#FF3B30';
                    ctx.fillRect(x + itemSize - 25, y + 5, 15, 15);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('×', x + itemSize - 17, y + 15);
                    
                    // Store button coordinates for click detection
                    deleteButtonPositions.push({
        x: x + itemSize - 25,
        y: y + 5,  // This is already the actual Y position on screen
        width: 15,
        height: 15,
        fishId: fish.id,
        fishName: fish.name,
        fishRarity: fish.rarity
    });
                }
            }
        });
        
        // Restore the context to remove clip
        ctx.restore();
        
        // Draw scrollbar if needed
        if (contentHeight > viewportHeight) {
            const scrollbarHeight = (viewportHeight / contentHeight) * viewportHeight;
            const scrollbarPosition = (inventoryScrollOffset / (contentHeight - viewportHeight)) * (viewportHeight - scrollbarHeight);
            
            // Draw scroll track
            ctx.fillStyle = '#EEEEEE';
            ctx.fillRect(panelX + panelWidth - 20, viewportY, 10, viewportHeight);
            
            // Draw scrollbar
            ctx.fillStyle = '#BBBBBB';
            ctx.fillRect(panelX + panelWidth - 20, viewportY + scrollbarPosition, 10, scrollbarHeight);
        }
    }
    
    // Stats section
    const statsY = panelY + panelHeight - 60;
    
    ctx.fillStyle = '#333333';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    
    // Calculate stats
    const totalFish = fishInventory.length;
    const uniqueTypes = new Set(fishInventory.map(fish => fish.typeId)).size;
    const largestFish = fishInventory.length > 0 ? 
        Math.max(...fishInventory.map(fish => fish.size)) : 0;
    
    ctx.fillText(`Total Caught: ${totalFish}`, panelX + 30, statsY);
    ctx.fillText(`Unique Types: ${uniqueTypes}/10`, panelX + 30, statsY + 25);
    ctx.fillText(`Largest Fish: ${largestFish} cm`, panelX + panelWidth - 200, statsY);
    
    // Handle clicks in inventory
    canvas.onclick = handleInventoryClick;
}

// 2. Add new variables to track whose inventory we're viewing
let viewingOtherPlayer = false;
let viewingPlayerName = '';
let currentSearchQuery = '';

// 3. Update click handling for search functionality
function handleInventoryClick(e) {
    if (!isInventoryOpen) return;
    
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Check if close button clicked
    if (
        canvasX >= panelX + panelWidth - 30 && 
        canvasX <= panelX + panelWidth - 10 &&
        canvasY >= panelY + 10 && 
        canvasY <= panelY + 30
    ) {
        isInventoryOpen = false;
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        canvas.onclick = null; // Remove click handler
        return;
    }
    
    // Search input area dimensions
    const searchInputWidth = 200;
    const searchButtonWidth = 80;
    const searchInputHeight = 30;
    
    // Check if search input clicked
    if (
        canvasX >= panelX + 30 && 
        canvasX <= panelX + 30 + searchInputWidth &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        // Show prompt for player name
        const playerName = prompt("Enter player name to search:", currentSearchQuery || "");
        if (playerName && playerName.trim()) {
            currentSearchQuery = playerName.trim();
            // Request other player's fish inventory
            socket.emit('search_player_fish', { playerName: currentSearchQuery });
            
            // Show loading message
            addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
        }
        return;
    }
    
    // Check if search button clicked
    if (
        canvasX >= panelX + 30 + searchInputWidth + 10 && 
        canvasX <= panelX + 30 + searchInputWidth + 10 + searchButtonWidth &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        if (currentSearchQuery) {
            // Request other player's fish inventory
            socket.emit('search_player_fish', { playerName: currentSearchQuery });
            
            // Show loading message
            addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
        } else {
            // Prompt for player name if empty
            const playerName = prompt("Enter player name to search:");
            if (playerName && playerName.trim()) {
                currentSearchQuery = playerName.trim();
                socket.emit('search_player_fish', { playerName: currentSearchQuery });
                
                // Show loading message
                addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
            }
        }
        return;
    }
    
    // Check if back button clicked (when viewing other player's inventory)
    if (
        viewingOtherPlayer &&
        canvasX >= panelX + panelWidth - 150 && 
        canvasX <= panelX + panelWidth - 50 &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        // Reset to own inventory
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        inventoryScrollOffset = 0;
        socket.emit('get_fish_inventory');
        return;
    }
    
    // Handle delete button clicks only if viewing own inventory
    if (!viewingOtherPlayer) {
        for (const button of deleteButtonPositions) {
            if (
                canvasX >= button.x &&
                canvasX <= button.x + button.width &&
                canvasY >= button.y &&
                canvasY <= button.y + button.height
            ) {
                // Show confirmation dialog
                if (confirm(`Are you sure you want to remove this ${button.fishRarity} ${button.fishName}?`)) {
                    deleteFish(button.fishId);
                }
                return;
            }
        }
    }
    
    // Handle scrollbar clicks
    const viewportHeight = panelHeight - 180;
    const viewportY = panelY + 100;
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    
    if (contentHeight > viewportHeight && 
        canvasX >= panelX + panelWidth - 20 && 
        canvasX <= panelX + panelWidth - 10 &&
        canvasY >= viewportY && 
        canvasY <= viewportY + viewportHeight) {
        
        // Calculate new scroll position based on click position
        const clickPosition = (canvasY - viewportY) / viewportHeight;
        inventoryScrollOffset = clickPosition * (contentHeight - viewportHeight);
        
        // Redraw inventory with new scroll position
        drawFishInventory();
        return;
    }
}
// Variables for scroll handling
let inventoryScrollOffset = 0;
let isDraggingScrollbar = false;
let lastMouseY = 0;

// Add mouse wheel handler for scrolling the inventory
function handleInventoryScroll(e) {
    if (!isInventoryOpen) return;
    
    e.preventDefault();
    
    // Get panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Get mouse position relative to canvas
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Check if mouse is over the inventory panel
    if (
        mouseX >= panelX && 
        mouseX <= panelX + panelWidth &&
        mouseY >= panelY && 
        mouseY <= panelY + panelHeight
    ) {
        // Calculate scroll bounds
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
        const viewportHeight = panelHeight - 150;
        
        if (contentHeight > viewportHeight) {
            // Update scroll offset based on wheel direction
            inventoryScrollOffset += e.deltaY * 0.5; // Adjust scroll speed
            
            // Clamp scroll offset to valid range
            inventoryScrollOffset = Math.max(0, Math.min(contentHeight - viewportHeight, inventoryScrollOffset));
            
            // Redraw inventory with new scroll position
            drawFishInventory();
        }
    }
}

// Add mouse down handler for dragging the scrollbar
function handleMouseDown(e) {
    if (!isInventoryOpen) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Check if scrollbar is clicked
    const viewportHeight = panelHeight - 150;
    if (
        mouseX >= panelX + panelWidth - 20 && 
        mouseX <= panelX + panelWidth - 10 &&
        mouseY >= panelY + 70 && 
        mouseY <= panelY + 70 + viewportHeight
    ) {
        isDraggingScrollbar = true;
        lastMouseY = mouseY;
    }
}

// Add mouse move handler for dragging the scrollbar
function handleMouseMove(e) {
    if (!isInventoryOpen || !isDraggingScrollbar) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.left;
    
    // Calculate mouse movement
    const deltaY = mouseY - lastMouseY;
    lastMouseY = mouseY;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    
    // Calculate scroll bounds
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    const viewportHeight = panelHeight - 150;
    
    if (contentHeight > viewportHeight) {
        // Update scroll offset based on drag amount
        const scrollRatio = contentHeight / viewportHeight;
        inventoryScrollOffset += deltaY * scrollRatio;
        
        // Clamp scroll offset to valid range
        inventoryScrollOffset = Math.max(0, Math.min(contentHeight - viewportHeight, inventoryScrollOffset));
        
        // Redraw inventory with new scroll position
        drawFishInventory();
    }
}

// Add mouse up handler to end scrollbar dragging
function handleMouseUp() {
    isDraggingScrollbar = false;
}

// Initialize event listeners for scrolling
function initScrollListeners() {
    canvas.addEventListener('wheel', handleInventoryScroll, { passive: false });
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
}
function setupSocketHandlers() {
    // Make sure this is added alongside your other socket.on handlers
    socket.on('other_player_fish', (data) => {
        if (data.error) {
            // Show error message if player not found
            addChatMessage('System', data.error);
        } else {
            // Switch to viewing other player's fish
            viewingOtherPlayer = true;
            viewingPlayerName = data.playerName;
            fishInventory = data.fishes;
            inventoryScrollOffset = 0; // Reset scroll position
            
            // Sort inventory by rarity and size
            fishInventory.sort((a, b) => {
                const rarityOrder = { 'Common': 0, 'Uncommon': 1, 'Rare': 2, 'Epic': 3, 'Legendary': 4, 'Mythical': 5 };
                return rarityOrder[b.rarity] - rarityOrder[a.rarity] || b.size - a.size;
            });
            
            // Notify the user
            addChatMessage('System', `Viewing ${data.playerName}'s fish collection.`);
            
            // Redraw inventory
            drawFishInventory();
        }
    });
    
// Handle individual player movements (more efficient than full game state)
socket.on('player_move', (data) => {
    if (data.id === myId) return; // Ignore updates about ourselves
    
    if (players[data.id]) {
        // Add movement to buffer for interpolation
        positionBuffer.push({
            id: data.id,
            fromX: players[data.id].x,
            fromY: players[data.id].y,
            toX: data.x,
            toY: data.y,
            timestamp: Date.now(),
            progress: 0
        });
        
        // Limit buffer size
        if (positionBuffer.length > MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
        
        // Immediately update the target position
        players[data.id].targetX = data.x;
        players[data.id].targetY = data.y;
    }
});

// Handle position corrections from server
socket.on('position_correction', (data) => {
    if (!myId || !players[myId]) return;
    
    // Calculate server-client time difference
    const serverTime = data.timestamp;
    const clientTime = Date.now();
    const latency = clientTime - serverTime;
    
    // Get distance from current position to corrected position
    const dx = data.x - players[myId].x;
    const dy = data.y - players[myId].y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    // Only apply correction if significant and not during user input
    if (distance > 50 && !isAnyKeyPressed()) {
        // Smooth correction over time
        const correctionStartTime = Date.now();
        const correctionDuration = 200; // ms
        
        function applySmoothCorrection() {
            const now = Date.now();
            const elapsed = now - correctionStartTime;
            const progress = Math.min(elapsed / correctionDuration, 1);
            
            // Ease-out function for smoother correction
            const t = 1 - Math.pow(1 - progress, 3);
            
            // Apply partial correction
            players[myId].x = players[myId].x + dx * t;
            players[myId].y = players[myId].y + dy * t;
            
            if (progress < 1) {
                requestAnimationFrame(applySmoothCorrection);
            }
        }
        
        applySmoothCorrection();
    }
});
}
function isAnyKeyPressed() {
    return keys.up || keys.down || keys.left || keys.right;
}
// Update toggleFishInventory to initialize scroll position
function toggleFishInventory() {
    isInventoryOpen = !isInventoryOpen;
    
    if (isInventoryOpen) {
        // Reset state when opening inventory
        inventoryScrollOffset = 0;
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        currentSearchQuery = '';
        
        // Request latest fish inventory from server
        socket.emit('get_fish_inventory');
        
        // Make sure scroll listeners are initialized
        initScrollListeners();
    } else {
        // Clean up when closing inventory
        canvas.onclick = null;
    }
}

// Add keyboard controls for inventory scrolling
window.addEventListener('keydown', (e) => {
    if (!isInventoryOpen) return;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    
    // Calculate scroll bounds
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    const viewportHeight = panelHeight - 150;
    
    if (contentHeight > viewportHeight) {
        const scrollAmount = itemSize; // Scroll one row at a time
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            inventoryScrollOffset = Math.min(contentHeight - viewportHeight, inventoryScrollOffset + scrollAmount);
            drawFishInventory();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            inventoryScrollOffset = Math.max(0, inventoryScrollOffset - scrollAmount);
            drawFishInventory();
        } else if (e.key === 'PageDown') {
            e.preventDefault();
            inventoryScrollOffset = Math.min(contentHeight - viewportHeight, inventoryScrollOffset + viewportHeight);
            drawFishInventory();
        } else if (e.key === 'PageUp') {
            e.preventDefault();
            inventoryScrollOffset = Math.max(0, inventoryScrollOffset - viewportHeight);
            drawFishInventory();
        } else if (e.key === 'Home') {
            e.preventDefault();
            inventoryScrollOffset = 0;
            drawFishInventory();
        } else if (e.key === 'End') {
            e.preventDefault();
            inventoryScrollOffset = contentHeight - viewportHeight;
            drawFishInventory();
        }
    }
});
// 3. Add function to send delete request to server
function deleteFish(fishId) {
    // Send delete request to server
    socket.emit('delete_fish', { fishId: fishId });
    
    // Optimistically remove from local inventory (server will validate)
    fishInventory = fishInventory.filter(fish => fish.id !== fishId);
    
    // Redraw inventory
    drawFishInventory();
    
    // Play sound effect
    playSound('trashcan.mp3', 1);
}

// Helper functions for fish display
function getFishColor(typeId) {
    const colors = [
        '#F44336', '#E91E63', '#9C27B0', '#673AB7', 
        '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', 
        '#009688', '#4CAF50'
    ];
    return colors[(typeId - 1) % colors.length];
}

function getRarityColor(rarity) {
    switch(rarity) {
        case 'Common': return '#AAAAAA';
        case 'Uncommon': return '#4CAF50';
        case 'Rare': return '#2196F3';
        case 'Epic': return '#9C27B0';
        case 'Legendary': return '#FFD700';
        case 'Mythical': return '#cc0000';
        default: return '#AAAAAA';
    }
}
document.getElementById('closeInstructionsButton').addEventListener('click', function() {
    hideInstructions();
});

function updateBaitDisplay() {
    const baitDisplay = document.getElementById('baitDisplay');
    if (baitDisplay) {
        baitDisplay.textContent = `Bait: ${currentBait}/${MAX_BAIT}`;
        
        // Change color based on bait level
        if (currentBait <= 2) {
            baitDisplay.style.color = '#FF0000'; // Red for low bait
        } else if (currentBait <= 4) {
            baitDisplay.style.color = '#FFA500'; // Orange for medium bait
        } else {
            baitDisplay.style.color = '#000000'; // Black for normal
        }
    }
}
// Function to hide instructions
function hideInstructions() {
    const instructionsCard = document.getElementById('instructionsCard');
    instructionsCard.style.opacity = '0';
    instructionsCard.style.transition = 'opacity 0.3s ease';
    setTimeout(() => {
        instructionsCard.style.display = 'none';
    }, 300);
    
    // Save to localStorage so it doesn't show on every login
    localStorage.setItem('instructionsShown', 'true');
}

// Check localStorage when game initializes
function checkShowInstructions() {
    const instructionsCard = document.getElementById('instructionsCard');
    
    // Only show instructions if they haven't seen them before
    if (localStorage.getItem('instructionsShown') === 'true') {
        instructionsCard.style.display = 'none';
    } else {
        instructionsCard.style.display = 'block';
    }
}

// Add instructions toggle button to the UI
function addInstructionsButton() {
    const button = document.createElement('button');
    button.textContent = 'Game Help';
    button.style.position = 'absolute';
    button.style.top = '10px';
    button.style.left = '50%';
    button.style.transform = 'translateX(-50%)';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.borderRadius = '5px';
    button.style.padding = '8px 15px';
    button.style.cursor = 'pointer';
    button.style.zIndex = '1000';
    
    button.addEventListener('click', function() {
        const instructionsCard = document.getElementById('instructionsCard');
        if (instructionsCard.style.display === 'none') {
            instructionsCard.style.display = 'block';
            instructionsCard.style.opacity = '1';
        } else {
            hideInstructions();
        }
    });
    
    document.getElementById('gameContainer').appendChild(button);
}
// Play sounds with error handling
function playSound(soundFile, volume = 0.5) {
    const currentTime = Date.now();
    
    // Check if the sound is on cooldown
    if (currentTime - soundEffectCooldowns[soundFile] < SOUND_COOLDOWN) {
        // Skip playing if the sound is on cooldown
        return;
    }
    
    // Update the last played time for this sound
    soundEffectCooldowns[soundFile] = currentTime;
    
    try {
        const sound = new Audio(`/${soundFile}`);
        sound.volume = volume;
        
        // Add error handling for audio play
        const playPromise = sound.play();
        
        if (playPromise !== undefined) {
            playPromise.catch(e => {
                console.log(`Sound play failed: ${e}`);
            });
        }
    } catch (e) {
        console.log(`Error playing sound: ${e}`);
    }
}
// Function to initialize music
function setupGameMusic() {
    console.log("Setting up game music...");
    
    // Create brand new audio element
    const bgMusic = new Audio();
    bgMusic.src = '/background-music.mp3'; // Path to your music file
    bgMusic.loop = true;
    bgMusic.volume = 0.3;
    
    // Create UI control
    const musicControl = document.createElement('div');
    musicControl.style.position = 'absolute';
    musicControl.style.top = '120px';
    musicControl.style.left = '0px';
    musicControl.style.zIndex = '1000';
    
    const musicButton = document.createElement('button');
    musicButton.textContent = '🎵 Music: ON';
    musicButton.style.padding = '5px 10px';
    musicButton.style.backgroundColor = '#4CAF50';
    musicButton.style.border = 'none';
    musicButton.style.borderRadius = '3px';
    musicButton.style.cursor = 'pointer';
    
    let isMusicPlaying = false;
    
    // Toggle music state
    musicButton.addEventListener('click', function() {
        console.log("Music button clicked, current state:", isMusicPlaying);
        isMusicPlaying = !isMusicPlaying;
        
        if (isMusicPlaying) {
            // Try to play music
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("Music started successfully");
                    musicButton.textContent = '🎵 Music: ON';
                    musicButton.style.backgroundColor = '#4CAF50';
                }).catch(e => {
                    console.error("Music play failed:", e);
                    isMusicPlaying = false;
                    musicButton.textContent = '🎵 Music: OFF';
                    musicButton.style.backgroundColor = '#777';
                });
            }
        } else {
            // Pause music
            bgMusic.pause();
            musicButton.textContent = '🎵 Music: OFF';
            musicButton.style.backgroundColor = '#777';
        }
    });
    
    // Add to DOM
    musicControl.appendChild(musicButton);
    document.getElementById('gameContainer').appendChild(musicControl);
    
    // Try initial auto-play (will likely be blocked, but try anyway)
    bgMusic.play().then(() => {
        isMusicPlaying = true;
        console.log("Auto-play successful");
    }).catch(e => {
        console.log("Auto-play prevented (normal browser behavior):", e);
        isMusicPlaying = false;
        musicButton.textContent = '🎵 Music: OFF';
        musicButton.style.backgroundColor = '#777';
    });
    
    console.log("Music setup complete");
}

// Set a timer to add music after game fully loads
// This ensures the gameContainer exists
setTimeout(() => {
    if (document.getElementById('gameContainer')) {
        setupGameMusic();
    } else {
        // If game container doesn't exist yet, try on login success
        socket.on('join_success', () => {
            setTimeout(setupGameMusic, 1000);
        });
    }
}, 1000);

// Enable browser audio context on first user interaction (required by browsers)
document.addEventListener('click', function enableAudio() {
    // Create and destroy an audio context to enable audio
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    audioContext.resume().then(() => {
        console.log("AudioContext enabled by user interaction");
    });
    // Remove this listener after first click
    document.removeEventListener('click', enableAudio);
}, { once: true });
    </script>
     <div style="position: fixed; bottom: 5px; right: 5px; font-size: 12px; opacity: 0.5;">
        <a href="/admin" >Admin</a>
    </div>
    
</body>
</html>