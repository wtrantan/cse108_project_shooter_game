<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat and Chill</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #87CEEB;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: none;
        }
        #loginContainer, #registerContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 300px;
        }
        #registerContainer {
            display: none;
        }
        #gameCanvas {
            background-color: #87CEEB;
        }
        #chatBox {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            max-width: 400px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        #chatMessages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
        }
        #chatInput {
            width: calc(100% - 70px);
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        .leaderboard {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 200px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 5px;
    padding: 10px;
    z-index: 100;
}

.leaderboard h3 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 10px;
    color: #FFD700;
    font-size: 16px;
}

.playerRank {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
    padding: 3px 5px;
    border-radius: 3px;
}

.playerRank.self {
    background-color: rgba(255, 215, 0, 0.3);
    font-weight: bold;
}

.colorPicker {
    position: absolute;
    top: 210px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    z-index: 99;
}
.ammoDisplay {
    position: absolute;
    top: 50px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}
        .scoreDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            font-weight: bold;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
        }
        .input-group input {
            width: 100%;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button.secondary {
            background-color: #777;
        }
        button:hover {
            opacity: 0.9;
        }
        .error-message {
            color: #f44336;
            margin: 10px 0;
            font-size: 14px;
        }
        .playerName {
            position: absolute;
            text-align: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
        }
        .baitDisplay {
    position: absolute;
    top: 90px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    font-weight: bold;
}
#settingsMenu {
            position: absolute;
            top: 250px; /* Adjusted top position */
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            z-index: 100;
            width: 250px;
            display: none; /* Initially hidden */
        }

        #settingsMenu h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #333;
        }

        #settingsMenu .setting-group {
            margin-bottom: 15px;
        }

        #settingsMenu .setting-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 0.9em;
        }

        #settingsMenu .setting-group input[type="color"] {
            width: 100%;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        #settingsMenu .setting-group button {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
            width: 100%;
            text-align: center;
        }

        #settingsMenu .setting-group button:hover {
            background-color: #45a049;
        }

        #settingsMenu hr {
            margin: 10px 0;
            border: 0;
            border-top: 1px solid #ddd;
        }

        #settingsMenu .setting-group button.secondary {
            background-color: #777;
        }

        #settingsMenu .setting-group button.secondary:hover {
            background-color: #666;
        }

        #settingsMenu .setting-group button.danger {
            background-color: #f44336;
            color: white;
        }

        #settingsMenu .setting-group button.danger:hover {
            background-color: #d32f2f;
        }
        #settingsToggleButton {
    position: fixed; /* Changed from absolute to fixed for better positioning */
    top: 10px; /* Fixed the invalid space between 10 and px */
    right: 230px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    z-index: 1001; /* Increased z-index to be extra safe */
    color: #000;
    cursor: pointer;
    display: block; /* Explicit display property for Firefox */
    min-width: 70px; /* Ensure minimum width */
    text-align: center; /* Center the text */
    font-weight: bold; /* Make text more visible */
    font-size: 14px; /* Ensure readable text size */
    user-select: none; /* Prevent text selection when clicking */
}

/* Add media queries for responsive design at different zoom levels */
@media screen and (max-width: 1200px) {
    #settingsToggleButton {
        right: 200px;
    }
}

@media screen and (max-width: 900px) {
    #settingsToggleButton {
        right: 170px;
    }
}

@media screen and (max-width: 600px) {
    #settingsToggleButton {
        right: 120px;
        top: 50px; /* Move down a bit on very small screens */
    }
}
        /* Basic modal styling (you can customize this) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 300px; /* Could be more or less, depending on screen size */
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loginContainer">
        <h2>Welcome to Chat and Chill!</h2>
        <div class="input-group">
            <label for="loginUsername">Username:</label>
            <input type="text" id="loginUsername" placeholder="Username">
        </div>
        <div class="input-group">
            <label for="loginPassword">Password:</label>
            <input type="password" id="loginPassword" placeholder="Password">
        </div>
        <div class="error-message" id="loginError"></div>
        <button id="loginButton">Login</button>
        <p>Don't have an account? <a href="#" id="showRegisterLink">Register</a></p>
    </div>
    
    <div id="registerContainer">
        <h2>Create Account</h2>
        <div class="input-group">
            <label for="registerUsername">Username:</label>
            <input type="text" id="registerUsername" placeholder="Username (min 3 characters)">
        </div>
        <div class="input-group">
            <label for="registerPassword">Password:</label>
            <input type="password" id="registerPassword" placeholder="Password (min 4 characters)">
        </div>
        <div class="input-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" placeholder="Confirm Password">
        </div>
        <div class="error-message" id="registerError"></div>
        <button id="registerButton">Register</button>
        <p>Already have an account? <a href="#" id="showLoginLink">Login</a></p>
    </div>
    
    <div id="gameContainer">

<div id="instructionsCard" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1000; width: 400px; max-width: 90vw; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); font-family: Arial, sans-serif;">
    <h2 style="text-align: center; color: #FFD700; margin-top: 0;">Welcome to Chat and Chill!</h2>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #4CAF50; margin-bottom: 5px;">Movement</h3>
        <p>Use <b>WASD</b> or <b>Arrow Keys</b> to move your character</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #2196F3; margin-bottom: 5px;">Combat</h3>
        <p>Press <b>Spacebar</b> to shoot snowballs</p>
        <p>Collect snowballs to reload</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #FFC107; margin-bottom: 5px;">Fishing</h3>
        <p>Collect Bait to start fishing</p>
        <p>Stand in a pond and press <b>F</b> to throw your fishing rod</p>
        <p>When the bobber dips underwater, <b>Click</b> to hook the fish.</p>
        <p>Then, <b>Click</b> again when the indicator is in the green zone to catch it</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #9C27B0; margin-bottom: 5px;">Inventory</h3>
        <p>Press <b>E</b> to open your fish inventory</p>
    </div>
    <div style="margin-bottom: 15px;">
        <h3 style="color: #FF5722; margin-bottom: 5px;">Scoring</h3>
        <p>Collect coins to increase your score</p>
        <p>Shooting other players increases your score</p>
    </div>
    <div style="text-align: center; margin-top: 20px;">
        <button id="closeInstructionsButton" style="background-color: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">Got it!</button>
    </div>
</div>

        <canvas id="gameCanvas"></canvas>
        <div class="scoreDisplay" id="scoreDisplay">Score: 0</div>
        <div class="ammoDisplay" id="ammoDisplay">Ammo: 30/50</div>
        <div class="baitDisplay" id="baitDisplay">Bait: 5/10</div>
        <button id="settingsToggleButton">Settings</button>
        <div id="settingsMenu">
            <h2>Settings</h2>
            <div class="setting-group">
                <label>Change your color:</label>
                <input type="color" id="colorPicker" value="#FF0000">
                <button id="applyColorButton">Apply</button>
            </div>
            <hr>
            <button id="change-username-btn">Change Username</button>
            <button id="change-password-btn">Change Password</button>
            <div class="setting-group">
                <button id="logoutButton" class="secondary">Log Out</button>
            </div>
            <div class="setting-group">
                <button id="deleteAccountButton" class="danger">Delete Account</button>
            </div>
        </div>
        <div id="change-password-modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h3>Change Password</h3>
                <input type="password" id="current-password-change" placeholder="Current Password">
                <input type="password" id="new-password-change" placeholder="New Password">
                <button id="save-password-btn">Save Password</button>
            </div>
        </div>
        
        <div id="change-username-modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h3>Change Username</h3>
                <input type="password" id="current-password-username" placeholder="Current Password">
                <input type="text" id="new-username" placeholder="New Username">
                <button id="save-username-btn">Save Username</button>
            </div>
        </div>
        <div class="minimap" id="minimap"></div>
        <div id="chatBox">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <button id="toggleChatButton">Hide Chat</button>
                <span style="font-weight: bold;">Chat</span>
            </div>
            <div id="chatMessages"></div>
            <div>
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button id="sendButton">Send</button>
            </div>
        </div>
        <div class="leaderboard">
            <h3>Leaderboard</h3>
            <div id="leaderboardContent"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
    <script>
        // Connect to the server
        const socket = io();
        let chatInputFocused = false;
        // Game variables
        let canvas, ctx;
        let username = "";
        let userColor = "#FF0000";
        let players = {};
        const soundEffectCooldowns = {
    'coin-sound.mp3': 0,
    'ammo-sound.mp3': 0,
    'bait2.mp3': 0,
    'gun.mp3': 0,
    'catch.mp3': 0,
    'missedFish.mp3': 0,
    'splash.mp3': 0,
    'trashcan.mp3': 0
};
const playerSpriteSheet = new Image();
playerSpriteSheet.src = '/penguin_player.png'; // Create this image with your 20 frames

// Get the settings button and menu elements
const settingsToggleButton = document.getElementById('settingsToggleButton');
        const settingsMenu = document.getElementById('settingsMenu');
        const changePasswordBtn = document.getElementById('change-password-btn');
const changeUsernameBtn = document.getElementById('change-username-btn');
const changePasswordModal = document.getElementById('change-password-modal');
const changeUsernameModal = document.getElementById('change-username-modal');
const savePasswordBtn = document.getElementById('save-password-btn');
const saveUsernameBtn = document.getElementById('save-username-btn');

const closePasswordModal = document.querySelectorAll('#change-password-modal .close');
const closeUsernameModal = document.querySelectorAll('#change-username-modal .close');
const modalInputs = [
    document.getElementById('current-password-change'),
    document.getElementById('new-password-change'),
    document.getElementById('current-password-username'),
    document.getElementById('new-username')
];
modalInputs.forEach(input => {
    input.addEventListener('focus', () => {
        modalInputFocused = true;
        
        // Reset key states when focusing modal inputs
        keys.up = false;
        keys.down = false;
        keys.left = false;
        keys.right = false;
    });
    
    input.addEventListener('blur', () => {
        modalInputFocused = false;
    });
});
changePasswordBtn.addEventListener('click', () => {
    changePasswordModal.style.display = 'block';
});

changeUsernameBtn.addEventListener('click', () => {
    changeUsernameModal.style.display = 'block';
});

closePasswordModal.forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        changePasswordModal.style.display = 'none';
    });
});

closeUsernameModal.forEach(closeBtn => {
    closeBtn.addEventListener('click', () => {
        changeUsernameModal.style.display = 'none';
    });
});

window.addEventListener('click', (event) => {
    if (event.target === changePasswordModal) {
        changePasswordModal.style.display = 'none';
    }
    if (event.target === changeUsernameModal) {
        changeUsernameModal.style.display = 'none';
    }
});

savePasswordBtn.addEventListener('click', async () => {
    const currentPassword = document.getElementById('current-password-change').value;
    const newPassword = document.getElementById('new-password-change').value;

    const response = await fetch('/api/change-password', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ currentPassword, newPassword, username })
    });

    const data = await response.json();

    if (response.ok) {
        alert(data.message);
        changePasswordModal.style.display = 'none';
        window.location.reload();
    } else {
        alert(data.error);
    }
});

saveUsernameBtn.addEventListener('click', async () => {
    const currentPassword = document.getElementById('current-password-username').value;
    const newUsername = document.getElementById('new-username').value;

    const response = await fetch('/api/change-username', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ currentPassword, newUsername, username })
    });

    const data = await response.json();

    if (response.ok) {
        alert(data.message);
        localStorage.setItem('username', newUsername);  // Update local storage
        username = newUsername; // Update the username variable
        changeUsernameModal.style.display = 'none';
        window.location.reload();
    } else {
        alert(data.error);
    }
});
        // Add a click event listener to the settings button
        settingsToggleButton.addEventListener('click', () => {
            // Toggle the display of the settings menu
            if (settingsMenu.style.display === 'none') {
                settingsMenu.style.display = 'block';
            } else {
                settingsMenu.style.display = 'none';
            }
        });

let isMusicMuted = false;
        const SOUND_COOLDOWN = 300; // Adjust this value as needed
        let fishInventory = []; // Array to store caught fish
        let isInventoryOpen = false;
        let isFishing = false;
        let fishingProgress = 0;
        let fishingSuccess = false;
        let fishingResult = null;
        let fishingTimeout = null;
        let isFishingCast = false;    // New state for "rod is cast but waiting for bite"
let fishingBobber = null;     // Track the bobber position and state
let fishingBiteTimeout = null; // Timeout for when fish will bite
let fishingFailTimeout = null; // Timeout for when fishing fails if no click
let lastPondClicked = null;   // Remember which pond we're fishing in
        let myId = null;
        let playerScore = 0;
        let gameObjects = {
            trees: [],
            rocks: [],
            coins: [],
            ammoPacks: [],
            baitPacks: [],
            ponds: [],
            decorativeLakes: [] 
        };
        let currentBait = 5; // Start with 5 bait
        const MAX_BAIT = 10; // Maximum bait capacity
        const BAIT_PACK_SIZE = 1; // Amount of bait in each pack
        const BAIT_PACK_SIZE_DISPLAY = 60; // Visual size of bait packs
        let currentAmmo = 5; // Start with 30 bullets
        const MAX_AMMO = 10; // Maximum ammo capacity
        const AMMO_PACK_SIZE = 5; // Amount of ammo in each pack
        const AMMO_PACK_SIZE_DISPLAY = 70; // Visual size of ammo packs
        let bullets = [];
        let mouseX = 0;
        let mouseY = 0;
        let keys = {
    up: false,
    down: false,
    left: false,
    right: false
};
let lastLeaderboardUpdate = 0;
const LEADERBOARD_UPDATE_INTERVAL = 250; // Only update every 250ms max
const inputBuffer = [];
const MAX_BUFFER_SIZE = 10;
const positionBuffer = [];
let lastInputTime = 0;
const INPUT_SEND_INTERVAL = 50; // ms
let lastMovementUpdate = 0;
const MOVEMENT_UPDATE_INTERVAL = 33; // Send position updates at most every 33ms (~30 updates/sec)
let lastUpdateTime = 0; 
let modalInputFocused = false;
    const BULLET_SPEED = 10;
    const BULLET_SIZE = 8;
    const BULLET_COOLDOWN = 500; // Cooldown in milliseconds
    let lastShotTime = 0;
        // Game constants
        const PLAYER_SPEED = 7;
        const PLAYER_SIZE = 50;
        const COIN_SIZE = 20;
        let deleteButtonPositions = [];
        // Game assets preloading
        const playerSprite = new Image();
        playerSprite.src = '/player-penguin.png';
        const baitPackSprite = new Image();
baitPackSprite.src = '/worm.png'; // Create this image or use a placeholder    
        const pondSprite = new Image();
        pondSprite.src = '/'; // Create this image or use a placeholder
//         const fishingRodSprite = new Image();
// fishingRodSprite.src = '/fishing-rod.png'; // Create this image or use a placeholder
        const treeSprite = new Image();

        const fishSprites = {};
for (let i = 1; i <= 16; i++) {
    fishSprites[`fish${i}`] = new Image();
    fishSprites[`fish${i}`].src = `/fish${i}.png`; // Create these images or use placeholders
}
        treeSprite.src = '/pine_tree_Show.png'; // Create this image or use a placeholder
        
        const rockSprite = new Image();
        rockSprite.src = '/Snow_rocks.png'; // Create this image or use a placeholder
        
        const coinSprite = new Image();
        coinSprite.src = '/coin.png'; // Create this image or use a placeholder
        
        const ammoPackSprite = new Image();
        ammoPackSprite.src = '/Snowball2.png'; // Create this image or use a placeholder
        // Camera tracking
        let cameraX = 0;
        let cameraY = 0;
        const WORLD_WIDTH = 4000;  // Increased from 2000
        const WORLD_HEIGHT = 3000; // Increased from 1500
        
        // DOM elements
        const loginContainer = document.getElementById('loginContainer');
        const registerContainer = document.getElementById('registerContainer');
        const gameContainer = document.getElementById('gameContainer');
        const loginError = document.getElementById('loginError');
        const registerError = document.getElementById('registerError');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        // Show/hide auth forms
        document.getElementById('showRegisterLink').addEventListener('click', (e) => {
            e.preventDefault();
            loginContainer.style.display = 'none';
            registerContainer.style.display = 'block';
        });
        
        document.getElementById('showLoginLink').addEventListener('click', (e) => {
            e.preventDefault();
            registerContainer.style.display = 'none';
            loginContainer.style.display = 'block';
        });
        
        // Register handling
        document.getElementById('registerButton').addEventListener('click', register);
        
        async function register() {
            const usernameInput = document.getElementById('registerUsername');
            const passwordInput = document.getElementById('registerPassword');
            const confirmPasswordInput = document.getElementById('confirmPassword');
            
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            const confirmPassword = confirmPasswordInput.value;
            
            // Reset error message
            registerError.textContent = '';
            
            // Validate inputs
            if (username.length < 3) {
                registerError.textContent = 'Username must be at least 3 characters long';
                return;
            }
            
            if (password.length < 4) {
                registerError.textContent = 'Password must be at least 4 characters long';
                return;
            }
            
            if (password !== confirmPassword) {
                registerError.textContent = 'Passwords do not match';
                return;
            }
            
            try {
                // Send register request to server
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    registerError.textContent = data.error || 'Registration failed';
                    return;
                }
                
                // Set color from server
                userColor = data.color;
                
                // Show login form
                registerContainer.style.display = 'none';
                loginContainer.style.display = 'block';
                loginError.textContent = 'Registration successful! Please login.';
                
                // Pre-fill username
                document.getElementById('loginUsername').value = username;
            } catch (error) {
                console.error('Registration error:', error);
                registerError.textContent = 'Server error. Please try again later.';
            }
        }
        function toggleChat() {
    const chatBox = document.getElementById('chatBox');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const toggleButton = document.getElementById('toggleChatButton');
    
    if (chatMessages.style.display === 'none') {
        // Show chat
        chatMessages.style.display = 'block';
        chatInput.style.display = 'inline-block';
        document.getElementById('sendButton').style.display = 'inline-block';
        toggleButton.textContent = 'Hide Chat';
    } else {
        // Hide chat
        chatMessages.style.display = 'none';
        chatInput.style.display = 'none';
        document.getElementById('sendButton').style.display = 'none';
        toggleButton.textContent = 'Show Chat';
    }
}

        // Login handling
        document.getElementById('loginButton').addEventListener('click', login);
        document.getElementById('loginUsername').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('loginPassword').focus();
            }
        });
        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') login();
        });
        
        async function login() {
            const usernameInput = document.getElementById('loginUsername');
            const passwordInput = document.getElementById('loginPassword');
            
            username = usernameInput.value.trim();
            const password = passwordInput.value;
            
            // Reset error message
            loginError.textContent = '';
            
            // Validate inputs
            if (!username || !password) {
                loginError.textContent = 'Username and password are required';
                return;
            }
            
            try {
                // Send login request to server
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    loginError.textContent = data.error || 'Login failed';
                    return;
                }
                
                // Set user data from database
                userColor = data.color;
                playerScore = data.score || 0;
                document.getElementById('colorPicker').value = userColor;
                
                // Update score display
                scoreDisplay.textContent = `Score: ${playerScore}`;
                
                // Join the game using socket
                socket.emit('join_game', {
                    username: username,
                    color: userColor
                });
                
                // Wait for server confirmation
                socket.once('join_success', (playerId) => {
                    myId = playerId;
                    
                    // Hide login and show game
                    loginContainer.style.display = 'none';
                    gameContainer.style.display = 'block';
                    
                    // Initialize the game
                    initGame();
                });
            } catch (error) {
                console.error('Login error:', error);
                loginError.textContent = 'Server error. Please try again later.';
            }
        }
        
        // Initialize the game after successful login
        function initGame() {
            // Set up the canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to window size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
              addInstructionsButton();
             // Add unstuck button to the game UI
    const unstuckButton = document.createElement('button');
    unstuckButton.textContent = '🔄 Unstuck';
    unstuckButton.style.position = 'absolute';
    unstuckButton.style.bottom = '170px';
    unstuckButton.style.right = '10px';
    unstuckButton.style.backgroundColor = '#FF9800';
    unstuckButton.style.color = 'white';
    unstuckButton.style.border = 'none';
    unstuckButton.style.borderRadius = '5px';
    unstuckButton.style.padding = '8px 15px';
    unstuckButton.style.cursor = 'pointer';
    unstuckButton.style.zIndex = '1000';
    unstuckButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    
    // Add cooldown tracking
    let lastUnstuckTime = 0;
    const unstuckCooldown = 10000; // 10 seconds cooldown
    
    unstuckButton.addEventListener('click', function() {
        const currentTime = Date.now();
        
        // Check for cooldown
        if (currentTime - lastUnstuckTime < unstuckCooldown) {
            const remainingCooldown = Math.ceil((unstuckCooldown - (currentTime - lastUnstuckTime)) / 1000);
            addChatMessage('System', `Unstuck on cooldown. Please wait ${remainingCooldown} seconds.`);
            return;
        }
        
        // Request unstuck from server
        socket.emit('request_unstuck');
        lastUnstuckTime = currentTime;
        
        // Visual feedback that request was sent
        unstuckButton.disabled = true;
        unstuckButton.textContent = '⏳ Processing...';
        unstuckButton.style.backgroundColor = '#999';
        
        // Reset button after cooldown
        setTimeout(() => {
            unstuckButton.disabled = false;
            unstuckButton.textContent = '🔄 Unstuck';
            unstuckButton.style.backgroundColor = '#FF9800';
        }, unstuckCooldown);
        
        // Notify the player
        addChatMessage('System', "Attempting to unstuck you... Please wait.");
    });
    
    document.getElementById('gameContainer').appendChild(unstuckButton);
            // Set up chat functionality
            document.getElementById('sendButton').addEventListener('click', sendMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
            document.getElementById('chatInput').addEventListener('focus', () => {
    chatInputFocused = true;
    
    // Reset key states when focusing the chat input
    keys.up = false;
    keys.down = false;
    keys.left = false;
    keys.right = false;
});

document.getElementById('chatInput').addEventListener('blur', () => {
    chatInputFocused = false;
});

// Set up toggle chat button
document.getElementById('toggleChatButton').addEventListener('click', toggleChat);
            // Set up color picker
            document.getElementById('applyColorButton').addEventListener('click', changeColor);
            
            // Set up movement controls
            
// Add click handler for fishing
document.addEventListener('keydown', (e) => {
    // Check if the 'F' key was pressed (case-insensitive)
    if (e.key.toLowerCase() === 'f') {
         if (isPlayerInWater() && currentBait > 0) {
                castFishingRod();
            } else if (!isPlayerInWater()) {
                addChatMessage('System', "You need to be at a fishing spot!");
            } else if (currentBait <= 0) {
                addChatMessage('System', "You need bait to fish!");
                showBaitWarning();
            }
    }
});

canvas.addEventListener('click', function(e) {
    // Get click coordinates
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // CASE 1: Handle bobber clicks when casting
     if (isFishingCast && fishingBobber && fishingBobber.state === 'biting') {
        // Clear timeouts
        clearTimeout(fishingBiteTimeout);
        clearTimeout(fishingFailTimeout);
        
        // Transition to the actual fishing minigame
        isFishingCast = false;
        startFishing();
        
        // IMPORTANT: Stop event from being processed further
        return;
    }
     
    // CASE 2: Handle early clicks on bobber when fish is not yet biting
    if (isFishingCast && fishingBobber && fishingBobber.state === 'waiting') {
    // Any click while waiting for fish to bite will scare the fish away
    playSound('splash.mp3', 0.5);
    
    // Add ripples to show disturbance
    for (let i = 0; i < 4; i++) {
        fishingBobber.ripples.push({
            radius: 3 + i * 2,
            opacity: 0.8
        });
    }
    
    // Show message
    addChatMessage('System', "You scared the fish away by clicking too early!");
    
    // Clear any pending timeouts
    if (fishingBiteTimeout) {
        clearTimeout(fishingBiteTimeout);
    }
    
    // Reset fishing after a short delay to show the ripples
    setTimeout(() => {
        resetFishing();
    }, 1000);
    
    // IMPORTANT: Stop event from being processed further
    return;
}
    
    // CASE 3: Handle minigame clicks when fishing (only if we're in the minigame)
    else if (isFishing) {
        // Check if player clicked during the fishing minigame
        const progressBarWidth = 200;
        const progressBarHeight = 30;
        const progressBarX = (canvas.width - progressBarWidth) / 2;
        const progressBarY = canvas.height - 100;
        
        // Calculate the success zone position
        const successZoneWidth = progressBarWidth * 0.3;
        const timeOffset = Math.floor(Date.now() / 3000);
        const successZonePosition = ((Math.sin(timeOffset) + 1) / 2) * (progressBarWidth - successZoneWidth);
        const successZoneStart = progressBarX + successZonePosition;
        
        // Calculate current indicator position
        const indicatorPos = progressBarX + progressBarWidth * fishingProgress;
        
        // Check if indicator is in success zone
        const inSuccessZone = 
            indicatorPos >= successZoneStart && 
            indicatorPos <= successZoneStart + successZoneWidth;
        
        // Handle fishing success or failure
        if (inSuccessZone) {
            // Success! Player clicked in the green zone
            catchFish(true);
        } else {
            // Failed - player clicked outside the green zone
            catchFish(false);
        }
        
        // IMPORTANT: Stop event from being processed further
        return;
    }
    
    // Other click handlers can go here (if needed)
});
// Add 'E' key handler for fish inventory
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && !chatInputFocused) {
        toggleFishInventory();
    }
});
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('mousemove', (e) => {
            // Get mouse position relative to canvas
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateLeaderboard();
            });
           
// Add spacebar shooting in handleKeyDown function, or as a separate event listener:
         window.addEventListener('keydown', (e) => {
            
            if (e.code === 'Space' || e.key === ' ') {
            // Check if player has ammo
           shootBullet();
        }
        });
        updateAmmoDisplay();
        updateBaitDisplay();
        setupSocketHandlers();
            // Set up minimap
            setupMinimap();
            
            // Start the game loop
            requestAnimationFrame(gameLoop);
            
            // Listen for server updates
            socket.on('game_state', (gameState) => {
                let prevPosition = null;
    if (myId && players[myId]) {
        prevPosition = {
            x: players[myId].x,
            y: players[myId].y
        };
    }
                players = gameState.players;
    for (const id in players) {
    // Initialize animation properties if they don't exist
        if (!players[id].direction) players[id].direction = 'down';
        if (players[id].isMoving === undefined) players[id].isMoving = false;
        if (players[id].animFrame === undefined) players[id].animFrame = 0;
        if (players[id].animTimer === undefined) players[id].animTimer = 0;
    }

                if (prevPosition && myId && players[myId]) {
        const serverPos = players[myId];
        const distX = serverPos.x - prevPosition.x;
        const distY = serverPos.y - prevPosition.y;
        const distance = Math.sqrt(distX * distX + distY * distY);
        
        // Only reconcile if server and client positions differ significantly
        if (distance > 10) {
            // Smoothly move to the correct position over a few frames
            const reconciliationSpeed = 0.3; // Adjust as needed
            players[myId].x = prevPosition.x + distX * reconciliationSpeed;
            players[myId].y = prevPosition.y + distY * reconciliationSpeed;
        }
    }
                // Update game objects if available
                if (gameState.gameObjects) {
                    gameObjects = gameState.gameObjects;
                }
                
                // Update score display if this player's score changed
                if (myId && players[myId]) {
                    if (playerScore !== players[myId].score) {
                        playerScore = players[myId].score;
                        scoreDisplay.textContent = `Score: ${playerScore}`;
                        if (currentAmmo !== players[myId].ammo) {
                     currentAmmo = players[myId].ammo;
                updateAmmoDisplay();
                 }
                    }
                }
                socket.on('bullets_update', (serverBullets) => {
                // Add any new bullets from server that aren't in our local array
                for (const serverBullet of serverBullets) {
             if (!bullets.some(b => b.id === serverBullet.id)) {
                   bullets.push(serverBullet);
            }
        }
   
});
socket.on('fish_deleted', (data) => {
    if (data.success) {
        // Server confirmed deletion, show notification
        //addChatMessage('System', `${data.fishName} has been removed from your inventory.`);
          fishInventory = fishInventory.filter(fish => fish.id !== data.fishId);
        // Request updated inventory to ensure client and server are in sync
          drawFishInventory();
        socket.emit('get_fish_inventory');
    } else {
        // Handle errors
      //  addChatMessage('System', 'Failed to remove fish: ' + (data.error || 'Unknown error'));
          // Reset deletion state to allow further attempts
        isDeletingFish = false;
        
        // Process next pending deletion if any
        if (pendingDeletions.length > 0) {
            setTimeout(() => {
                const nextFishId = pendingDeletions.shift();
                deleteFish(nextFishId);
            }, 500);
        }
    }
});
    socket.on('ammo_update', (data) => {
    currentAmmo = data.ammo;
    updateAmmoDisplay();
    });
    socket.on('bait_update', (data) => {
    currentBait = data.bait;
    updateBaitDisplay();
});
   // Modify the socket.on('player_hit') handler to update scores immediately
socket.on('player_hit', (data) => {
    const { playerId, shooterId, damage } = data;
    
    // If this is the player being hit
    if (playerId === myId) {
        // Flash the screen red for feedback
        flashScreen('rgba(255,0,0,0.3)');
        
        // Immediately update score on hit (prevent negative scores)
        playerScore = Math.max(0, playerScore - damage);
        scoreDisplay.textContent = `Score: ${playerScore}`;
        
        // Update the player's score in our local model
        if (players[myId]) {
            players[myId].score = playerScore;
        }
    }
    
    // If this is the player who shot
    if (shooterId === myId) {
        // Play hit confirmation sound
        playHitConfirmSound();
        
        // Immediately update score for shooter
        playerScore = playerScore + damage;
        scoreDisplay.textContent = `Score: ${playerScore}`;
        
        // Update the player's score in our local model
        if (players[myId]) {
            players[myId].score = playerScore;
        }
    }
    
    // Also update scores in the players object for both shooter and hit player
    // This ensures consistency with local score and leaderboard
    if (players[playerId]) {
        players[playerId].score = Math.max(0, players[playerId].score - damage);
    }
    
    if (players[shooterId]) {
        players[shooterId].score += damage;
    }
    
    // Update the leaderboard with these new scores
    updateLeaderboard();
});

// Add this to handle the players_update event more efficiently
socket.on('players_update', (updatedPlayers) => {
    // Update only the specific players that changed
    for (const id in updatedPlayers) {
        if (players[id]) {
            players[id] = {...players[id], ...updatedPlayers[id]};
        }
    }
    
    // Update score display if current player was updated by server
    // (this ensures client stays in sync with authoritative server)
    if (myId && updatedPlayers[myId] && updatedPlayers[myId].score !== undefined) {
        // Only update if server value differs from local value
        if (playerScore !== updatedPlayers[myId].score) {
            playerScore = updatedPlayers[myId].score;
            scoreDisplay.textContent = `Score: ${playerScore}`;
        }
    }
    
    // Update leaderboard
    updateLeaderboard();
});
                // Update minimap
                updateMinimap();
            });
            
            socket.on('chat_message', (data) => {
                addChatMessage(data.username, data.message);
            });
        }
        socket.on('fish_caught', (fishData) => {
    // Add the fish to inventory
    fishInventory.push(fishData);
    
    // Show notification
   // addChatMessage('System', `You caught a ${fishData.rarity} ${fishData.name} (${fishData.size} cm)!`);
    
    // Sort inventory by rarity and size
    fishInventory.sort((a, b) => {
        const rarityOrder = { 'Common': 0, 'Uncommon': 1, 'Rare': 2, 'Epic': 3, 'Legendary': 4, 'Mythical': 5 };
        return rarityOrder[b.rarity] - rarityOrder[a.rarity] || b.size - a.size;
    });
});

socket.on('fish_inventory', (inventory) => {
    fishInventory = inventory;
});
        // Set up logout and delete account buttons
document.getElementById('logoutButton').addEventListener('click', handleLogout);
document.getElementById('deleteAccountButton').addEventListener('click', confirmDeleteAccount);

// Logout function
function handleLogout() {
    // Disconnect from the socket
    socket.disconnect();
    
    // Hide game container and show login form
    gameContainer.style.display = 'none';
    loginContainer.style.display = 'block';
    
    // Clear password field
    document.getElementById('loginPassword').value = '';
    
    // Optional: Show a message to the user
    loginError.textContent = 'You have been logged out successfully.';
    loginError.style.color = 'green';
}

// Delete account confirmation
function confirmDeleteAccount() {
    if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
        // Call the delete account API
        deleteAccount();
    }
}

// Delete account function
async function deleteAccount() {
    try {
        // Send delete request to server
        const response = await fetch('/api/delete-account', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ username: username })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            alert(`Failed to delete account: ${data.error}`);
            return;
        }
        
        // Disconnect socket
        socket.disconnect();
        
        // Show login screen
        gameContainer.style.display = 'none';
        loginContainer.style.display = 'block';
        
        // Show success message
        loginError.textContent = 'Your account has been deleted successfully.';
        loginError.style.color = 'green';
        
        // Clear fields
        document.getElementById('loginUsername').value = '';
        document.getElementById('loginPassword').value = '';
        
    } catch (error) {
        console.error('Delete account error:', error);
        alert('Server error. Please try again later.');
    }
}

        function setupMinimap() {
            const minimap = document.getElementById('minimap');
            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
            minimap.appendChild(minimapCanvas);
        }
        
        function updateMinimap() {
            const minimap = document.querySelector('#minimap canvas');
            const minimapCtx = minimap.getContext('2d');
            const minimapWidth = minimap.width;
            const minimapHeight = minimap.height;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw world boundary
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.strokeRect(0, 0, minimapWidth, minimapHeight);
            
            // Draw trees as green dots
            minimapCtx.fillStyle = '#0a5';
            gameObjects.trees.forEach(tree => {
                minimapCtx.fillRect(
                    (tree.x / WORLD_WIDTH) * minimapWidth,
                    (tree.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
            });
//frozen lakes
    minimapCtx.fillStyle = '#B8E3FF';
    gameObjects.decorativeLakes.forEach(lake => {
        const centerX = (lake.x / WORLD_WIDTH) * minimapWidth + ((lake.width / WORLD_WIDTH) * minimapWidth) / 2;
        const centerY = (lake.y / WORLD_HEIGHT) * minimapHeight + ((lake.height / WORLD_HEIGHT) * minimapHeight) / 2;
        const radiusX = ((lake.width / WORLD_WIDTH) * minimapWidth) / 2;
        const radiusY = ((lake.height / WORLD_HEIGHT) * minimapHeight) / 2;
        
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.fill();
    });
    
    // Draw fishable ponds as darker blue (so they're distinguishable)
     minimapCtx.fillStyle = '#4FC3F7';
    gameObjects.ponds.forEach(pond => {
        const centerX = (pond.x / WORLD_WIDTH) * minimapWidth + ((pond.width / WORLD_WIDTH) * minimapWidth) / 2;
        const centerY = (pond.y / WORLD_HEIGHT) * minimapHeight + ((pond.height / WORLD_HEIGHT) * minimapHeight) / 2;
        const radiusX = ((pond.width / WORLD_WIDTH) * minimapWidth) / 2;
        const radiusY = ((pond.height / WORLD_HEIGHT) * minimapHeight) / 2;
        
        // Draw pond
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.fill();
        
        // Add border for visibility
        minimapCtx.strokeStyle = '#0277BD';
        minimapCtx.beginPath();
        minimapCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
        minimapCtx.stroke();
    });
            // Draw rocks as gray dots
            minimapCtx.fillStyle = '#777';
            gameObjects.rocks.forEach(rock => {
                minimapCtx.fillRect(
                    (rock.x / WORLD_WIDTH) * minimapWidth,
                    (rock.y / WORLD_HEIGHT) * minimapHeight,
                    2, 2
                );
            });
            
            // Draw coins as yellow dots
            minimapCtx.fillStyle = '#ff0';
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    minimapCtx.fillRect(
                        (coin.x / WORLD_WIDTH) * minimapWidth,
                        (coin.y / WORLD_HEIGHT) * minimapHeight,
                        3, 3
                    );
                }
            });
            //draw ammo packs as blue dots
            minimapCtx.fillStyle = '#00f';
            gameObjects.ammoPacks.forEach(ammoPack => {
             if (!ammoPack.collected) {
                minimapCtx.fillRect(
                    (ammoPack.x / WORLD_WIDTH) * minimapWidth,
                    (ammoPack.y / WORLD_HEIGHT) * minimapHeight,
                    3, 3
                );
             }
        });
          // Draw bait packs as brown dots
    minimapCtx.fillStyle = '#8B4513';
    gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected) {
            minimapCtx.fillRect(
                (baitPack.x / WORLD_WIDTH) * minimapWidth,
                (baitPack.y / WORLD_HEIGHT) * minimapHeight,
                3, 3
            );
        }
    });
            // Draw players
             Object.values(players).forEach(player => {
        // Find if this player has an active interpolation
        const movingPlayer = positionBuffer.find(move => move.id === player.id);
        let displayX = player.x;
        let displayY = player.y;
        
        // If player is currently being interpolated, use the interpolated position
        if (movingPlayer) {
            // Calculate interpolated position using the same logic as in gameLoop
            const progress = movingPlayer.progress;
            const t = 1 - Math.pow(1 - progress, 2); // Same easing function
            displayX = movingPlayer.fromX + (movingPlayer.toX - movingPlayer.fromX) * t;
            displayY = movingPlayer.fromY + (movingPlayer.toY - movingPlayer.fromY) * t;
        }
        
        minimapCtx.fillStyle = player.color || '#f00';
        minimapCtx.fillRect(
            (displayX / WORLD_WIDTH) * minimapWidth,
            (displayY / WORLD_HEIGHT) * minimapHeight,
            4, 4
        );
    });
            
            // Highlight current player
            if (myId && players[myId]) {
                const player = players[myId];
                minimapCtx.strokeStyle = '#fff';
                minimapCtx.strokeRect(
                    (player.x / WORLD_WIDTH) * minimapWidth - 2,
                    (player.y / WORLD_HEIGHT) * minimapHeight - 2,
                    8, 8
                );
                
                // Draw view rectangle
                minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                minimapCtx.strokeRect(
                    (cameraX / WORLD_WIDTH) * minimapWidth,
                    (cameraY / WORLD_HEIGHT) * minimapHeight,
                    (canvas.width / WORLD_WIDTH) * minimapWidth,
                    (canvas.height / WORLD_HEIGHT) * minimapHeight
                );
            }
        }
        
        function changeColor() {
            const colorPicker = document.getElementById('colorPicker');
            const newColor = colorPicker.value;
            
            // Update local color
            userColor = newColor;
            
            // Send to server
            socket.emit('change_color', { color: newColor });
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
     function handleKeyDown(e) {
    // If a chat or modal input is focused, don't process movement keys
    if ((chatInputFocused || modalInputFocused) && 
        ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' ', 'e', 'f'].includes(e.key)) {
        return;
    }
    
    const input = updateKeyState(e, true);
    if (input) addToInputBuffer(input);
}

function handleKeyUp(e) {
    // If a chat or modal input is focused, don't process movement keys
    if ((chatInputFocused || modalInputFocused) && 
        ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' ', 'e', 'f'].includes(e.key)) {
        return;
    }
    
    const input = updateKeyState(e, false);
    if (input) addToInputBuffer(input);
}

function updateKeyState(e, isPressed) {
    let input = null;
    switch(e.key) {
        case 'ArrowUp':
        case 'w':
            keys.up = isPressed;
            input = { type: 'move', key: 'up', pressed: isPressed };
            break;
        case 'ArrowDown':
        case 's':
            keys.down = isPressed;
            input = { type: 'move', key: 'down', pressed: isPressed };
            break;
        case 'ArrowLeft':
        case 'a':
            keys.left = isPressed;
            input = { type: 'move', key: 'left', pressed: isPressed };
            break;
        case 'ArrowRight':
        case 'd':
            keys.right = isPressed;
            input = { type: 'move', key: 'right', pressed: isPressed };
            break;
        case ' ': // Space
            if (isPressed) {
                shootBullet();
                input = { type: 'shoot' };
            }
            break;
    }
    
    return input;
}
function addToInputBuffer(input) {
    input.timestamp = Date.now();
    input.sequence = inputBuffer.length > 0 ? 
                    inputBuffer[inputBuffer.length - 1].sequence + 1 : 0;
    
    inputBuffer.push(input);
    
    // Keep buffer size limited
    if (inputBuffer.length > MAX_BUFFER_SIZE) {
        inputBuffer.shift();
    }
    
    // Process and send inputs
    processInputBuffer();
}
function processInputBuffer() {
    const now = Date.now();
    
    // Only send updates at a fixed interval
    if (now - lastInputTime >= INPUT_SEND_INTERVAL && inputBuffer.length > 0) {
        lastInputTime = now;
        
        // Send all buffered inputs at once
        socket.emit('player_inputs', inputBuffer);
        
        // Clear buffer after sending
        // inputBuffer.length = 0; // Uncomment if you want to clear after sending
    }
}
function updateLeaderboard() {
    const now = Date.now();
    
    // Throttle updates to avoid flickering
    if (now - lastLeaderboardUpdate < LEADERBOARD_UPDATE_INTERVAL) {
        return;
    }
    
    lastLeaderboardUpdate = now;
    
    const leaderboardContent = document.getElementById('leaderboardContent');
    if (!leaderboardContent) return;
    
    // Clear existing content
    leaderboardContent.innerHTML = '';
    
    // Get all players and ensure scores are valid numbers
    const playerList = Object.values(players).map(player => {
        // Ensure score is a valid number
        if (typeof player.score !== 'number' || isNaN(player.score)) {
            player = {...player, score: 0};
        }
        return player;
    }).sort((a, b) => b.score - a.score);
    
    // Add each player to the leaderboard
    playerList.forEach((player, index) => {
        const playerRow = document.createElement('div');
        playerRow.className = 'playerRank';
        
        // Highlight current player
        if (player.id === myId) {
            playerRow.classList.add('self');
        }
        
        // Add color indicator
        const colorIndicator = document.createElement('span');
        colorIndicator.style.display = 'inline-block';
        colorIndicator.style.width = '10px';
        colorIndicator.style.height = '10px';
        colorIndicator.style.backgroundColor = player.color;
        colorIndicator.style.marginRight = '5px';
        colorIndicator.style.borderRadius = '50%';
        
        // Create rank and name element
        const rankAndName = document.createElement('span');
        rankAndName.textContent = `${index + 1}. ${player.username}`;
        
        // Create score element
        const score = document.createElement('span');
        score.textContent = player.score || 0;  // Ensure we display 0 if undefined
        
        // Add elements to row
        playerRow.appendChild(colorIndicator);
        playerRow.appendChild(rankAndName);
        playerRow.appendChild(score);
        
        // Add row to leaderboard
        leaderboardContent.appendChild(playerRow);
    });
}
function shootBullet() {
    if (!myId || !players[myId] || chatInputFocused) return;
    
    if (currentAmmo <= 0) {
        // Play empty gun sound or show message
        showAmmoWarning();
        return;
    }
    // Check cooldown
    const currentTime = Date.now();
    if (currentTime - lastShotTime < BULLET_COOLDOWN) return;
    lastShotTime = currentTime;
    //Decrease ammo
    currentAmmo--;
    updateAmmoDisplay();
    const player = players[myId];
    
    // Calculate bullet starting position (center of player)
    const startX = player.x + PLAYER_SIZE / 2;
    const startY = player.y + PLAYER_SIZE / 2;
    
    // Calculate direction vector from player to mouse, considering camera position
    const targetX = mouseX + cameraX;
    const targetY = mouseY + cameraY;
    
    // Calculate direction vector
    let dirX = targetX - startX;
    let dirY = targetY - startY;
    
    // Normalize the direction vector
    const length = Math.sqrt(dirX * dirX + dirY * dirY);
    if (length > 0) {
        dirX /= length;
        dirY /= length;
    }
    
    // Create bullet object
    const bullet = {
        id: `bullet-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        x: startX,
        y: startY,
        dirX: dirX,
        dirY: dirY,
        playerId: myId,
        color: player.color
    };
    
    // Add to local bullets array
    bullets.push(bullet);
    
    // Send to server
    socket.emit('shoot_bullet', bullet);
     // Update server about ammo count
     socket.emit('update_ammo', { ammo: currentAmmo });
    // Play sound effect
    playShootSound();
}

// 4. Add sound effect function
function playShootSound() {
    playSound('snowball-shoot.mp3', 0.2);
}
function updateAmmoDisplay() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        ammoDisplay.textContent = `Snowball: ${currentAmmo}/${MAX_AMMO}`;
        
        // Change color based on ammo level
        if (currentAmmo <= 2) {
            ammoDisplay.style.color = '#FF0000'; // Red for low ammo
        } else if (currentAmmo <= 4) {
            ammoDisplay.style.color = '#FFA500'; // Orange for medium ammo
        } else {
            ammoDisplay.style.color = '#000000'; // Black for normal
        }
    }
}
function showAmmoWarning() {
    const ammoDisplay = document.getElementById('ammoDisplay');
    if (ammoDisplay) {
        // Flash the ammo display
        ammoDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        setTimeout(() => {
            ammoDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        }, 300);
        
        // Show message in chat
       // addChatMessage('System', 'Out of ammo! Find ammo packs to reload.');
    }
}
// 5. Add bullet update and rendering functions
function updateBullets(deltaTime) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        // Move bullet
        bullet.x += bullet.dirX * BULLET_SPEED;
        bullet.y += bullet.dirY * BULLET_SPEED;
        
        // Check if bullet is out of bounds
        if (
            bullet.x < 0 ||
            bullet.x > WORLD_WIDTH ||
            bullet.y < 0 ||
            bullet.y > WORLD_HEIGHT
        ) {
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with obstacles
        if (checkBulletObstacleCollision(bullet)) {
            // Add visual effect for collision
            createBulletImpactEffect(bullet.x, bullet.y);
            // Remove bullet and notify server
            socket.emit('bullet_removed', bullet.id);
            bullets.splice(i, 1);
            continue;
        }
        
        // Check collision with other players (only for visual feedback)
        for (const playerId in players) {
    // Don't collide with the shooter
    if (playerId === bullet.playerId) continue;
    
    const player = players[playerId];
    
    // Use a more reliable collision detection algorithm
    // Calculate distances between centers
    const bulletCenterX = bullet.x;
    const bulletCenterY = bullet.y;
    const playerCenterX = player.x + PLAYER_SIZE/2;
    const playerCenterY = player.y + PLAYER_SIZE/2;
    
    // Check if the bullet is inside the player's bounding box
    if (
        bulletCenterX >= player.x &&
        bulletCenterX <= player.x + PLAYER_SIZE &&
        bulletCenterY >= player.y &&
        bulletCenterY <= player.y + PLAYER_SIZE
    ) {
        // Visual effect only
        createHitEffect(bullet.x, bullet.y);
        
        // Notify server about the hit - this is the key change
        socket.emit('bullet_hit_player', {
            bulletId: bullet.id,
            playerId: playerId
        });
        
        // Remove bullet locally
        bullets.splice(i, 1);
        break;
    }
}
    }
}
function showBaitWarning() {
    const baitDisplay = document.getElementById('baitDisplay');
    if (baitDisplay) {
        // Flash the bait display
        baitDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
        setTimeout(() => {
            baitDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        }, 300);
        
        // Show message in chat
        addChatMessage('System', 'Out of bait! Find bait packs to resupply.');
    }
}

function createBulletImpactEffect(x, y) {
    // Create impact particle effect
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        const size = Math.random() * 3 + 2;
        const lifetime = Math.random() * 15 + 5;
        
        const particle = {
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            lifetime: lifetime,
            maxLifetime: lifetime,
            color: '#888888'
        };
        
        // If you have a particles array, add it there
        // particles.push(particle);
        
        // For simplicity, we'll just draw them directly
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Play impact sound
    // const impactSound = new Audio('/impact-sound.mp3'); // Create this sound or use a placeholder
    // impactSound.volume = 0.2;
    // impactSound.play().catch(e => console.log('Audio play failed:', e));
}
// Find the gameLoop function in your code and modify the part where you draw the ground
// Replace the current ground drawing code with this:

function drawBaitPacks() {
     gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected && !baitPack.visuallyCollected) {
            const drawX = baitPack.x - cameraX;
            const drawY = baitPack.y - cameraY;
            
            // Only draw if visible on screen
            if (
                drawX + BAIT_PACK_SIZE_DISPLAY >= 0 &&
                drawX <= canvas.width &&
                drawY + BAIT_PACK_SIZE_DISPLAY >= 0 &&
                drawY <= canvas.height
            ) {
                // Calculate bob effect for animation
                baitPack.bobOffset = baitPack.bobOffset || 0;
                baitPack.bobDirection = baitPack.bobDirection || 1;
                baitPack.bobOffset += 0.05 * baitPack.bobDirection;
                
                if (baitPack.bobOffset > 5 || baitPack.bobOffset < 0) {
                    baitPack.bobDirection *= -1;
                }
                
                // Draw with vertical bobbing animation
                const bobY = drawY + baitPack.bobOffset;
                
                // Try to draw sprite
                try {
                    ctx.drawImage(baitPackSprite, drawX, bobY, BAIT_PACK_SIZE_DISPLAY, BAIT_PACK_SIZE_DISPLAY);
                } catch (e) {
                    // Fallback to drawn worm if sprite fails to load
                    // Draw a worm-like bait pack
                    ctx.fillStyle = '#8B4513'; // Brown for worm body
                    ctx.fillRect(drawX + 5, bobY + 10, BAIT_PACK_SIZE_DISPLAY - 10, BAIT_PACK_SIZE_DISPLAY - 20);
                    
                    // Draw worm details
                    ctx.fillStyle = '#A0522D'; // Darker brown for segments
                    ctx.fillRect(drawX + 8, bobY + 15, BAIT_PACK_SIZE_DISPLAY - 16, 3);
                    ctx.fillRect(drawX + 8, bobY + 22, BAIT_PACK_SIZE_DISPLAY - 16, 3);
                    
                    // Draw worm head
                    ctx.fillStyle = '#CD853F'; // Lighter brown for head
                    ctx.beginPath();
                    ctx.arc(drawX + 5, bobY + BAIT_PACK_SIZE_DISPLAY/2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw a "B" on the bait pack (for "Bait")
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('B', drawX + BAIT_PACK_SIZE_DISPLAY/2 + 5, bobY + BAIT_PACK_SIZE_DISPLAY/2 + 5);
                }
            }
        }
    });
}
//bait pack collection function
function checkBaitPackCollection(player) {
    // Define player hitbox with larger interaction area
if (currentBait >= MAX_BAIT) {
        
        return;
    }

    const playerHitbox = {
        x: player.x + 5,            // Reduced padding from 10 to 5
        y: player.y + 5,            // Reduced padding from 10 to 5
        width: PLAYER_SIZE - 10,    // Increased from PLAYER_SIZE - 20
        height: PLAYER_SIZE - 10    // Increased from PLAYER_SIZE - 20
    };
    // Check collision with each bait pack
    gameObjects.baitPacks.forEach(baitPack => {
        if (!baitPack.collected && !baitPack.visuallyCollected) {
            // Define bait pack hitbox with better interaction area
            const baitPackHitbox = {
                x: baitPack.x,                  // Removed +5 padding
                y: baitPack.y,                  // Removed +5 padding
                width: BAIT_PACK_SIZE_DISPLAY,  // Use full size
                height: BAIT_PACK_SIZE_DISPLAY  // Use full size
            };
            
            // Check hitbox overlap
            if (
                playerHitbox.x < baitPackHitbox.x + baitPackHitbox.width &&
                playerHitbox.x + playerHitbox.width > baitPackHitbox.x &&
                playerHitbox.y < baitPackHitbox.y + baitPackHitbox.height &&
                playerHitbox.y + playerHitbox.height > baitPackHitbox.y
            ) {
                // Mark as visually collected immediately
                baitPack.visuallyCollected = true;
                
                // Create collection effect
                createCollectionEffect(baitPack.x, baitPack.y);
                
                // Collect the bait pack (server will validate)
                socket.emit('collect_bait', baitPack.id);
                
                // Play bait collection sound
                playBaitSound();
            }
        }
    });
}
function createCollectionEffect(x, y) {
    // Create simple particle effect at collection point
    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        const size = Math.random() * 3 + 2;
        
        const particleX = x + BAIT_PACK_SIZE_DISPLAY/2 - cameraX;
        const particleY = y + BAIT_PACK_SIZE_DISPLAY/2 - cameraY;
        
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
        ctx.fill();
    }
}
// 10. Add bait collection sound
function playBaitSound() {
    playSound('bait2.mp3', 0.3);
}
function drawPixelatedSnow() {
    // Use larger pixels for better performance
    const pixelSize = 16; // Larger pixels for better performance
    
    // Calculate visible area based on camera position
    // Only draw pixels that are actually visible on screen
    const startX = Math.floor(cameraX / pixelSize) * pixelSize;
    const startY = Math.floor(cameraY / pixelSize) * pixelSize;
    const endX = startX + canvas.width + pixelSize;
    const endY = startY + canvas.height + pixelSize;
    
    // Snow color palette
    const snowColors = [
        '#FFFFFF', // Pure white (main color)
        '#F0F8FF', // Alice blue (very light blue-white)
        '#F5F5F5', // White smoke (off-white)
        '#E6EEFF'  // Light blue tinted white
    ];
    
    // Pre-calculated pattern lookup for better performance
    // This creates a 16x16 pattern that repeats
    if (!window.snowPattern) {
        // Create a reusable pattern (only computed once)
        window.snowPattern = [];
        for (let px = 0; px < 16; px++) {
            window.snowPattern[px] = [];
            for (let py = 0; py < 16; py++) {
                // Generate values for each position in the repeating pattern
                const patternSeed = Math.sin(px * 0.7) * 10000 + Math.cos(py * 0.7) * 10000;
                const val = Math.abs(patternSeed) % 100;
                
                // Determine color index based on the value
                let colorIndex;
                if (val < 60) colorIndex = 0; // Main color (60%)
                else if (val < 85) colorIndex = 1; // Second color (25%)
                else if (val < 95) colorIndex = 2; // Third color (10%)
                else colorIndex = 3; // Fourth color (5%)
                
                window.snowPattern[px][py] = colorIndex;
            }
        }
    }
    
    // Draw the pixelated snow efficiently
    for (let x = startX; x < endX; x += pixelSize) {
        for (let y = startY; y < endY; y += pixelSize) {
            // Use a repeating pattern based on world position
            const patternX = Math.abs(Math.floor(x / pixelSize) % 16);
            const patternY = Math.abs(Math.floor(y / pixelSize) % 16);
            
            // Look up the color index from our pre-computed pattern
            const colorIndex = window.snowPattern[patternX][patternY];
            
            // Draw the snow pixel
            ctx.fillStyle = snowColors[colorIndex];
            ctx.fillRect(
                x - cameraX, 
                y - cameraY, 
                pixelSize, 
                pixelSize
            );
            
            // Add sparkle effects to make snow glisten (only to about 1% of pixels)
            if ((patternX + patternY) % 16 === 0) {
                // Simple highlight detail that's very cheap to draw
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(
                    x - cameraX + pixelSize/4, 
                    y - cameraY + pixelSize/4, 
                    pixelSize/2, 
                    pixelSize/2
                );
            }
        }
    }
    
    // Add occasional snow drifts/bumps for texture
 // drawSnowDrifts(startX, startY, endX, endY, pixelSize);
}

// Function to add occasional snow drifts for more texture
function drawSnowDrifts(startX, startY, endX, endY, pixelSize) {
    // Create some random snow drifts
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    
    // Use a deterministic approach for drift placement based on world position
    for (let x = startX; x < endX; x += pixelSize * 10) {
        for (let y = startY; y < endY; y += pixelSize * 10) {
            // Use position to seed a consistent drift pattern
            const seed = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 10000;
            
            // Only draw drift in some locations
            if (Math.abs(seed) % 100 < 30) {
                // Determine drift size
                const driftWidth = (Math.abs(seed) % 5 + 3) * pixelSize;
                const driftHeight = (Math.abs(seed) % 3 + 1) * pixelSize;
                
                // Draw an oval snow drift
                ctx.beginPath();
                ctx.ellipse(
                    x - cameraX + pixelSize * 5, 
                    y - cameraY + pixelSize * 5, 
                    driftWidth / 2, 
                    driftHeight / 2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }
    }
}
// Add this new function to create the pixelated grass effect
function drawPixelatedGrass() {
    // Use larger pixels for better performance
    const pixelSize = 16; // Larger pixels for better performance
    
    // Calculate visible area based on camera position
    // Only draw pixels that are actually visible on screen
    const startX = Math.floor(cameraX / pixelSize) * pixelSize;
    const startY = Math.floor(cameraY / pixelSize) * pixelSize;
    const endX = startX + canvas.width + pixelSize;
    const endY = startY + canvas.height + pixelSize;
    
    // Simpler color palette for better performance
    const grassColors = [
        '#7CFC00', // Base bright green (main color)
        '#6BC400', // Slightly darker green
        '#5FB300', // Medium green
        '#73DB0A'  // Yellowish green
    ];
    
    // Pre-calculated pattern lookup for better performance
    // This creates a 16x16 pattern that repeats
    if (!window.grassPattern) {
        // Create a reusable pattern (only computed once)
        window.grassPattern = [];
        for (let px = 0; px < 16; px++) {
            window.grassPattern[px] = [];
            for (let py = 0; py < 16; py++) {
                // Generate values for each position in the repeating pattern
                const patternSeed = Math.sin(px * 0.7) * 10000 + Math.cos(py * 0.7) * 10000;
                const val = Math.abs(patternSeed) % 100;
                
                // Determine color index based on the value
                let colorIndex;
                if (val < 60) colorIndex = 0; // Main color (60%)
                else if (val < 85) colorIndex = 1; // Second color (25%)
                else if (val < 95) colorIndex = 2; // Third color (10%)
                else colorIndex = 3; // Fourth color (5%)
                
                window.grassPattern[px][py] = colorIndex;
            }
        }
    }
    
    // Draw the pixelated grass efficiently
    for (let x = startX; x < endX; x += pixelSize) {
        for (let y = startY; y < endY; y += pixelSize) {
            // Use a repeating pattern based on world position
            const patternX = Math.abs(Math.floor(x / pixelSize) % 16);
            const patternY = Math.abs(Math.floor(y / pixelSize) % 16);
            
            // Look up the color index from our pre-computed pattern
            const colorIndex = window.grassPattern[patternX][patternY];
            
            // Draw the grass pixel
            ctx.fillStyle = grassColors[colorIndex];
            ctx.fillRect(
                x - cameraX, 
                y - cameraY, 
                pixelSize, 
                pixelSize
            );
            
            // Add minimal detail elements (only to about 1% of pixels)
            // This uses a very efficient calculation
            if ((patternX + patternY) % 16 === 0) {
                // Simple highlight detail that's very cheap to draw
                ctx.fillStyle = '#AEFF00';
                ctx.fillRect(
                    x - cameraX + pixelSize/4, 
                    y - cameraY + pixelSize/4, 
                    pixelSize/2, 
                    pixelSize/2
                );
            }
        }
    }
}
function getAnimationFrame(player) {
    // Base frames for each direction
    const frameMap = {
        'right': { idle: 0, walkStart: 1 },
        'left': { idle: 5, walkStart: 6 },
        'down': { idle: 10, walkStart: 11 },
        'up': { idle: 15, walkStart: 16 }
    };
    
    const dir = player.direction || 'down';
    
    // Use idle frame if not moving
    if (!player.isMoving) {
        return frameMap[dir].idle;
    }
    
    // Otherwise use walk animation (cycles through 4 frames)
    const baseFrame = frameMap[dir].walkStart;
    return baseFrame + (player.animFrame % 4);
}
function checkBulletObstacleCollision(bullet) {
    // Check rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        if (
            bullet.x >= rock.x &&
            bullet.x <= rock.x + rockSize &&
            bullet.y >= rock.y &&
            bullet.y <= rock.y + rockSize
        ) {
            return true;
        }
    }
    
    // Check trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Only collide with the trunk part
        if (
            bullet.x >= tree.x + treeSize * 0.3 &&
            bullet.x <= tree.x + treeSize * 0.7 &&
            bullet.y >= tree.y + treeSize * 0.5 &&
            bullet.y <= tree.y + treeSize
        ) {
            return true;
        }
    }
    
    return false;
}

// 6. Add hit effect function for visual feedback
function createHitEffect(x, y) {
    // This could be expanded with particles, animation, etc.
    // const hitSound = new Audio('/hit-sound.mp3'); // Create this sound or use a placeholder
    // hitSound.volume = 0.3;
    // hitSound.play().catch(e => console.log('Audio play failed:', e));
}

// Function to update the water animation to look like ice
function drawDecorativeLakes() {
    gameObjects.decorativeLakes.forEach(lake => {
        const drawX = lake.x - cameraX;
        const drawY = lake.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + lake.width >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + lake.height >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Use the same ice drawing style as your existing ponds
            // but make them slightly lighter to differentiate
            ctx.fillStyle = '#B8E3FF'; // Slightly lighter blue than fishable ponds
            ctx.beginPath();
            ctx.ellipse(
                drawX + lake.width/2, 
                drawY + lake.height/2, 
                lake.width/2, 
                lake.height/2, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Add inner detail
            ctx.fillStyle = '#E0F4FF'; // Even lighter blue
            ctx.beginPath();
            ctx.ellipse(
                drawX + lake.width/2, 
                drawY + lake.height/2, 
                lake.width/3, 
                lake.height/3, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Draw ice cracks and ripples
            drawDecorativeIceRipples(drawX, drawY, lake);
            
            // Animate ice effects
          //  drawDecorativeIceAnimation(drawX, drawY, lake);
        }
    });
}

// 3. Adapted ice ripples function for decorative lakes
function drawDecorativeIceRipples(drawX, drawY, lake) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // Slightly more transparent than ponds
    ctx.lineWidth = 1;
    
    // Draw 4 elliptical cracks (more than ponds for larger size)
    for (let i = 0; i < 4; i++) {
        const seed = i * 1000 + lake.x + lake.y + 500; // Different seed pattern
        const cracksScale = 0.7 + (i * 0.08);
        
        ctx.beginPath();
        ctx.ellipse(
            drawX + lake.width/2, 
            drawY + lake.height/2, 
            lake.width/2 * cracksScale, 
            lake.height/2 * cracksScale, 
            0, 0, Math.PI * 2
        );
        ctx.stroke();
        
        // Add radiating cracks
        const numCracks = 4 + i; // More cracks for larger lakes
        for (let j = 0; j < numCracks; j++) {
            const angle = (seed + j * 1000) % 628 / 100;
            const startX = drawX + lake.width/2;
            const startY = drawY + lake.height/2;
            const length = (lake.width/2) * (0.4 + (j % 3) * 0.2);
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            // Create jagged line
            let currentX = startX;
            let currentY = startY;
            const segments = 4 + (j % 3);
            
            for (let k = 0; k < segments; k++) {
                const segmentAngle = angle + (Math.sin(k * 1.7) * 0.25);
                const segmentLength = length / segments;
                
                currentX += Math.cos(segmentAngle) * segmentLength;
                currentY += Math.sin(segmentAngle) * segmentLength;
                
                ctx.lineTo(currentX, currentY);
            }
            
            ctx.stroke();
        }
    }
}

// 4. Adapted ice animation function for decorative lakes
function drawDecorativeIceAnimation(drawX, drawY, lake) {
    const time = Date.now() * 0.001;
    
    // Draw ice cracks pattern
    ctx.strokeStyle = 'rgba(200, 230, 255, 0.5)'; // Slightly more transparent
    ctx.lineWidth = 1.5;
    
    // Create ice crack patterns (more for larger lakes)
    for (let i = 0; i < 7; i++) {
        const yOffset = (i * lake.height/7) + Math.sin(time * 0.4 + i) * 4;
        
        if (yOffset > 0 && yOffset < lake.height) {
            ctx.beginPath();
            ctx.moveTo(drawX + lake.width * 0.15, drawY + yOffset);
            
            // Create jagged line for ice cracks
            for (let x = 0; x <= 8; x++) {
                const waveX = drawX + lake.width * (0.15 + x * 0.0875);
                const waveY = drawY + yOffset + Math.sin(time * 1.3 + x * 2.2 + i) * 4;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.stroke();
        }
    }
    
    // Add multiple ice shine highlights for larger area
    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
    
    // Main highlight
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * 0.6,
        drawY + lake.height * 0.3,
        lake.width * 0.12,
        lake.height * 0.08,
        Math.PI / 5,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Secondary highlight
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * 0.75,
        drawY + lake.height * 0.6,
        lake.width * 0.08,
        lake.height * 0.05,
        -Math.PI / 6,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Moving frost pattern
    const frostTime = (time * 0.5) % 1;
    ctx.fillStyle = 'rgba(245, 250, 255, 0.15)';
    ctx.beginPath();
    ctx.ellipse(
        drawX + lake.width * (0.2 + frostTime * 0.6),
        drawY + lake.height * (0.4 + Math.sin(time) * 0.2),
        lake.width * 0.1,
        lake.height * 0.05,
        time,
        0, Math.PI * 2
    );
    ctx.fill();
}


function drawPonds() {
    gameObjects.ponds.forEach(pond => {
        const drawX = pond.x - cameraX;
        const drawY = pond.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + pond.width >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + pond.height >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to colored shape
            try {
                ctx.drawImage(pondSprite, drawX, drawY, pond.width, pond.height);
            } catch (e) {
                // Fallback to blue oval
                ctx.fillStyle = '#4FC3F7';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/2, 
                    pond.height/2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add some detail to the pond
                ctx.fillStyle = '#29B6F6';
                ctx.beginPath();
                ctx.ellipse(
                    drawX + pond.width/2, 
                    drawY + pond.height/2, 
                    pond.width/3, 
                    pond.height/3, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Add ripple effects
                drawPondRipples(drawX, drawY, pond);
            }
            
            // Animate water by drawing semi-transparent waves
            drawWaterAnimation(drawX, drawY, pond);
        }
    });
}

// Add ripple effects to pond
function drawPondRipples(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2;
    
    // Draw 3 elliptical ripples that grow and fade over time
    for (let i = 0; i < 3; i++) {
        const offset = i * Math.PI * 0.6; // Offset each ripple
        const size = ((time + offset) % 3) / 3; // 0 to 1 value for size
        
        if (size > 0.1) { // Only draw visible ripples
            ctx.globalAlpha = 0.3 - size * 0.3; // Fade out as they grow
            ctx.beginPath();
            ctx.ellipse(
                drawX + pond.width/2, 
                drawY + pond.height/2, 
                pond.width/2 * size + pond.width/4, 
                pond.height/2 * size + pond.height/4, 
                0, 0, Math.PI * 2
            );
            ctx.stroke();
        }
    }
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

// Animate water surface
function drawWaterAnimation(drawX, drawY, pond) {
    const time = Date.now() * 0.001;
    
    // Draw some animated wave lines on the water
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1.5;
    
    // Create wave patterns
    for (let i = 0; i < 5; i++) {
        const yOffset = (i * pond.height/5) + Math.sin(time * 2 + i) * 5;
        
        if (yOffset > 0 && yOffset < pond.height) {
            ctx.beginPath();
            ctx.moveTo(drawX + pond.width * 0.2, drawY + yOffset);
            
            // Create wavy line
            for (let x = 0; x <= 6; x++) {
                const waveX = drawX + pond.width * (0.2 + x * 0.1);
                const waveY = drawY + yOffset + Math.sin(time * 3 + x + i) * 3;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.stroke();
        }
    }
}
// 7. Add bullet drawing function
function drawBullets() {
    for (const bullet of bullets) {
        const drawX = bullet.x - cameraX;
        const drawY = bullet.y - cameraY;
        
        // Only draw if visible on screen
        if (
            drawX + BULLET_SIZE >= 0 &&
            drawX <= canvas.width &&
            drawY + BULLET_SIZE >= 0 &&
            drawY <= canvas.height
        ) {
            // Draw bullet
            ctx.fillStyle = bullet.color || '#FF0000';
            ctx.beginPath();
            ctx.arc(drawX, drawY, BULLET_SIZE/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Optional: Draw trail/tail
            ctx.strokeStyle = bullet.color || '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(drawX, drawY);
            ctx.lineTo(drawX - bullet.dirX * 10, drawY - bullet.dirY * 10);
            ctx.stroke();
        }
    }
}
// Function to draw ammo packs
function drawAmmoPacks() {
    ctx.fillStyle = '#00AAFF'; // Blue color for ammo packs
    
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            const drawX = ammoPack.x - cameraX;
            const drawY = ammoPack.y - cameraY;
            
            // Only draw if visible on screen
            if (
                drawX + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawX <= canvas.width &&
                drawY + AMMO_PACK_SIZE_DISPLAY >= 0 &&
                drawY <= canvas.height
            ) {
                // Try to draw sprite
                try {
                    ctx.drawImage(ammoPackSprite, drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                } catch (e) {
                    // Fallback to colored rectangle with an "A" on it
                    ctx.fillStyle = '#0088CC';
                    ctx.fillRect(drawX, drawY, AMMO_PACK_SIZE_DISPLAY, AMMO_PACK_SIZE_DISPLAY);
                    
                    // Draw a white "A" on the ammo pack
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('A', drawX + AMMO_PACK_SIZE_DISPLAY/2, drawY + AMMO_PACK_SIZE_DISPLAY/2 + 7);
                    
                    // Reset fill style
                    ctx.fillStyle = '#00AAFF';
                }
                
                // Animate ammo pack bob up and down (similar to coins)
                ammoPack.bobOffset = ammoPack.bobOffset || 0;
                ammoPack.bobDirection = ammoPack.bobDirection || 1;
                ammoPack.bobOffset += 0.05 * ammoPack.bobDirection;
                
                if (ammoPack.bobOffset > 5 || ammoPack.bobOffset < 0) {
                    ammoPack.bobDirection *= -1;
                }
            }
        }
    });
}
let lastFlashTime = 0;
const FLASH_COOLDOWN = 500;
function flashScreen(color) {
    const currentTime = Date.now();
    if (currentTime - lastFlashTime < FLASH_COOLDOWN) return;
    lastFlashTime = currentTime;
    // Create overlay div
    
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.boxShadow = 'inset 0 0 50px 20px ' + color; // Create an inset shadow instead of background
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '1000';
    flash.style.backgroundColor = 'transparent'; // No background color
    
    // Add to game container
    gameContainer.appendChild(flash);
    
    // Fade out and remove
    setTimeout(() => {
        flash.style.transition = 'box-shadow 0.3s';
        flash.style.boxShadow = 'inset 0 0 0 0 transparent';
        setTimeout(() => {
            gameContainer.removeChild(flash);
        }, 300);
    }, 100);
}

function playHitConfirmSound() {
    // const hitConfirmSound = new Audio('/hit-confirm.mp3'); // Create this sound or use a placeholder
    // hitConfirmSound.volume = 0.2;
    // hitConfirmSound.play().catch(e => console.log('Audio play failed:', e));
}

        function checkCoinCollection(player) {
            // Define player hitbox
            const playerHitbox = {
                x: player.x + 10,
                y: player.y + 10,
                width: PLAYER_SIZE - 20,
                height: PLAYER_SIZE - 20
            };
            
            // Check collision with each coin
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    // Define coin hitbox
                    const coinHitbox = {
                        x: coin.x + 5,
                        y: coin.y + 5,
                        width: COIN_SIZE - 10,
                        height: COIN_SIZE - 10
                    };
                    
                    // Check hitbox overlap
                    if (
                        playerHitbox.x < coinHitbox.x + coinHitbox.width &&
                        playerHitbox.x + playerHitbox.width > coinHitbox.x &&
                        playerHitbox.y < coinHitbox.y + coinHitbox.height &&
                        playerHitbox.y + playerHitbox.height > coinHitbox.y
                    ) {
                        // Collect the coin (server will validate)
                        socket.emit('collect_coin', coin.id);
                        
                        // Play coin collection sound
                        playCoinSound();
                    }
                }
            });
               updateLeaderboard();
        }
        function checkAmmoPackCollection(player) {
    // Define player hitbox
    const playerHitbox = {
        x: player.x + 10,
        y: player.y + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 20
    };
    
    // Check collision with each ammo pack
    gameObjects.ammoPacks.forEach(ammoPack => {
        if (!ammoPack.collected) {
            // Define ammo pack hitbox
            const ammoPackHitbox = {
                x: ammoPack.x + 5,
                y: ammoPack.y + 5,
                width: AMMO_PACK_SIZE_DISPLAY - 10,
                height: AMMO_PACK_SIZE_DISPLAY - 10
            };
            
            // Check hitbox overlap
            if (
                playerHitbox.x < ammoPackHitbox.x + ammoPackHitbox.width &&
                playerHitbox.x + playerHitbox.width > ammoPackHitbox.x &&
                playerHitbox.y < ammoPackHitbox.y + ammoPackHitbox.height &&
                playerHitbox.y + playerHitbox.height > ammoPackHitbox.y
            ) {
                // Collect the ammo pack (server will validate)
                socket.emit('collect_ammo', ammoPack.id);
                
                // Play ammo collection sound
                playAmmoSound();
            }
        }
    });
}
function playAmmoSound() {
    playSound('snowball-get.mp3', 0.5);
}
        function checkCollision(player, newX, newY) {
    // Define player hitbox with some padding for better gameplay
    const playerHitbox = {
        x: newX + 10,
        y: newY + 10,
        width: PLAYER_SIZE - 20,
        height: PLAYER_SIZE - 30
    };
    
    // Calculate player center coordinates - ADD THESE LINES
    const playerCenterX = newX + PLAYER_SIZE/2;
    const playerCenterY = newY + PLAYER_SIZE/2;
    // Check collision with trees
    for (const tree of gameObjects.trees) {
        const treeSize = tree.size || 70;
        // Trees have a smaller collision box than visual size
        const treeHitbox = {
            x: tree.x + treeSize * 0.2,
            y: tree.y + treeSize * 0.5, // Mostly bottom part (trunk)
            width: treeSize * 0.6,
            height: treeSize * 0.5
        };
        
        if (
            playerHitbox.x < treeHitbox.x + treeHitbox.width &&
            playerHitbox.x + playerHitbox.width > treeHitbox.x &&
            playerHitbox.y < treeHitbox.y + treeHitbox.height &&
            playerHitbox.y + playerHitbox.height > treeHitbox.y
        ) {
            return true; // Collision detected
        }
    }
    
    // Check collision with rocks
    for (const rock of gameObjects.rocks) {
        const rockSize = rock.size || 40;
        // Rocks have a slightly smaller collision box
        const rockHitbox = {
            x: rock.x + rockSize * 0.1,
            y: rock.y + rockSize * 0.1,
            width: rockSize * 0.8,
            height: rockSize * 0.8
        };
        
        if (
            playerHitbox.x < rockHitbox.x + rockHitbox.width &&
            playerHitbox.x + playerHitbox.width > rockHitbox.x &&
            playerHitbox.y < rockHitbox.y + rockHitbox.height &&
            playerHitbox.y + playerHitbox.height > rockHitbox.y
        ) {
            return true; // Collision detected
        }
    }
     // Check deep water collision (allow wading at edges but not deep water)
    for (const pond of gameObjects.ponds) {
        // Calculate pond center and radiuses
        const pondCenterX = pond.x + pond.width/2;
        const pondCenterY = pond.y + pond.height/2;
        const pondRadiusX = pond.width/2;
        const pondRadiusY = pond.height/2;
        
        // Calculate normalized distance from center (elliptical equation)
        // For a point (x,y) in an ellipse with center (h,k) and radii a,b:
        // ((x-h)/a)² + ((y-k)/b)² <= 1 means the point is inside the ellipse
        const dx = (playerCenterX - pondCenterX) / pondRadiusX;
        const dy = (playerCenterY - pondCenterY) / pondRadiusY;
        const distanceSquared = dx*dx + dy*dy;
        
        // If player is deeper than 70% into the pond (from edge to center), block movement
        // This allows the player to wade in the shallow edges (30% from the edge)
        if (distanceSquared < 0.7*0.7) {  // Using 0.7² to avoid square root calculation
            return true; // Too deep in water
        }
        
        // Optional: Add movement penalty when in shallow water
        // This would be handled elsewhere in movement code
    }
    
    return false; // No collision
}
function playCoinSound() {
    playSound('coin-sound.mp3', 0.2);
}
        
        function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message.length > 0) {
                socket.emit('chat_message', message);
                chatInput.value = '';
            }
        }
        
        function addChatMessage(username, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.textContent = `${username}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function gameLoop() {
            if (!myId || !players[myId]) {
                requestAnimationFrame(gameLoop);
                return;
            }
            if (!players[myId].momentum) {
    players[myId].momentum = { x: 0, y: 0 };
    players[myId].isOnIce = false;
}
             // Update player movement based on key states
            updatePlayerMovement();
            // Update camera position to follow player
            const player = players[myId];
            cameraX = player.x - canvas.width / 2 + PLAYER_SIZE / 2;
            cameraY = player.y - canvas.height / 2 + PLAYER_SIZE / 2;
            
            // Clamp camera to world bounds
            cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - canvas.height));
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            ctx.fillStyle = '#7CFC00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds (optional)
            //drawPixelatedGrass();
            drawPixelatedSnow();
           
            // Draw rocks
           
             drawDecorativeLakes();
            //draw ponds
            drawPonds();
            //drawIce();
            // Draw trees
          
            
            // Draw coins
        for (const id in players) {
    const player = players[id];
    
    // For our own player, determine movement state from keys
    if (id === myId) {
        // Check if moving
        player.isMoving = keys.up || keys.down || keys.left || keys.right;
        
        // Update direction based on last pressed key
        if (keys.right) player.direction = 'right';
        else if (keys.left) player.direction = 'left';
        else if (keys.down) player.direction = 'down';
        else if (keys.up) player.direction = 'up';
    } else {
        // For other players, check if they're moving by comparing positions
        if (player.prevX !== undefined && player.prevY !== undefined) {
            player.isMoving = 
                Math.abs(player.x - player.prevX) > 0.1 || 
                Math.abs(player.y - player.prevY) > 0.1;
                
            if (player.isMoving) {
                // Calculate movement magnitude in each direction
                const dx = Math.abs(player.x - player.prevX);
                const dy = Math.abs(player.y - player.prevY);
                
                // Only update direction if there's significant movement
                // This prevents rapid direction changes during small movements
                const movementThreshold = 0.3;
                
                // Direction change hysteresis - require more movement to change direction
                const directionChangeThreshold = player.lastDirection === player.direction ? 1.2 : 1.0;
                
                if (dx > movementThreshold || dy > movementThreshold) {
                    // Determine primary movement direction with hysteresis
                    // This prevents rapid switching between horizontal/vertical during diagonal movement
                    let newDirection = player.direction; // Default to keeping current direction
                    
                    if (dx > dy * directionChangeThreshold) {
                        // Horizontal movement dominates
                        newDirection = player.x > player.prevX ? 'right' : 'left';
                    } else if (dy > dx * directionChangeThreshold) {
                        // Vertical movement dominates
                        newDirection = player.y > player.prevY ? 'down' : 'up';
                    }
                    
                    // Store last direction before changing
                    player.lastDirection = player.direction;
                    
                    // Update direction if it changed
                    player.direction = newDirection;
                }
            }
        }
        
        // Update previous position
        player.prevX = player.x;
        player.prevY = player.y;
    }
    
    // Update animation frame counter
  if (player.isMoving) {
    player.animTimer = player.animTimer || 0;
    player.animTimer++;
    
    // Change animation frame less frequently for other players
    const frameChangeThreshold = id === myId ? 12 : 12; // Increased from 32 to 45 for other players
    
    if (player.animTimer >= frameChangeThreshold) {
        player.animFrame = player.animFrame || 0;
        player.animFrame = (player.animFrame + 1) % 4; // 4 frames per direction
        player.animTimer = 0;
    }
    
    // Store last animation time to prevent rapid resets
    player.lastAnimTime = Date.now();
} else {
    // Only reset animation when definitely idle for a while (debounce)
    // This prevents animation resetting during tiny pauses in network updates
    if (!player.lastAnimTime || (Date.now() - player.lastAnimTime > 500)) {
        player.animFrame = 0;
        player.animTimer = 0;
    }
}
}
            drawPlayers();
            drawGameObjects(gameObjects.trees, treeSprite, 'green');
            drawGameObjects(gameObjects.rocks, rockSprite, 'gray');
               drawIceParticles();
             // Draw ammo packs
            drawAmmoPacks();
            if (isFishing || isFishingCast) {
                drawFishingProgress();
            }
    drawBaitPacks();
    drawCoins();
    drawBullets();
    drawClouds();
    drawFallingSnow();
    // Draw fish inventory if open
    if (isInventoryOpen) {
        drawFishInventory();
    }
    
    updateBullets(16);
     updateMinimap();
    const now = Date.now();
    const INTERPOLATION_DURATION = 100; // ms
    
    // Process position buffer for smooth movement
    for (let i = positionBuffer.length - 1; i >= 0; i--) {
        const move = positionBuffer[i];
        const elapsed = now - move.timestamp;
        
        if (elapsed >= INTERPOLATION_DURATION) {
            // Apply final position and remove from buffer
            if (players[move.id]) {
                players[move.id].x = move.toX;
                players[move.id].y = move.toY;
            }
            positionBuffer.splice(i, 1);
        } else {
            // Interpolate position
            const progress = elapsed / INTERPOLATION_DURATION;
            move.progress = progress;
            
            if (players[move.id]) {
                // Ease-out function for smoother motion
                const t = 1 - Math.pow(1 - progress, 2);
                players[move.id].x = move.fromX + (move.toX - move.fromX) * t;
                players[move.id].y = move.fromY + (move.toY - move.fromY) * t;
            }
        }
    }
   
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }
   function updatePlayerMovement() {
    if (!myId || !players[myId]) return;
    
    const player = players[myId];
    let newX = player.x;
    let newY = player.y;
    let moved = false;
    
    // Save original position for rollback if needed
    const originalX = player.x;
    const originalY = player.y;
    
    // Define movement parameters
    const CONSTANT_SPEED = 300; // pixels per second
    
    // Calculate elapsed time since last frame in seconds
    const now = performance.now();
    const deltaTimeSeconds = (now - (lastUpdateTime || now)) / 1000;
    lastUpdateTime = now;
    
    // Apply a strict cap to prevent huge jumps if the game freezes momentarily
    const cappedDeltaTime = Math.min(deltaTimeSeconds, 0.1); // max 100ms
    
    // Check if the player is on ice
    const onIce = isPlayerOnIce(player.x, player.y, PLAYER_SIZE);
    player.isOnIce = onIce;
    
    // Different physics parameters based on surfa1e
  const acceleration = onIce ? 0.1 : 1.0; // Slower acceleration on ice
    const friction = onIce ? 0.98 : 0.1;   // Less friction (more slippery) on ice
    
    // Calculate base movement distance
    const moveDistance = CONSTANT_SPEED * cappedDeltaTime;
    
    // Apply forces based on key presses (acceleration)
   if (keys.up) {
    player.momentum.y -= moveDistance * acceleration;
    moved = true;
}
if (keys.down) {
    player.momentum.y += moveDistance * acceleration;
    moved = true;
}
if (keys.left) {
    player.momentum.x -= moveDistance * acceleration;
    moved = true;
}
if (keys.right) {
    player.momentum.x += moveDistance * acceleration;
    moved = true;
}

// Apply diagonal normalization - MODIFIED for better ice physics
if ((keys.up || keys.down) && (keys.left || keys.right)) {
    // Use a milder diagonal factor on ice to prevent feeling sluggish
    const diagonalFactor = onIce ? 0.9 : 0.7071; // Higher value on ice
    player.momentum.x *= diagonalFactor;
    player.momentum.y *= diagonalFactor;
}
    
    // Apply momentum (this is what creates the sliding effect)
    newX += player.momentum.x;
    newY += player.momentum.y;
    
    // Apply friction to slow down
    player.momentum.x *= friction;
    player.momentum.y *= friction;
    
    // If momentum is very small, just stop completely
    if (Math.abs(player.momentum.x) < 0.1) player.momentum.x = 0;
    if (Math.abs(player.momentum.y) < 0.1) player.momentum.y = 0;
    
    // Keep player within world bounds
    if (newX < 0) {
        newX = 0;
        player.momentum.x = 0; // Stop momentum when hitting wall
    }
    if (newY < 0) {
        newY = 0;
        player.momentum.y = 0; // Stop momentum when hitting wall
    }
    if (newX > WORLD_WIDTH - PLAYER_SIZE) {
        newX = WORLD_WIDTH - PLAYER_SIZE;
        player.momentum.x = 0; // Stop momentum when hitting wall
    }
    if (newY > WORLD_HEIGHT - PLAYER_SIZE) {
        newY = WORLD_HEIGHT - PLAYER_SIZE;
        player.momentum.y = 0; // Stop momentum when hitting wall
    }
    
    // Visual ice indicator (optional)
    if (onIce && (Math.abs(player.momentum.x) > 0.5 || Math.abs(player.momentum.y) > 0.5)) {
        // Create sliding effects/particles behind player
        createIceSlideEffect(player.x + PLAYER_SIZE/2, player.y + PLAYER_SIZE/2);
    }
    
    // Check for collision with obstacles
    if ((moved || player.momentum.x !== 0 || player.momentum.y !== 0) && !checkCollision(player, newX, newY)) {
        // Apply movement locally first (client-side prediction)
        players[myId].x = newX;
        players[myId].y = newY;
        
        // Check for collectibles
        checkCoinCollection(player);
        checkAmmoPackCollection(player);
        checkBaitPackCollection(player);
        
        // Send updated position to server with timestamp
        const now = Date.now();
        if (now - lastMovementUpdate >= MOVEMENT_UPDATE_INTERVAL) {
            lastMovementUpdate = now;
            socket.emit('move', {
                x: newX,
                y: newY,
                timestamp: now
            });
        }
    } else if (moved || player.momentum.x !== 0 || player.momentum.y !== 0) {
        // If there's a collision, stop momentum
        player.momentum.x = 0;
        player.momentum.y = 0;
        
        // Revert to last valid position
        players[myId].x = originalX;
        players[myId].y = originalY;
    }
}
function createIceSlideEffect(x, y) {
    // Create ice particle effects
    for (let i = 0; i < 2; i++) { // Keep particle count low for performance
        const particle = {
            x: x + (Math.random() * 10 - 5),
            y: y + (Math.random() * 10 - 5),
            size: Math.random() * 2 + 1,
            opacity: Math.random() * 0.3 + 0.2,
            lifetime: 10,
            maxLifetime: 10
        };
        
        
        // If you have a particle system:
        if (!window.iceParticles) window.iceParticles = [];
        window.iceParticles.push(particle);
    }
}

//render ice particles
function drawIceParticles() {
    if (!window.iceParticles) return;
    
    ctx.fillStyle = '#FFFFFF';
    
    for (let i = window.iceParticles.length - 1; i >= 0; i--) {
        const p = window.iceParticles[i];
        
        // Draw particle
        ctx.globalAlpha = p.opacity * (p.lifetime / p.maxLifetime);
        ctx.beginPath();
        ctx.arc(p.x - cameraX, p.y - cameraY, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Update lifetime
        p.lifetime--;
        
        // Remove dead particles
        if (p.lifetime <= 0) {
            window.iceParticles.splice(i, 1);
        }
    }
    
    ctx.globalAlpha = 1.0;
}
function drawClouds() {
    // Winter cloud settings - using blue-gray tones
    // Choose one of these color options:
    
    // Option 1: Light Gray Clouds
    // ctx.fillStyle = 'rgba(220, 220, 220, 0.8)';
    
    // Option 2: Soft Blue-Gray Clouds (recommended for winter theme)
    ctx.fillStyle = 'rgba(210, 218, 230, 0.8)';
    
    // Option 3: White with blue tint
    // ctx.fillStyle = 'rgba(240, 248, 255, 0.8)';
    
    // Use time to animate clouds
    const time = Date.now() * 0.0002;
    
    // Create fewer clouds with larger minimum size
    // and make them move horizontally
    const cloudSpacingX = 1200; // Increased from 800 for larger world
    const cloudSpacingY = 800;  // Increased from 500 for larger world
    
    // Determine visible area based on camera position
    const visibleLeft = cameraX;
    const visibleRight = cameraX + canvas.width;
    const visibleTop = cameraY;
    const visibleBottom = cameraY + canvas.height;
    
    // Generate clouds in the visible area (with buffer for smooth scrolling)
    for (let baseY = Math.floor(visibleTop / cloudSpacingY) * cloudSpacingY - cloudSpacingY; 
         baseY <= visibleBottom + cloudSpacingY; 
         baseY += cloudSpacingY) {
        
        // For each row, create fewer clouds
        for (let i = 0; i < 5; i++) {
            // Create a cloud with consistent movement based on position
            const seed = baseY * 0.1 + i * 1000;
            const random = Math.abs(Math.sin(seed)) * 10000 % 1;
            
            // Calculate base position
            let baseX = (i * cloudSpacingX) + (random * cloudSpacingX);
            
            // Apply horizontal movement based on time
            // Different rows move at different speeds and directions
            const speedFactor = (baseY % 3 === 0) ? 1 : ((baseY % 3 === 1) ? -0.7 : 0.5);
            const movement = time * 100 * speedFactor;
            
            // Wrap around the world width
            baseX = (baseX + movement) % (WORLD_WIDTH + cloudSpacingX);
            if (baseX < -cloudSpacingX) baseX += WORLD_WIDTH + cloudSpacingX;
            
            // Determine cloud size (larger minimum size)
            const minSize = 220; // Increased minimum size
            const maxSize = 500;
            const sizeVariation = Math.max(0.5, 1 - (baseY / WORLD_HEIGHT));
            const cloudSize = minSize + (maxSize - minSize) * sizeVariation * random;
            
            const drawX = baseX - cameraX;
            const drawY = baseY - cameraY;
            
            // Only draw if potentially visible
            if (drawX + cloudSize >= -200 && 
                drawX <= canvas.width + 200 && 
                drawY + cloudSize >= -200 && 
                drawY <= canvas.height + 200) {
                
                // Draw cloud with MORE overlapping circles to avoid triangle gaps
                ctx.beginPath();
                
                // Main center circle
                ctx.arc(drawX, drawY, cloudSize * 0.5, 0, Math.PI * 2);
                
                // Additional circles to create fuller shape without gaps
                ctx.arc(drawX + cloudSize * 0.4, drawY - cloudSize * 0.1, cloudSize * 0.45, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.3, drawY, cloudSize * 0.4, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.1, drawY + cloudSize * 0.1, cloudSize * 0.35, 0, Math.PI * 2);
                
                // Add more circles to fill gaps
                ctx.arc(drawX - cloudSize * 0.15, drawY - cloudSize * 0.15, cloudSize * 0.35, 0, Math.PI * 2);
                ctx.arc(drawX + cloudSize * 0.25, drawY + cloudSize * 0.05, cloudSize * 0.3, 0, Math.PI * 2);
                ctx.arc(drawX - cloudSize * 0.1, drawY + cloudSize * 0.2, cloudSize * 0.25, 0, Math.PI * 2);
                
                // Fill the entire shape
                ctx.fill();
                
                // Optional: Add darker bottom to clouds to suggest snow
                ctx.fillStyle = 'rgba(190, 200, 220, 0.4)';
                ctx.beginPath();
                ctx.arc(drawX, drawY + cloudSize * 0.1, cloudSize * 0.45, 0, Math.PI);
                ctx.arc(drawX - cloudSize * 0.25, drawY + cloudSize * 0.15, cloudSize * 0.3, 0, Math.PI);
                ctx.arc(drawX + cloudSize * 0.25, drawY + cloudSize * 0.12, cloudSize * 0.35, 0, Math.PI);
                ctx.fill();
            }
        }
    }
    
    // Optional: Add occasional falling snowflakes
   // drawFallingSnow();
}

//a new function to create falling snow effect
// Simple diagonal snow effect for top-down view
function drawFallingSnow() {
    // Create snow array once
    if (!window.snowflakes) {
        window.snowflakes = [];
        // Create snowflakes around the camera view
        for (let i = 0; i < 300; i++) {
            window.snowflakes.push(createSnowflakeAtCamera());
        }
    }
    
    // Draw and update each snowflake
    ctx.fillStyle = '#FFFFFF';
    
    for (let i = 0; i < window.snowflakes.length; i++) {
        const flake = window.snowflakes[i];
        
        // Calculate screen position (relative to camera)
        const drawX = flake.x - cameraX;
        const drawY = flake.y - cameraY;
        
        // Only draw if visible on screen (with small buffer)
        if (
            drawX >= -20 &&
            drawX <= canvas.width + 20 &&
            drawY >= -20 &&
            drawY <= canvas.height + 20
        ) {
            // Set opacity for this snowflake
            ctx.globalAlpha = flake.opacity;
            
            // Draw snowflake as a simple circle
            ctx.beginPath();
            ctx.arc(drawX, drawY, flake.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Update snowflake position - diagonal movement
        flake.x += flake.speedX;
        flake.y += flake.speedY;
        
        // Check if the snowflake is far outside the camera view
        // Use a larger boundary than drawing boundary
        const farOffScreen = 
            drawX < -100 || 
            drawX > canvas.width + 100 || 
            drawY < -100 || 
            drawY > canvas.height + 100;
            
        // If far off screen, recycle the snowflake to a new position near the camera
        if (farOffScreen) {
            // Determine which edge to place the new snowflake based on the movement direction
            // Since we're moving diagonally down-left, place new flakes at top or right edges
            const edgeChoice = Math.random() > 0.5 ? 'top' : 'right';
            
            if (edgeChoice === 'top') {
                // Place at random position along top edge of camera view
                flake.x = cameraX + Math.random() * canvas.width;
                flake.y = cameraY - 10 - Math.random() * 20; // Slightly above camera view
            } else {
                // Place at random position along right edge of camera view
                flake.x = cameraX + canvas.width + 10 + Math.random() * 20; // Slightly right of camera view
                flake.y = cameraY + Math.random() * canvas.height;
            }
            
            // Randomize the snowflake properties slightly to keep the effect fresh
            flake.size = Math.random() * 2 + 1;
            flake.speedX = -(Math.random() * 0.5 + 1); // Always moves left
            flake.speedY = Math.random() * 0.5 + 1;    // Always moves down
            flake.opacity = Math.random() * 0.3 + 0.7;
        }
    }
    
    // Reset global alpha
    ctx.globalAlpha = 1.0;
}

// Helper function to create a snowflake near the camera
function createSnowflakeAtCamera() {
    // Determine start position - either above or to the right of camera view
    const edgeChoice = Math.random() > 0.5 ? 'top' : 'right';
    
    let x, y;
    
    if (edgeChoice === 'top') {
        // Place at random position along top edge of camera view
        x = cameraX + Math.random() * canvas.width;
        y = cameraY - 10 - Math.random() * 20; // Slightly above camera view
    } else {
        // Place at random position along right edge of camera view
        x = cameraX + canvas.width + 10 + Math.random() * 20; // Slightly right of camera view
        y = cameraY + Math.random() * canvas.height;
    }
    
    // For initial creation, also randomly place some flakes within the camera view
    if (Math.random() < 0.3) { // 30% chance
        x = cameraX + Math.random() * canvas.width;
        y = cameraY + Math.random() * canvas.height;
    }
    
    return {
        x: x,
        y: y,
        size: Math.random() * 2 + 1,
        // Diagonal speed components
        speedX: -(Math.random() * 0.5 + 1), // Always moves left (negative X)
        speedY: Math.random() * 0.5 + 1,    // Always moves down (positive Y)
        // Slight variance in opacity
        opacity: Math.random() * 0.3 + 0.7
    };
}
        
      function drawGameObjects(objects, sprite, fallbackColor) {
    objects.forEach(obj => {
        // Use our constants instead of default values
        const size = obj === gameObjects.trees ? 
            (obj.size || TREE_SIZE) : 
            (obj === gameObjects.rocks ? 
                (obj.size || ROCK_SIZE) : 
                (obj.size || 50));
        
        const drawX = obj.x - cameraX;
        const drawY = obj.y - cameraY;
        
        // Only draw if visible on screen (with buffer)
        if (
            drawX + size >= -100 &&
            drawX <= canvas.width + 100 &&
            drawY + size >= -100 &&
            drawY <= canvas.height + 100
        ) {
            // Try to draw sprite, fallback to color shape
            try {
                ctx.drawImage(sprite, drawX, drawY, size, size);
            } catch (e) {
                // Fallback to colored shape
                ctx.fillStyle = fallbackColor;
                
                if (objects === gameObjects.rocks) {
                    // Draw rock (irregular circle)
                    ctx.beginPath();
                    ctx.ellipse(drawX + size/2, drawY + size/2, size/2, size/2 * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (objects === gameObjects.trees) {
                    // Draw tree (triangle top with rectangle trunk)
                    ctx.fillStyle = '#8B4513'; // Brown trunk
                    ctx.fillRect(drawX + size/3, drawY + size/2, size/3, size/2);
                    
                    ctx.fillStyle = '#006400'; // Dark green foliage
                    ctx.beginPath();
                    ctx.moveTo(drawX, drawY + size/2);
                    ctx.lineTo(drawX + size/2, drawY);
                    ctx.lineTo(drawX + size, drawY + size/2);
                    ctx.fill();
                }
            }
        }
    });
}
        
        function drawCoins() {
            ctx.fillStyle = '#FFD700'; // Gold color
            
            gameObjects.coins.forEach(coin => {
                if (!coin.collected) {
                    const drawX = coin.x - cameraX;
                    const drawY = coin.y - cameraY;
                    
                    // Only draw if visible on screen
                    if (
                        drawX + COIN_SIZE >= 0 &&
                        drawX <= canvas.width &&
                        drawY + COIN_SIZE >= 0 &&
                        drawY <= canvas.height
                    ) {
                        // Try to draw sprite
                        try {
                            ctx.drawImage(coinSprite, drawX, drawY, COIN_SIZE, COIN_SIZE);
                        } catch (e) {
                            // Fallback to gold circle
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // coin detail (inner circle)
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.arc(drawX + COIN_SIZE/2, drawY + COIN_SIZE/2, COIN_SIZE/4, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = '#FFD700';
                        }
                        
                        // Animate coin bob up and down
                        coin.bobOffset = coin.bobOffset || 0;
                        coin.bobDirection = coin.bobDirection || 1;
                        coin.bobOffset += 0.05 * coin.bobDirection;
                        
                        if (coin.bobOffset > 5 || coin.bobOffset < 0) {
                            coin.bobDirection *= -1;
                        }
                    }
                }
            });
        }
   function drawPlayers() {
    for (const id in players) {
        const player = players[id];
        const drawX = player.x - cameraX;
        const drawY = player.y - cameraY;
        
        // Only draw if visible on screen
        if (
            drawX + PLAYER_SIZE >= 0 &&
            drawX <= canvas.width &&
            drawY + PLAYER_SIZE >= 0 &&
            drawY <= canvas.height
        ) {
            // Get the correct animation frame
            const frameIndex = getAnimationFrame(player);
            
            // Calculate source rectangle from sprite sheet
            const frameWidth = playerSpriteSheet.width / 20; // Width of one frame
            const sourceX = frameIndex * frameWidth;
            
            const visualScale = 2.25;
            const sizeIncrease = PLAYER_SIZE * (visualScale - 1);
            
            // Save the current context state
            ctx.save();
            
            // Add glow effect based on player's color
            const color = player.color || '#FF0000';
            const centerX = drawX + PLAYER_SIZE / 2;
            const centerY = drawY + PLAYER_SIZE / 2;
            
            // REDUCED: Smaller pulse and glow size
            const pulseTime = Date.now() * 0.005;
            const pulseScale = 1 + Math.sin(pulseTime) * 0.1; // Reduced from 0.15 to 0.1
            const glowSize = PLAYER_SIZE * 0.7 * pulseScale; // Reduced from 0.9 to 0.6
            
            // Create a radial gradient for the glow
            const gradient = ctx.createRadialGradient(
                centerX, centerY, glowSize * 0.1,
                centerX, centerY, glowSize
            );
            
            // Parse the hex color to rgba for transparency
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.5)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.2)`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            // Draw the glow
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add smaller glow for current player
            if (id === myId) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 15 * pulseScale; // Reduced from 20
                ctx.beginPath();
                ctx.arc(centerX, centerY, glowSize * 0.6, 0, Math.PI * 2); // Reduced from 0.7
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow for sprite drawing
            }
            
            // Restore the context state before drawing the sprite
            ctx.restore();
            
            // Draw character sprite with animation
            try {
                ctx.drawImage(
                    playerSpriteSheet,
                    sourceX, 0,             // Source position (x, y)
                    frameWidth, playerSpriteSheet.height, // Source dimensions
                    drawX - sizeIncrease/2, // Center the larger sprite
                    drawY - sizeIncrease/2, // Center the larger sprite
                    PLAYER_SIZE * visualScale, // Wider
                    PLAYER_SIZE * visualScale  // Taller
                );
            } catch (e) {
                console.error("Error drawing player sprite:", e);
            }
            
            // Draw player name and score
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000000';
            ctx.fillText(player.username, drawX + PLAYER_SIZE / 2, drawY - 10);
            
            if (player.score !== undefined) {
                ctx.fillText(`${player.score} pts`, drawX + PLAYER_SIZE / 2, drawY - 30);
            }
        }
    }
}
let currentFishingPond = null;
function findNearestPond(playerX, playerY) {
    let nearestPond = null;
    let shortestDistance = Infinity;
    
    for (const pond of gameObjects.ponds) {
        // Calculate distance from player center to pond center
        const playerCenterX = playerX + PLAYER_SIZE/2;
        const playerCenterY = playerY + PLAYER_SIZE/2;
        const pondCenterX = pond.x + pond.width/2;
        const pondCenterY = pond.y + pond.height/2;
        
        const distance = Math.sqrt(
            Math.pow(playerCenterX - pondCenterX, 2) + 
            Math.pow(playerCenterY - pondCenterY, 2)
        );
        
        if (distance < shortestDistance) {
            shortestDistance = distance;
            nearestPond = pond;
        }
    }
    
    return { pond: nearestPond, distance: shortestDistance };
}
function isPlayerOnIce(playerX, playerY, playerSize) {
    // Calculate player center coordinates
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    // Check each decorative lake (frozen)
    for (const lake of gameObjects.decorativeLakes) {
        // Calculate lake center and radiuses
        const lakeCenterX = lake.x + lake.width/2;
        const lakeCenterY = lake.y + lake.height/2;
        const lakeRadiusX = lake.width/2;
        const lakeRadiusY = lake.height/2;
        
        // Calculate normalized distance from center (elliptical equation)
        const dx = (playerCenterX - lakeCenterX) / lakeRadiusX;
        const dy = (playerCenterY - lakeCenterY) / lakeRadiusY;
        const distanceSquared = dx*dx + dy*dy;
        
        // If the player is inside the lake
        if (distanceSquared <= 1.0) {
            return true; // Player is on ice
        }
    }
    
    return false; // Not on ice
}
      function isPlayerInWater() {
    if (!myId || !players[myId]) return false;
    
    const player = players[myId];
    const playerCenter = {
        x: player.x + PLAYER_SIZE/2,
        y: player.y + PLAYER_SIZE/2
    };
    
    // Check each pond
    for (const pond of gameObjects.ponds) {
        // Use ellipse equation to check if player is in the pond
        const dx = (playerCenter.x - (pond.x + pond.width/2)) / (pond.width/2);
        const dy = (playerCenter.y - (pond.y + pond.height/2)) / (pond.height/2);
        
        if (dx*dx + dy*dy <= 1) {
            return true;
        }
    }
    
    return false;
}


// Start fishing minigame

function castFishingRod() {
    const player = players[myId];
    
    // Find the nearest pond for the bobber position
    const { pond, distance } = findNearestPond(player.x, player.y);
    if (!pond || distance > 250) {
        addChatMessage('System', "You're not close enough to a fishing spot!");
        return;
    }
    
    // Set fishing cast state
    isFishingCast = true;
    lastPondClicked = pond;
    
    
   
    
    // Play casting sound
    playSound('cast.mp3', 0.4);
    
    // Calculate bobber position - place it in the pond
    // Get player center coordinates
    const playerCenterX = player.x + PLAYER_SIZE/2;
    const playerCenterY = player.y + PLAYER_SIZE/2;
    
    // Get pond center coordinates
    const pondCenterX = pond.x + pond.width/2; 
    const pondCenterY = pond.y + pond.height/2;
    
    // Calculate position slightly away from center (so it's not exactly in the middle)
    // Create a vector from player to pond center
    const vectorX = pondCenterX - playerCenterX;
    const vectorY = pondCenterY - playerCenterY;
    
    // Normalize this vector
    const length = Math.sqrt(vectorX * vectorX + vectorY * vectorY);
    const normalizedX = vectorX / length;
    const normalizedY = vectorY / length;
    
    // Calculate bobber position - a bit toward the player from center
    const offsetRatio = 0.7; // 70% of the way from player to center
    const bobberX = playerCenterX + normalizedX * length * offsetRatio;
    const bobberY = playerCenterY + normalizedY * length * offsetRatio;
    
    // Store bobber data
    fishingBobber = {
        x: bobberX,
        y: bobberY,
        state: 'waiting', // Can be 'waiting', 'biting', or 'missed'
        ripples: [],
        lastRippleTime: Date.now(),
        animationOffset: 0
    };
    
    // Show message
    //addChatMessage('System', "Fishing rod cast! Watch the bobber closely...");
    
    // Set a random timeout for when fish will bite (between 3-8 seconds)
    const biteTime = 3000 + Math.random() * 5000;
    fishingBiteTimeout = setTimeout(() => {
        // Fish is biting!
        if (fishingBobber) {
            fishingBobber.state = 'biting';
            playSound('splash.mp3', 0.5);
            
            // Create multiple ripples
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    if (fishingBobber) { // Check if still fishing
                        fishingBobber.ripples.push({
                            radius: 5,
                            opacity: 1.0
                        });
                    }
                }, i * 150); // Stagger ripples slightly
            }
            
            // Set timeout for missed fish if not clicked within 2 seconds
            fishingFailTimeout = setTimeout(() => {
                if (isFishingCast && fishingBobber) {
                    fishingBobber.state = 'missed';
                    playSound('missedFish.mp3', 0.4);
                  //  addChatMessage('System', "The fish got away! You weren't fast enough.");
                    
                    // Wait 2 seconds then reset
                    setTimeout(() => {
                        resetFishing();
                    }, 2000);
                }
            }, 2000);
        }
    }, biteTime);
}

function startFishing() {
    if (isFishing) return;
    
    // Use the pond we already stored when casting
    currentFishingPond = lastPondClicked;
    
    isFishing = true;
    fishingProgress = 0;
    fishingSuccess = false;
    fishingResult = null;
    
    // Play sound effect
   // playSound('splash.mp3', 0.3);
    // Tell server we've used bait
    socket.emit('update_bait', { bait: currentBait });
    // Use bait
    currentBait--;
    updateBaitDisplay();
    
    // Start fishing minigame
    fishingTimeout = setTimeout(() => {
        if (isFishing) {
            // If player didn't click in time, fishing fails
            isFishing = false;
            currentFishingPond = null; // Reset fishing pond
            playSound('missedFish.mp3', 1);
            addChatMessage('System', 'You missed your chance! The fish got away.');
        }
    }, 3000); // 3 seconds to click
}
function resetFishing() {
    isFishingCast = false;
    fishingBobber = null;
    
    if (fishingBiteTimeout) {
        clearTimeout(fishingBiteTimeout);
        fishingBiteTimeout = null;
    }
    
    if (fishingFailTimeout) {
        clearTimeout(fishingFailTimeout);
        fishingFailTimeout = null;
    }
    
    lastPondClicked = null;
}
// Handle fishing progress
function drawFishingProgress() {
    if (!isFishing && !isFishingCast) return;
    
    const player = players[myId];
    const drawX = player.x - cameraX;
    const drawY = player.y - cameraY;
    
    // Get pond to target
    const pond = isFishingCast ? lastPondClicked : currentFishingPond;
    
    if (pond) {
        // Get player center coordinates
        const playerCenterX = player.x + PLAYER_SIZE/2;
        const playerCenterY = player.y + PLAYER_SIZE/2;
        
        // Draw fishing line from player to bobber or pond center
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(drawX + PLAYER_SIZE/2, drawY + PLAYER_SIZE/2);
        
        if (isFishingCast && fishingBobber) {
            // Draw line to bobber
            const bobberDrawX = fishingBobber.x - cameraX;
            const bobberDrawY = fishingBobber.y - cameraY;
            ctx.lineTo(bobberDrawX, bobberDrawY);
        } else {
            // Draw line to pond center (original behavior)
            const pondCenterX = pond.x + pond.width/2 - cameraX;
            const pondCenterY = pond.y + pond.height/2 - cameraY;
            ctx.lineTo(pondCenterX, pondCenterY);
        }
        ctx.stroke();
        
        if (isFishingCast && fishingBobber) {
            // Draw bobber
            const bobberDrawX = fishingBobber.x - cameraX;
            const bobberDrawY = fishingBobber.y - cameraY;
            
            // slight bobbing animation
            const time = Date.now() * 0.002;
            const bobOffset = Math.sin(time) * 2;
            
            // Modify bobbing based on state
            let yOffset = bobOffset;
            if (fishingBobber.state === 'biting') {
                // Make the bobber bounce more when biting
                fishingBobber.animationOffset += 0.2;
                if (fishingBobber.animationOffset > Math.PI * 2) {
                    fishingBobber.animationOffset = 0;
                }
                yOffset = Math.sin(fishingBobber.animationOffset * 5) * 5;
            } else if (fishingBobber.state === 'missed') {
                // Make it look like it was pulled under briefly
                yOffset = Math.sin(time * 3) * 1 + 3; // Smaller movement but lower in water
            }
            
            // Draw bobber shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(bobberDrawX, bobberDrawY + 5, 6, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw bobber (red and white)
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(bobberDrawX, bobberDrawY + yOffset, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(bobberDrawX, bobberDrawY + yOffset - 2, 4, 0, Math.PI, true);
            ctx.fill();
            
            // Draw ripples
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 1;
            
            // Automatically add gentle ripples occasionally
            const now = Date.now();
            if (now - fishingBobber.lastRippleTime > 2000 + Math.random() * 1000) {
                fishingBobber.ripples.push({
                    radius: 5,
                    opacity: 0.5
                });
                fishingBobber.lastRippleTime = now;
            }
            
            // Draw and update all ripples
            for (let i = fishingBobber.ripples.length - 1; i >= 0; i--) {
                const ripple = fishingBobber.ripples[i];
                
                ctx.globalAlpha = ripple.opacity;
                ctx.beginPath();
                ctx.arc(bobberDrawX, bobberDrawY + yOffset + 3, ripple.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                
                // Expand ripples
                ripple.radius += 0.5;
                ripple.opacity -= 0.02;
                
                // Remove faded ripples
                if (ripple.opacity <= 0) {
                    fishingBobber.ripples.splice(i, 1);
                }
            }
            
            // Instructions if fish is biting
            if (fishingBobber.state === 'biting') {
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('CLICK NOW!', bobberDrawX, bobberDrawY - 20);
            }
        }
    }
    
    // If in fishing mode (after bite), show the original progress bar
    if (isFishing) {
        // Draw fishing progress bar (Your existing code)
        const progressBarWidth = 200;
        const progressBarHeight = 30;
        const progressBarX = (canvas.width - progressBarWidth) / 2;
        const progressBarY = canvas.height - 100;
        
        fishingProgress = (Date.now() % 1000) / 1000;
        
        // Draw progress bar background
        ctx.fillStyle = '#332727';
        ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
        
        // Draw success zone
        const successZoneWidth = progressBarWidth * 0.3;
        const timeOffset = Math.floor(Date.now() / 3000);
        const successZonePosition = ((Math.sin(timeOffset) + 1) / 2) * (progressBarWidth - successZoneWidth);
        const successZoneStart = progressBarX + successZonePosition;
        
        ctx.fillStyle = '#8bf0a8';
        ctx.fillRect(successZoneStart, progressBarY, successZoneWidth, progressBarHeight);
        
        // Draw progress indicator
        const indicatorPos = progressBarX + progressBarWidth * fishingProgress;
        ctx.fillStyle = '#c23636';
        ctx.fillRect(indicatorPos - 2, progressBarY, 4, progressBarHeight);
        
        // Check if in success zone
        const inSuccessZone = 
            indicatorPos >= successZoneStart && 
            indicatorPos <= successZoneStart + successZoneWidth;
        
        if (inSuccessZone) {
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('CLICK NOW!', canvas.width / 2, progressBarY - 10);
        }
    }
}
// Handle caught fish
function catchFish(success) {
    if (!isFishing) return;
    
    // Clear fishing timeout
    clearTimeout(fishingTimeout);
    isFishing = false;
    currentFishingPond = null;
    resetFishing(); // Also reset the casting state
    
    if (success) {
        // Request a fish from the server
        socket.emit('catch_fish');
        addChatMessage('System', 'You got a bite! Waiting to see what you caught...');
        playSound('catch.mp3', 0.4);
    } else {
        addChatMessage('System', 'You missed! Better luck next time.');
        playSound('missedFish.mp3', 1);
    }
}

// Render fish inventory
function toggleFishInventory() {
    isInventoryOpen = !isInventoryOpen;
    
    if (isInventoryOpen) {
        // Request latest fish inventory from server
        socket.emit('get_fish_inventory');
    }
}

// Draw the fish inventory screen
function drawFishInventory() {
    // Semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Inventory panel
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Draw panel background
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    
    // Panel title
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    
    // Display different title based on viewing mode
    if (viewingOtherPlayer) {
        ctx.fillText(`${viewingPlayerName}'s Fish Collection`, panelX + panelWidth/2, panelY + 40);
    } else {
        ctx.fillText('Fish Collection', panelX + panelWidth/2, panelY + 40);
    }
    
    // Add search input
    const searchInputWidth = 200;
    const searchButtonWidth = 80;
    const searchInputHeight = 30;
    
    ctx.fillStyle = '#EEEEEE';
    ctx.fillRect(panelX + 30, panelY + 60, searchInputWidth, searchInputHeight);
    ctx.strokeStyle = '#AAAAAA';
    ctx.strokeRect(panelX + 30, panelY + 60, searchInputWidth, searchInputHeight);
    
    // Add search button
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(panelX + 30 + searchInputWidth + 10, panelY + 60, searchButtonWidth, searchInputHeight);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Search', panelX + 30 + searchInputWidth + 10 + searchButtonWidth/2, panelY + 60 + searchInputHeight/2 + 5);
    
    // Add search placeholder/text
    ctx.fillStyle = '#888888';
    ctx.textAlign = 'left';
    ctx.fillText(currentSearchQuery || 'Enter player name...', panelX + 40, panelY + 60 + searchInputHeight/2 + 5);
    
    // Back button if viewing other player's inventory
    if (viewingOtherPlayer) {
        ctx.fillStyle = '#2196F3';
        ctx.fillRect(panelX + panelWidth - 150, panelY + 60, 100, searchInputHeight);
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.fillText('Back to Mine', panelX + panelWidth - 100, panelY + 60 + searchInputHeight/2 + 5);
    }
    
    // Close button
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(panelX + panelWidth - 30, panelY + 10, 20, 20);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('×', panelX + panelWidth - 20, panelY + 25);
    
    // Draw fish section
    // Check if we have fish to display
    if (fishInventory.length === 0) {
        ctx.fillStyle = '#666666';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        if (viewingOtherPlayer) {
            ctx.fillText(`${viewingPlayerName} hasn't caught any fish yet.`, panelX + panelWidth/2, panelY + panelHeight/2);
        } else {
            ctx.fillText('No fish caught yet. Go fishing!', panelX + panelWidth/2, panelY + panelHeight/2);
        }
    } else {
        // Display fish in a grid with scrolling
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const startX = panelX + (panelWidth - (columns * itemSize)) / 2;
        
        // Set up scrollable area
        const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
        const viewportHeight = panelHeight - 180; // Space for title, search, and stats
        const viewportY = panelY + 100; // Start below search box
        
        // Create clipPath for the scrollable area
        ctx.save();
        ctx.beginPath();
        ctx.rect(panelX + 10, viewportY, panelWidth - 20, viewportHeight);
        ctx.clip();
        
        // Apply scroll offset
        const scrollY = viewportY - inventoryScrollOffset;
        
        deleteButtonPositions = [];


        // Draw fish items
        fishInventory.forEach((fish, index) => {
            const col = index % columns;
            const row = Math.floor(index / columns);
            const x = startX + col * itemSize;
            const y = scrollY + row * itemSize;
            
            // Only draw if it would be visible (optimization)
            if (y + itemSize >= viewportY && y <= viewportY + viewportHeight) {
                // Draw fish slot background
                ctx.fillStyle = '#F0F0F0';
                ctx.fillRect(x, y, itemSize - 10, itemSize - 10);
                
                // Draw fish sprite if available
                try {
                    const fishSprite = fishSprites[`fish${fish.typeId}`];
                    ctx.drawImage(fishSprite, x + 10, y + 10, itemSize - 30, itemSize - 50);
                } catch (e) {
                    // Fallback to colored rectangle if sprite not available
                    ctx.fillStyle = getFishColor(fish.typeId);
                    ctx.fillRect(x + 10, y + 10, itemSize - 30, itemSize - 50);
                }
                
                // Draw fish details
                ctx.fillStyle = '#333333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(fish.name, x + (itemSize - 10)/2, y + itemSize - 35);
                ctx.fillText(`${fish.size} cm`, x + (itemSize - 10)/2, y + itemSize - 20);
                
                // Draw rarity indicator
                const rarityColor = getRarityColor(fish.rarity);
                ctx.fillStyle = rarityColor;
                ctx.fillRect(x + (itemSize - 40)/2, y + itemSize - 15, 40, 10);
                
                // Add delete button for each fish ONLY for own inventory (not when viewing others)
                if (!viewingOtherPlayer) {
                    ctx.fillStyle = '#FF3B30';
                    ctx.fillRect(x + itemSize - 25, y + 5, 15, 15);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('×', x + itemSize - 17, y + 15);
                    
                    // Store button coordinates for click detection
                    deleteButtonPositions.push({
        x: x + itemSize - 25,
        y: y + 5,  // This is already the actual Y position on screen
        width: 15,
        height: 15,
        fishId: fish.id,
        fishName: fish.name,
        fishRarity: fish.rarity
    });
                }
            }
        });
        
        // Restore the context to remove clip
        ctx.restore();
        
        // Draw scrollbar if needed
        if (contentHeight > viewportHeight) {
            const scrollbarHeight = (viewportHeight / contentHeight) * viewportHeight;
            const scrollbarPosition = (inventoryScrollOffset / (contentHeight - viewportHeight)) * (viewportHeight - scrollbarHeight);
            
            // Draw scroll track
            ctx.fillStyle = '#EEEEEE';
            ctx.fillRect(panelX + panelWidth - 20, viewportY, 10, viewportHeight);
            
            // Draw scrollbar
            ctx.fillStyle = '#BBBBBB';
            ctx.fillRect(panelX + panelWidth - 20, viewportY + scrollbarPosition, 10, scrollbarHeight);
        }
    }
    
    // Stats section
    const statsY = panelY + panelHeight - 60;
    
    ctx.fillStyle = '#333333';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    
    // Calculate stats
    const totalFish = fishInventory.length;
    const uniqueTypes = new Set(fishInventory.map(fish => fish.typeId)).size;
    const largestFish = fishInventory.length > 0 ? 
        Math.max(...fishInventory.map(fish => fish.size)) : 0;
    
    ctx.fillText(`Total Caught: ${totalFish}`, panelX + 30, statsY);
    ctx.fillText(`Unique Types: ${uniqueTypes}/16`, panelX + 30, statsY + 25);
    ctx.fillText(`Largest Fish: ${largestFish} cm`, panelX + panelWidth - 200, statsY);
    
 if (viewingFishDetails && selectedFish) {
        drawFishDetails();
    }
  
    // Handle clicks in inventory
    canvas.onclick = handleInventoryClick;
}

//  Add new variables to track whose inventory we're viewing
let viewingOtherPlayer = false;
let viewingPlayerName = '';
let currentSearchQuery = '';
let selectedFish = null;
let viewingFishDetails = false;
// Update click handling for search functionality
function handleInventoryClick(e) {
    if (!isInventoryOpen) return;
    
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
 if (viewingFishDetails) {
        // Check if close button clicked
        const detailWidth = Math.min(400, canvas.width - 100);
        const detailHeight = Math.min(500, canvas.height - 100);
        const detailX = (canvas.width - detailWidth) / 2;
        const detailY = (canvas.height - detailHeight) / 2;
        
        if (canvasX >= detailX + detailWidth - 30 && 
            canvasX <= detailX + detailWidth - 10 &&
            canvasY >= detailY + 10 && 
            canvasY <= detailY + 30) {
            // Close button clicked
            viewingFishDetails = false;
            selectedFish = null;
            drawFishInventory(); // Redraw inventory
            return;
        }
        
        // Check if clicked anywhere outside the detail panel to close
        if (canvasX < detailX || canvasX > detailX + detailWidth ||
            canvasY < detailY || canvasY > detailY + detailHeight) {
            viewingFishDetails = false;
            selectedFish = null;
            drawFishInventory(); // Redraw inventory
            return;
        }
        
        return; // Don't process other inventory clicks while viewing details
    }

    // Check if close button clicked
    if (
        canvasX >= panelX + panelWidth - 30 && 
        canvasX <= panelX + panelWidth - 10 &&
        canvasY >= panelY + 10 && 
        canvasY <= panelY + 30
    ) {
        isInventoryOpen = false;
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        canvas.onclick = null; // Remove click handler
        return;
    }
    // Check if a fish item was clicked (add this new section)
    if (!viewingFishDetails && fishInventory.length > 0) {
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const startX = panelX + (panelWidth - (columns * itemSize)) / 2;
        const viewportY = panelY + 100;
        const scrollY = viewportY - inventoryScrollOffset;
        
        for (let i = 0; i < fishInventory.length; i++) {
            const col = i % columns;
            const row = Math.floor(i / columns);
            const x = startX + col * itemSize;
            const y = scrollY + row * itemSize;
            
            // Check if click is within this fish's area
            if (canvasX >= x && canvasX <= x + itemSize - 10 &&
                canvasY >= y && canvasY <= y + itemSize - 10) {
                
                // Avoid triggering on delete button area
                const isDeleteButton = !viewingOtherPlayer && 
                    canvasX >= x + itemSize - 25 && 
                    canvasX <= x + itemSize - 10 &&
                    canvasY >= y + 5 && 
                    canvasY <= y + 20;
                
                if (!isDeleteButton) {
                    // Show fish details!
                    selectedFish = fishInventory[i];
                    viewingFishDetails = true;
                    //playSound('flip-page.mp3', 0.2);
                    drawFishDetails();
                    return;
                }
            }
        }
    }
    // Search input area dimensions
    const searchInputWidth = 200;
    const searchButtonWidth = 80;
    const searchInputHeight = 30;
    
    // Check if search input clicked
    if (
        canvasX >= panelX + 30 && 
        canvasX <= panelX + 30 + searchInputWidth &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        // Show prompt for player name
        const playerName = prompt("Enter player name to search:", currentSearchQuery || "");
        if (playerName && playerName.trim()) {
            currentSearchQuery = playerName.trim();
            // Request other player's fish inventory
            socket.emit('search_player_fish', { playerName: currentSearchQuery });
            
            // Show loading message
            addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
        }
        return;
    }
    
    // Check if search button clicked
    if (
        canvasX >= panelX + 30 + searchInputWidth + 10 && 
        canvasX <= panelX + 30 + searchInputWidth + 10 + searchButtonWidth &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        if (currentSearchQuery) {
            // Request other player's fish inventory
            socket.emit('search_player_fish', { playerName: currentSearchQuery });
            
            // Show loading message
            addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
        } else {
            // Prompt for player name if empty
            const playerName = prompt("Enter player name to search:");
            if (playerName && playerName.trim()) {
                currentSearchQuery = playerName.trim();
                socket.emit('search_player_fish', { playerName: currentSearchQuery });
                
                // Show loading message
                addChatMessage('System', `Searching for ${currentSearchQuery}'s fish collection...`);
            }
        }
        return;
    }
    
    // Check if back button clicked (when viewing other player's inventory)
    if (
        viewingOtherPlayer &&
        canvasX >= panelX + panelWidth - 150 && 
        canvasX <= panelX + panelWidth - 50 &&
        canvasY >= panelY + 60 && 
        canvasY <= panelY + 60 + searchInputHeight
    ) {
        // Reset to own inventory
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        inventoryScrollOffset = 0;
        socket.emit('get_fish_inventory');
        return;
    }
    
    // Handle delete button clicks only if viewing own inventory
    if (!viewingOtherPlayer) {
        for (const button of deleteButtonPositions) {
            if (
                canvasX >= button.x &&
                canvasX <= button.x + button.width &&
                canvasY >= button.y &&
                canvasY <= button.y + button.height
            ) {
                // Show confirmation dialog
                if (confirm(`Are you sure you want to remove this ${button.fishRarity} ${button.fishName}?`)) {
                    deleteFish(button.fishId);
                }
                return;
            }
        }
    }
    
    // Handle scrollbar clicks
    const viewportHeight = panelHeight - 180;
    const viewportY = panelY + 100;
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    
    if (contentHeight > viewportHeight && 
        canvasX >= panelX + panelWidth - 20 && 
        canvasX <= panelX + panelWidth - 10 &&
        canvasY >= viewportY && 
        canvasY <= viewportY + viewportHeight) {
        
        // Calculate new scroll position based on click position
        const clickPosition = (canvasY - viewportY) / viewportHeight;
        inventoryScrollOffset = clickPosition * (contentHeight - viewportHeight);
        
        // Redraw inventory with new scroll position
        drawFishInventory();
        return;
    }
}
function drawFishDetails() {
    if (!viewingFishDetails || !selectedFish) return;
    
    // Create semi-transparent background overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Create detail panel
    const panelWidth = Math.min(400, canvas.width - 100);
    const panelHeight = Math.min(500, canvas.height - 100);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Draw panel background with subtle border
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    ctx.strokeStyle = getRarityColor(selectedFish.rarity);
    ctx.lineWidth = 4;
    ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
    
    // Draw close button
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(panelX + panelWidth - 30, panelY + 10, 20, 20);
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('×', panelX + panelWidth - 20, panelY + 25);
    
    // Draw fish name as title
    ctx.fillStyle = '#333333';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(selectedFish.name, panelX + panelWidth/2, panelY + 40);
    
    // Draw rarity with appropriate color
    ctx.fillStyle = getRarityColor(selectedFish.rarity);
    ctx.font = 'bold 20px Arial';
    ctx.fillText(selectedFish.rarity, panelX + panelWidth/2, panelY + 70);
    
    // Draw fish image - large and centered
    const fishImgSize = Math.min(panelWidth * 0.8, 200);
    const fishImgX = panelX + (panelWidth - fishImgSize) / 2;
    const fishImgY = panelY + 90;
    
    try {
        const fishSprite = fishSprites[`fish${selectedFish.typeId}`];
        ctx.drawImage(fishSprite, fishImgX, fishImgY, fishImgSize, fishImgSize * 0.8);
    } catch (e) {
        // Fallback to colored shape if sprite fails
        ctx.fillStyle = getFishColor(selectedFish.typeId);
        ctx.fillRect(fishImgX, fishImgY, fishImgSize, fishImgSize * 0.8);
        
        // Add fish shape details
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.ellipse(
            fishImgX + fishImgSize * 0.8, 
            fishImgY + fishImgSize * 0.4, 
            fishImgSize * 0.15, 
            fishImgSize * 0.3, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // Draw fish details
    const detailStartY = fishImgY + fishImgSize * 0.8 + 20;
    ctx.fillStyle = '#333333';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    
    // Show size with "ruler" visualization
    ctx.fillText(`Size: ${selectedFish.size} cm`, panelX + 30, detailStartY);
    const fishSizeRanges = {
        1: {name: "Common Carp", min: 20, max: 45},
        2: {name: "Sunfish", min: 10, max: 20},
        3: {name: "Catfish", min: 25, max: 60},
        4: {name: "Bass", min: 20, max: 40},
        5: {name: "Rainbow Trout", min: 15, max: 35},
        6: {name: "Pike", min: 40, max: 80},
        7: {name: "Salmon", min: 30, max: 70},
        8: {name: "Golden Perch", min: 25, max: 50},
        9: {name: "Sturgeon", min: 60, max: 120},
        10: {name: "Mythical Koi", min: 50, max: 100},
        11: {name: "Kyogre", min: 400, max: 450},
        12: {name: "Manaphy", min: 25, max: 30},
        13: {name: "Golden Magikarp", min: 50, max: 90},
        14: {name: "Shiny Gyarados", min: 500, max: 700},
        15: {name: "Wailord", min: 1450, max: 2000},
        16: {name: "Lapras", min: 150, max: 300}
    };
    // Draw size visualization (ruler)
    // Get size range for this fish type
    const fishType = fishSizeRanges[selectedFish.typeId] || {min: 10, max: 100};
    
    // Draw size visualization (ruler)
    const rulerWidth = panelWidth - 60;
    const rulerY = detailStartY + 20;
    
    // Calculate the size range to show (min to max of this fish type)
    const minPossibleSize = fishType.min;
    const maxPossibleSize = fishType.max;
    const sizeRange = maxPossibleSize - minPossibleSize;
    
    // Calculate how far along the ruler this fish's size is
    const sizePosition = (selectedFish.size - minPossibleSize) / sizeRange;
    const cappedSizePosition = Math.max(0, Math.min(1, sizePosition)); // Ensure between 0-1
    
    // Draw ruler background
    ctx.fillStyle = '#EEEEEE';
    ctx.fillRect(panelX + 30, rulerY, rulerWidth, 20);
    
    // Draw size indicator
     ctx.fillStyle = getRarityColor(selectedFish.rarity);
    ctx.fillRect(panelX + 30, rulerY, rulerWidth * cappedSizePosition, 20);
    
    // Draw ruler markings
    ctx.strokeStyle = '#777777';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const markX = panelX + 30 + (rulerWidth / 10) * i;
        ctx.beginPath();
        ctx.moveTo(markX, rulerY);
        ctx.lineTo(markX, rulerY + (i % 5 === 0 ? 15 : 10));
        ctx.stroke();
    }
    
    // Draw size text on the ruler
    ctx.fillStyle = '#000000';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
   ctx.fillText(`${minPossibleSize} cm`, panelX + 30, rulerY + 35);
    ctx.fillText(`${Math.round(maxPossibleSize)} cm`, panelX + 30 + rulerWidth, rulerY + 35);

    //fail size context
 ctx.fillStyle = '#555555';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    const sizePercentage = Math.round(cappedSizePosition * 100);
    const sizeMessage = sizePercentage < 30 ? "Small specimen" : 
                       sizePercentage < 70 ? "Average size" : 
                       sizePercentage < 90 ? "Large specimen" : "Exceptional size!";
    ctx.fillText(sizeMessage, panelX + panelWidth/2, rulerY + 35);

    // Draw catch date if available
    if (selectedFish.caughtAt) {
        const catchDate = new Date(selectedFish.caughtAt);
        const formattedDate = `${catchDate.toLocaleDateString()} ${catchDate.toLocaleTimeString()}`;
        ctx.fillStyle = '#666666';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Caught on: ${formattedDate}`, panelX + panelWidth/2, rulerY + 65);
    }
    
    // Add fish description based on type and rarity
     const fishDescriptions = {
        1: "The Common Carp is a hardy freshwater fish known for its resilience. These omnivores can survive in waters where other fish cannot, thanks to their ability to tolerate low oxygen levels and pollutants.",
        2: "The Sunfish's vibrant colors light up any collection. Despite their small size, these aggressive little predators will fiercely defend their territory against much larger intruders.",
        3: "Catfish are known for their distinctive whisker-like barbels used to taste and feel in murky waters. As bottom-feeders, they patrol the lake floor after dark searching for food.",
        4: "The Bass is prized for its fighting spirit when caught. An apex predator in many lakes, its powerful jaws can swallow prey nearly half its own size.",
        5: "The Rainbow Trout features a stunning spectrum of colors along its side. These agile swimmers prefer cool, oxygen-rich waters and are known for their spectacular leaping ability.",
        6: "The Pike is a fearsome ambush predator with a torpedo-shaped body built for speed. Ancient folklore claims their sharp teeth and aggressive nature make them the 'water wolves'.",
        7: "The Salmon's remarkable homing instinct allows it to return to its birthplace to spawn, sometimes traveling thousands of miles through changing salinity. Their determination is legendary.",
        8: "The Golden Perch's scales shimmer like coins in the sunlight. Indigenous legends say possessing one brings wealth and prosperity to the fortunate angler.",
        9: "The Sturgeon is a living fossil, virtually unchanged for over 200 million years. These ancient behemoths can live over 100 years and grow to immense sizes.",
        10: "The Mythical Koi represents perseverance in Eastern mythology. It's said that a koi that climbs the waterfall of Dragon Gate will transform into a mighty dragon.",
        11: "Kyogre is a legendary creature said to have expanded the seas. Ancient carvings depict it commanding storms and tsunamis with a mere thought.",
        12: "Manaphy is called the 'Prince of the Sea' in old maritime tales. Sailors claim its presence brings calm waters and favorable winds to troubled voyages.",
        13: "The Golden Magikarp appears useless at first glance, but old fishermen whisper that with enough patience, it holds the potential for incredible transformation.",
        14: "The Shiny Gyarados is the stuff of nightmares—its crimson hue marks it as a rare mutation fueled by raw rage. Some believe it appears only in times of chaos.",
        15: "Wailord, the colossal titan of the seas, is often mistaken for an island by passing ships. Its deep calls echo for miles, rumbling like underwater thunder.",
        16: "Lapras is a gentle giant known to ferry travelers across treacherous waters. Tales speak of its intelligence and hauntingly beautiful songs echoing under moonlight."
    };
      const description = fishDescriptions[selectedFish.typeId] || "A mysterious fish about which little is known.";
    
    
    // Draw description text with word wrapping
    ctx.fillStyle = '#333333';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    
    const maxWidth = panelWidth - 60;
    const words = description.split(' ');
    let line = '';
    let y = rulerY + 100;
    
    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, panelX + 30, y);
            line = words[n] + ' ';
            y += 25;
        }
        else {
            line = testLine;
        }
    }
    ctx.fillText(line, panelX + 30, y);
}
// Variables for scroll handling
let inventoryScrollOffset = 0;
let isDraggingScrollbar = false;
let lastMouseY = 0;

// Add mouse wheel handler for scrolling the inventory
function handleInventoryScroll(e) {
    if (!isInventoryOpen) return;
    
    e.preventDefault();
    
    // Get panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Get mouse position relative to canvas
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Check if mouse is over the inventory panel
    if (
        mouseX >= panelX && 
        mouseX <= panelX + panelWidth &&
        mouseY >= panelY && 
        mouseY <= panelY + panelHeight
    ) {
        // Calculate scroll bounds
        const itemSize = 100;
        const columns = Math.floor((panelWidth - 40) / itemSize);
        const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
        const viewportHeight = panelHeight - 150;
        
        if (contentHeight > viewportHeight) {
            // Update scroll offset based on wheel direction
            inventoryScrollOffset += e.deltaY * 0.5; // Adjust scroll speed
            
            // Clamp scroll offset to valid range
            inventoryScrollOffset = Math.max(0, Math.min(contentHeight - viewportHeight, inventoryScrollOffset));
            
            // Redraw inventory with new scroll position
            drawFishInventory();
        }
    }
}

// Add mouse down handler for dragging the scrollbar
function handleMouseDown(e) {
    if (!isInventoryOpen) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    const panelX = (canvas.width - panelWidth) / 2;
    const panelY = (canvas.height - panelHeight) / 2;
    
    // Check if scrollbar is clicked
    const viewportHeight = panelHeight - 150;
    if (
        mouseX >= panelX + panelWidth - 20 && 
        mouseX <= panelX + panelWidth - 10 &&
        mouseY >= panelY + 70 && 
        mouseY <= panelY + 70 + viewportHeight
    ) {
        isDraggingScrollbar = true;
        lastMouseY = mouseY;
    }
}

// Add mouse move handler for dragging the scrollbar
function handleMouseMove(e) {
    if (!isInventoryOpen || !isDraggingScrollbar) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.left;
    
    // Calculate mouse movement
    const deltaY = mouseY - lastMouseY;
    lastMouseY = mouseY;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    
    // Calculate scroll bounds
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    const viewportHeight = panelHeight - 150;
    
    if (contentHeight > viewportHeight) {
        // Update scroll offset based on drag amount
        const scrollRatio = contentHeight / viewportHeight;
        inventoryScrollOffset += deltaY * scrollRatio;
        
        // Clamp scroll offset to valid range
        inventoryScrollOffset = Math.max(0, Math.min(contentHeight - viewportHeight, inventoryScrollOffset));
        
        // Redraw inventory with new scroll position
        drawFishInventory();
    }
}

// Add mouse up handler to end scrollbar dragging
function handleMouseUp() {
    isDraggingScrollbar = false;
}

// Initialize event listeners for scrolling
function initScrollListeners() {
    canvas.addEventListener('wheel', handleInventoryScroll, { passive: false });
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
}
function setupSocketHandlers() {
    // Make sure this is added alongside your other socket.on handlers
    socket.on('other_player_fish', (data) => {
        if (data.error) {
            // Show error message if player not found
            addChatMessage('System', data.error);
        } else {
            // Switch to viewing other player's fish
            viewingOtherPlayer = true;
            viewingPlayerName = data.playerName;
            fishInventory = data.fishes;
            inventoryScrollOffset = 0; // Reset scroll position
            
            // Sort inventory by rarity and size
            fishInventory.sort((a, b) => {
                const rarityOrder = { 'Common': 0, 'Uncommon': 1, 'Rare': 2, 'Epic': 3, 'Legendary': 4, 'Mythical': 5 };
                return rarityOrder[b.rarity] - rarityOrder[a.rarity] || b.size - a.size;
            });
            
            // Notify the user
            addChatMessage('System', `Viewing ${data.playerName}'s fish collection.`);
            
            // Redraw inventory
            drawFishInventory();
        }
    });
    
// Handle individual player movements (more efficient than full game state)
socket.on('player_move', (data) => {
    if (data.id === myId) return; // Ignore updates about ourselves
    
    if (players[data.id]) {
        // Add movement to buffer for interpolation
        positionBuffer.push({
            id: data.id,
            fromX: players[data.id].x,
            fromY: players[data.id].y,
            toX: data.x,
            toY: data.y,
            timestamp: Date.now(),
            progress: 0
        });
        
        // Limit buffer size
        if (positionBuffer.length > MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
        
        // Immediately update the target position
        players[data.id].targetX = data.x;
        players[data.id].targetY = data.y;
    }
});

// Handle position corrections from server
socket.on('position_correction', (data) => {
    if (!myId || !players[myId]) return;
    
    // Calculate server-client time difference
    const serverTime = data.timestamp;
    const clientTime = Date.now();
    const latency = clientTime - serverTime;
    
    // Get distance from current position to corrected position
    const dx = data.x - players[myId].x;
    const dy = data.y - players[myId].y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    // Only apply correction if significant and not during user input
    if (distance > 50 && !isAnyKeyPressed()) {
        // Smooth correction over time
        const correctionStartTime = Date.now();
        const correctionDuration = 200; // ms
        
        function applySmoothCorrection() {
            const now = Date.now();
            const elapsed = now - correctionStartTime;
            const progress = Math.min(elapsed / correctionDuration, 1);
            
            // Ease-out function for smoother correction
            const t = 1 - Math.pow(1 - progress, 3);
            
            // Apply partial correction
            players[myId].x = players[myId].x + dx * t;
            players[myId].y = players[myId].y + dy * t;
            
            if (progress < 1) {
                requestAnimationFrame(applySmoothCorrection);
            }
        }
        
        applySmoothCorrection();
    }
});
}
function isAnyKeyPressed() {
    return keys.up || keys.down || keys.left || keys.right;
}
// Update toggleFishInventory to initialize scroll position
function toggleFishInventory() {
    isInventoryOpen = !isInventoryOpen;
    
    if (isInventoryOpen) {
        // Reset state when opening inventory
        inventoryScrollOffset = 0;
        viewingOtherPlayer = false;
        viewingPlayerName = '';
        currentSearchQuery = '';
        
        // Request latest fish inventory from server
        socket.emit('get_fish_inventory');
        
        // Make sure scroll listeners are initialized
        initScrollListeners();
    } else {
        // Clean up when closing inventory
        canvas.onclick = null;
    }
}

// Add keyboard controls for inventory scrolling
window.addEventListener('keydown', (e) => {
    if (!isInventoryOpen) return;
    
    // Calculate panel dimensions
    const panelWidth = Math.min(canvas.width - 100, 800);
    const panelHeight = Math.min(canvas.height - 100, 600);
    
    // Calculate scroll bounds
    const itemSize = 100;
    const columns = Math.floor((panelWidth - 40) / itemSize);
    const contentHeight = Math.ceil(fishInventory.length / columns) * itemSize;
    const viewportHeight = panelHeight - 150;
    
    if (contentHeight > viewportHeight) {
        const scrollAmount = itemSize; // Scroll one row at a time
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            inventoryScrollOffset = Math.min(contentHeight - viewportHeight, inventoryScrollOffset + scrollAmount);
            drawFishInventory();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            inventoryScrollOffset = Math.max(0, inventoryScrollOffset - scrollAmount);
            drawFishInventory();
        } else if (e.key === 'PageDown') {
            e.preventDefault();
            inventoryScrollOffset = Math.min(contentHeight - viewportHeight, inventoryScrollOffset + viewportHeight);
            drawFishInventory();
        } else if (e.key === 'PageUp') {
            e.preventDefault();
            inventoryScrollOffset = Math.max(0, inventoryScrollOffset - viewportHeight);
            drawFishInventory();
        } else if (e.key === 'Home') {
            e.preventDefault();
            inventoryScrollOffset = 0;
            drawFishInventory();
        } else if (e.key === 'End') {
            e.preventDefault();
            inventoryScrollOffset = contentHeight - viewportHeight;
            drawFishInventory();
        }
    }
});
// 3. Add function to send delete request to server
let isDeletingFish = false;
let pendingDeletions = [];

function deleteFish(fishId) {
    // Prevent multiple rapid deletions
    if (isDeletingFish) {
        // Queue this deletion to process after current one completes
        pendingDeletions.push(fishId);
        return;
    }
    
    isDeletingFish = true;
    
    // Play sound effect first
    playSound('trashcan.mp3', 1);
    
    // Show visual feedback that deletion is in progress
    showStatusMessage("Deleting fish...");
    
    // Send delete request to server
    socket.emit('delete_fish', { fishId: fishId });
    
    // Use a timeout to prevent UI from freezing
    setTimeout(() => {
        // Let the server confirmation handle the actual removal
        // No optimistic deletion to avoid desync issues
        
        // Reset deletion state after a reasonable timeout
        isDeletingFish = false;
        
        // Process any pending deletions
        if (pendingDeletions.length > 0) {
            const nextFishId = pendingDeletions.shift();
            deleteFish(nextFishId);
        }
    }, 500);
}

// helper function
function showStatusMessage(message) {
    // Create or update a status message element
    let statusElement = document.getElementById('statusMessage');
    if (!statusElement) {
        statusElement = document.createElement('div');
        statusElement.id = 'statusMessage';
        statusElement.style.position = 'absolute';
        statusElement.style.bottom = '80px';
        statusElement.style.left = '50%';
        statusElement.style.transform = 'translateX(-50%)';
        statusElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
        statusElement.style.color = 'white';
        statusElement.style.padding = '10px 20px';
        statusElement.style.borderRadius = '5px';
        statusElement.style.zIndex = '1000';
        document.getElementById('gameContainer').appendChild(statusElement);
    }
    
    statusElement.textContent = message;
    statusElement.style.display = 'block';
    
    // Hide after 2 seconds
    setTimeout(() => {
        statusElement.style.display = 'none';
    }, 2000);
}
// Helper functions for fish display
function getFishColor(typeId) {
    const colors = [
        '#F44336', '#E91E63', '#9C27B0', '#673AB7', 
        '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', 
        '#009688', '#4CAF50'
    ];
    return colors[(typeId - 1) % colors.length];
}

function getRarityColor(rarity) {
    switch(rarity) {
        case 'Common': return '#AAAAAA';
        case 'Uncommon': return '#4CAF50';
        case 'Rare': return '#2196F3';
        case 'Epic': return '#9C27B0';
        case 'Legendary': return '#FFD700';
        case 'Mythical': return '#cc0000';
        default: return '#AAAAAA';
    }
}
document.getElementById('closeInstructionsButton').addEventListener('click', function() {
    hideInstructions();
});

function updateBaitDisplay() {
    const baitDisplay = document.getElementById('baitDisplay');
    if (baitDisplay) {
        baitDisplay.textContent = `Bait: ${currentBait}/${MAX_BAIT}`;
        
        // Change color based on bait level
        if (currentBait <= 2) {
            baitDisplay.style.color = '#FF0000'; // Red for low bait
        } else if (currentBait <= 4) {
            baitDisplay.style.color = '#FFA500'; // Orange for medium bait
        } else {
            baitDisplay.style.color = '#000000'; // Black for normal
        }
    }
}
// Function to hide instructions
function hideInstructions() {
    const instructionsCard = document.getElementById('instructionsCard');
    instructionsCard.style.opacity = '0';
    instructionsCard.style.transition = 'opacity 0.3s ease';
    setTimeout(() => {
        instructionsCard.style.display = 'none';
    }, 300);
    
    // Save to localStorage so it doesn't show on every login
    localStorage.setItem('instructionsShown', 'true');
}

// Check localStorage when game initializes
function checkShowInstructions() {
    const instructionsCard = document.getElementById('instructionsCard');
    
    // Only show instructions if they haven't seen them before
    if (localStorage.getItem('instructionsShown') === 'true') {
        instructionsCard.style.display = 'none';
    } else {
        instructionsCard.style.display = 'block';
    }
}

// Add instructions toggle button to the UI
function addInstructionsButton() {
    const button = document.createElement('button');
    button.textContent = 'Game Help';
    button.style.position = 'absolute';
    button.style.top = '10px';
    button.style.left = '50%';
    button.style.transform = 'translateX(-50%)';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.borderRadius = '5px';
    button.style.padding = '8px 15px';
    button.style.cursor = 'pointer';
    button.style.zIndex = '1000';
    
    button.addEventListener('click', function() {
        const instructionsCard = document.getElementById('instructionsCard');
        if (instructionsCard.style.display === 'none') {
            instructionsCard.style.display = 'block';
            instructionsCard.style.opacity = '1';
        } else {
            hideInstructions();
        }
    });
    
    document.getElementById('gameContainer').appendChild(button);
}
// Play sounds with error handling
function playSound(soundFile, volume = 0.5) {
    const currentTime = Date.now();
    
    // Check if the sound is on cooldown
    if (currentTime - soundEffectCooldowns[soundFile] < SOUND_COOLDOWN) {
        // Skip playing if the sound is on cooldown
        return;
    }
    
    // Update the last played time for this sound
    soundEffectCooldowns[soundFile] = currentTime;
    
    try {
        const sound = new Audio(`/${soundFile}`);
        sound.volume = volume;
        
        // Add error handling for audio play
        const playPromise = sound.play();
        
        if (playPromise !== undefined) {
            playPromise.catch(e => {
                console.log(`Sound play failed: ${e}`);
            });
        }
    } catch (e) {
        console.log(`Error playing sound: ${e}`);
    }
}
// Function to initialize music
function setupGameMusic() {
    console.log("Setting up game music system with queue...");
    
    // Define music tracks
    const musicTracks = [
        '/background-music.mp3',
        '/Hateno-Village.mp3',
        '/Kass.mp3',
        '/Sidons-Theme.mp3',
        '/House-Theme.mp3'
    ];
    
    // Track state
    let currentTrackIndex = 0;
    let isMusicPlaying = true;
    let currentAudio = null;
    let isShuffleEnabled = true; // Start with shuffle enabled
    let playHistory = []; // Track played songs for better shuffle experience
    
    // Create UI control
    const musicControl = document.createElement('div');
    musicControl.style.position = 'absolute';
    musicControl.style.top = '120px';
    musicControl.style.left = '0px';
    musicControl.style.zIndex = '1000';
    
    // Add music toggle button
    const musicButton = document.createElement('button');
    musicButton.textContent = '🎵 Music: ON';
    musicButton.style.padding = '5px 10px';
    musicButton.style.backgroundColor = '#4CAF50'; 
    musicButton.style.color = 'white';
    musicButton.style.border = 'none';
    musicButton.style.borderRadius = '3px';
    musicButton.style.cursor = 'pointer';
    
    // Add track info display
    const trackInfo = document.createElement('div');
    trackInfo.style.fontSize = '10px';
    trackInfo.style.color = 'white';
    trackInfo.style.backgroundColor = 'rgba(0,0,0,0.5)';
    trackInfo.style.padding = '2px 5px';
    trackInfo.style.borderRadius = '3px';
    trackInfo.style.marginTop = '3px';
    trackInfo.style.display = 'block';
    
    // Function to play a specific track
    function playTrack(index) {
        // Stop current track if playing
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
        }
        
        // Create new audio element
        currentAudio = new Audio(musicTracks[index]);
        currentAudio.volume = 0.2;
        
        // Add to play history
        playHistory.push(index);
        // Keep history at reasonable size
        if (playHistory.length > musicTracks.length * 2) {
            playHistory.shift();
        }
        
        // Set up event to play next track when this one ends
        currentAudio.addEventListener('ended', playNextTrack);
        
        // Play the track
        const playPromise = currentAudio.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log(`Now playing track ${index + 1}/${musicTracks.length}: ${getTrackName(musicTracks[index])}`);
                updateTrackDisplay();
            }).catch(e => {
                console.error("Music playback failed:", e);
                isMusicPlaying = false;
                updateMusicButton();
            });
        }
    }
    
    // Function to get next track when in shuffle mode
    function getNextShuffledTrack() {
        if (musicTracks.length <= 1) return 0;
        
        // Create array of possible next tracks (excluding current)
        const possibleTracks = Array.from(
            { length: musicTracks.length }, 
            (_, i) => i
        ).filter(i => i !== currentTrackIndex);
        
        // Avoid repeating recent tracks if possible
        if (playHistory.length > 0 && possibleTracks.length > 1) {
            // Get last 2 played tracks if available
            const recentTracks = playHistory.slice(-2);
            // Filter out recently played tracks
            const freshTracks = possibleTracks.filter(i => !recentTracks.includes(i));
            // Use fresh tracks if available, otherwise use all possible tracks
            if (freshTracks.length > 0) {
                possibleTracks.length = 0;
                possibleTracks.push(...freshTracks);
            }
        }
        
        // Pick random track from possible tracks
        const randomIndex = Math.floor(Math.random() * possibleTracks.length);
        return possibleTracks[randomIndex];
    }
    
    // Function to play next track in queue
    function playNextTrack() {
        if (!isMusicPlaying) return;
        
        if (isShuffleEnabled) {
            // Choose a random next track
            currentTrackIndex = getNextShuffledTrack();
        } else {
            // Sequential play - move to next track, loop back to beginning if needed
            currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
        }
        
        playTrack(currentTrackIndex);
    }
    
    // Function to play previous track
    function playPrevTrack() {
        if (!isMusicPlaying) return;
        
        if (isShuffleEnabled && playHistory.length > 1) {
            // Go back in play history
            playHistory.pop(); // Remove current track
            currentTrackIndex = playHistory.pop() || 0; // Get previous track
        } else {
            // Sequential mode - move to previous track, loop to end if at beginning
            currentTrackIndex = (currentTrackIndex - 1 + musicTracks.length) % musicTracks.length;
        }
        
        playTrack(currentTrackIndex);
    }
    
    // Helper to get track name from path
    function getTrackName(path) {
        return path.split('/').pop().replace('.mp3', '').replace(/-/g, ' ');
    }
    
    // Update music button appearance
    function updateMusicButton() {
        if (isMusicPlaying) {
            musicButton.textContent = '🎵 Music: ON';
            musicButton.style.backgroundColor = '#4CAF50';
            trackInfo.style.display = 'block';
        } else {
            musicButton.textContent = '🎵 Music: OFF';
            musicButton.style.backgroundColor = '#777';
            trackInfo.style.display = 'none';
        }
    }
    
    // Update track display
    function updateTrackDisplay() {
        if (currentAudio && isMusicPlaying) {
            const trackName = getTrackName(musicTracks[currentTrackIndex]);
            trackInfo.textContent = `♪ ${trackName} (${currentTrackIndex + 1}/${musicTracks.length}) ${isShuffleEnabled ? '🔀' : '▶️'}`;
        }
    }
    
    // Create navigation buttons
    const controlsRow = document.createElement('div');
    controlsRow.style.display = 'flex';
    controlsRow.style.marginTop = '5px';
    
    // Previous track button
    const prevButton = document.createElement('button');
    prevButton.textContent = '⏮️';
    prevButton.style.flex = '1';
    prevButton.style.padding = '3px';
    prevButton.style.backgroundColor = '#666';
    prevButton.style.color = 'white';
    prevButton.style.border = 'none';
    prevButton.style.borderRadius = '3px 0 0 3px';
    prevButton.style.cursor = 'pointer';
    prevButton.addEventListener('click', function() {
        if (isMusicPlaying) {
            playPrevTrack();
        }
    });
    
    // Shuffle button
    const shuffleButton = document.createElement('button');
    shuffleButton.textContent = '🔀';
    shuffleButton.style.flex = '1';
    shuffleButton.style.padding = '3px';
    shuffleButton.style.backgroundColor = isShuffleEnabled ? '#4CAF50' : '#666';
    shuffleButton.style.color = 'white';
    shuffleButton.style.border = 'none';
    shuffleButton.style.cursor = 'pointer';
    shuffleButton.addEventListener('click', function() {
        isShuffleEnabled = !isShuffleEnabled;
        shuffleButton.style.backgroundColor = isShuffleEnabled ? '#4CAF50' : '#666';
        updateTrackDisplay();
    });
    
    // Next track button
    const nextButton = document.createElement('button');
    nextButton.textContent = '⏭️';
    nextButton.style.flex = '1';
    nextButton.style.padding = '3px';
    nextButton.style.backgroundColor = '#666';
    nextButton.style.color = 'white';
    nextButton.style.border = 'none';
    nextButton.style.borderRadius = '0 3px 3px 0';
    nextButton.style.cursor = 'pointer';
    nextButton.addEventListener('click', function() {
        if (isMusicPlaying) {
            playNextTrack();
        }
    });
    
    // Toggle music state
    musicButton.addEventListener('click', function() {
        isMusicPlaying = !isMusicPlaying;
        
        if (isMusicPlaying) {
            playTrack(currentTrackIndex);
        } else {
            if (currentAudio) {
                currentAudio.pause();
            }
        }
        
        updateMusicButton();
    });
    
    // Add all elements to UI
    controlsRow.appendChild(prevButton);
    controlsRow.appendChild(shuffleButton);
    controlsRow.appendChild(nextButton);
    
    musicControl.appendChild(musicButton);
    musicControl.appendChild(trackInfo);
    musicControl.appendChild(controlsRow);
    
    // Start playing immediately
    setTimeout(() => {
        if (isShuffleEnabled) {
            // Start with a random track
            currentTrackIndex = Math.floor(Math.random() * musicTracks.length);
        }
        playTrack(currentTrackIndex);
    }, 1000);
    
    document.getElementById('gameContainer').appendChild(musicControl);
    console.log("Music queue system setup complete");
}

// Set a timer to add music after game fully loads
// This ensures the gameContainer exists
setTimeout(() => {
    if (document.getElementById('gameContainer')) {
        setupGameMusic();
    } else {
        // If game container doesn't exist yet, try on login success
        socket.on('join_success', () => {
            setTimeout(setupGameMusic, 1000);
        });
    }
}, 1000);

// Enable browser audio context on first user interaction (required by browsers)
document.addEventListener('click', function enableAudio() {
    // Create and destroy an audio context to enable audio
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    audioContext.resume().then(() => {
        console.log("AudioContext enabled by user interaction");
    });
    // Remove this listener after first click
    document.removeEventListener('click', enableAudio);
}, { once: true });
// Add this function to your game initialization (call it from initGame())
function addInstructionsButton() {
    const button = document.createElement('button');
    button.id = 'instructionsButton';
    button.textContent = 'Help';
    button.style.position = 'absolute';
    button.style.bottom = '220px'; 
    button.style.right = '10px';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.borderRadius = '5px';
    button.style.padding = '8px 15px';
    button.style.cursor = 'pointer';
    button.style.zIndex = '1000';
    button.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    
    button.addEventListener('click', toggleInstructions);
    
    document.getElementById('gameContainer').appendChild(button);
}

// Add this function to toggle instructions visibility
function toggleInstructions() {
    const instructionsCard = document.getElementById('instructionsCard');
    
    if (instructionsCard.style.display === 'none') {
        // Show instructions
        instructionsCard.style.display = 'block';
        instructionsCard.style.opacity = '0';
        
        // Animate fade-in
        setTimeout(() => {
            instructionsCard.style.opacity = '1';
            instructionsCard.style.transition = 'opacity 0.3s ease';
        }, 10);
    } else {
        // Hide instructions
        hideInstructions();
    }
}
    </script>
     <div style="position: fixed; bottom: 5px; right: 5px; font-size: 12px; opacity: 0.5;">
        <a href="/admin" >Admin</a>
    </div>
    
</body>
</html>